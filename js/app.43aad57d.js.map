{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Navbar.vue?3ac9","webpack:///./src/views/entries/EntryWithPauseAndRun.vue?b200","webpack:///./src/views/entries/SimpleEntryTemplate.vue?5c3d","webpack:///./src/components/EntryTitle.vue?872b","webpack:///./src/components/EntrySimpleOutput.vue?b71f","webpack:///./src/views/entries/custom/2020/LobbyLayout.vue?685e","webpack:///./src/App.vue?f446","webpack:///./src/views/entries/custom/2020/ConwayCubesView.vue?1437","webpack:///./src/components/Hamburger.vue?386a","webpack:///./data lazy ^\\.\\/.*\\.txt$ namespace object","webpack:///./src/components/EntryInput.vue?a4fe","webpack:///./src/components/EntryFileInput.vue?def5","webpack:///./src/views/Home.vue?6b74","webpack:///./src/components/EntryTemplate.vue?abf7","webpack:///./src/components/EntryChoice.vue?bcb1","webpack:///./src/components/CalendarEntry.vue?8f66","webpack:///./src/views/Entries.vue?ba32","webpack:///./src/App.vue?405e","webpack:///./src/components/Navbar.vue?c990","webpack:///./src/components/Hamburger.vue?9858","webpack:///./src/components/Hamburger.vue?646c","webpack:///./src/components/Hamburger.vue?b0c2","webpack:///./src/components/Hamburger.vue","webpack:///./src/components/Year.vue?5577","webpack:///./src/components/Year.vue?775f","webpack:///./src/components/Year.vue?baa6","webpack:///./src/components/Year.vue","webpack:///./src/state/state.ts","webpack:///./src/components/Navbar.vue?6c59","webpack:///./src/constants/choice.ts","webpack:///./src/components/Navbar.vue?1bdf","webpack:///./src/components/Navbar.vue","webpack:///./src/entries/entry.ts","webpack:///./src/entries/single-entries/2015/not-quite-lisp.ts","webpack:///./src/entries/single-entries/2015/i-was-told-there-would-be-no-math.ts","webpack:///./src/support/best.ts","webpack:///./src/support/geometry.ts","webpack:///./src/entries/single-entries/2015/perfect-spherical-houses-in-a-vacuum.ts","webpack:///./src/entries/single-entries/2015/the-ideal-stocking-stuffer.ts","webpack:///./src/entries/single-entries/2015/intern-elves.ts","webpack:///./src/support/async.ts","webpack:///./src/support/matrix.ts","webpack:///./src/entries/single-entries/2015/probably-a-fire-hazard.ts","webpack:///./src/entries/single-entries/2015/some-assembly-required.ts","webpack:///./src/entries/single-entries/2015/matchsticks.ts","webpack:///./src/support/sequences.ts","webpack:///./src/entries/single-entries/2015/all-in-a-single-night.ts","webpack:///./src/entries/single-entries/2015/elves-look-elves-say.ts","webpack:///./src/entries/single-entries/2015/corporate-policy.ts","webpack:///./src/entries/single-entries/2015/abacus-framework.ts","webpack:///./src/entries/single-entries/2015/knights-of-the-dinner-table.ts","webpack:///./src/entries/single-entries/2015/reindeer-olympics.ts","webpack:///./src/entries/single-entries/2015/science-for-hungry-people.ts","webpack:///./src/entries/single-entries/2015/aunt-sue.ts","webpack:///./src/entries/single-entries/2015/no-such-thing-as-too-much.ts","webpack:///./src/entries/single-entries/2015/like-a-gif-for-your-yard.ts","webpack:///./src/entries/single-entries/2015/turing-lock.ts","webpack:///./src/entries/single-entries/2015/medicine-for-rudolph.ts","webpack:///./src/entries/single-entries/2015/infinite-elves-and-infinite-houses.ts","webpack:///./src/entries/single-entries/2015/rpg-simulator-20xx.ts","webpack:///./src/support/data-structure.ts","webpack:///./src/entries/single-entries/2015/wizard-simulator-20xx.ts","webpack:///./src/support/time.ts","webpack:///./src/entries/single-entries/2015/it-hangs-in-the-balance.ts","webpack:///./src/support/algebra.ts","webpack:///./src/entries/single-entries/2015/let-it-snow.ts","webpack:///./src/entries/single-entries/2015/index.ts","webpack:///./src/entries/single-entries/2016/no-time-for-a-taxicab.ts","webpack:///./src/entries/single-entries/2016/bathroom-security.ts","webpack:///./src/entries/single-entries/2016/squares-with-three-sides.ts","webpack:///./src/entries/single-entries/2016/security-through-obscurity.ts","webpack:///./src/support/random.ts","webpack:///./src/entries/single-entries/2016/how-about-a-nice-game-of-chess.ts","webpack:///./src/entries/single-entries/2016/signals-and-noise.ts","webpack:///./src/entries/single-entries/2016/internet-protocol-version-7.ts","webpack:///./src/entries/single-entries/2016/two-factor-authentication.ts","webpack:///./src/entries/single-entries/2016/explosives-in-cyberspace.ts","webpack:///./src/entries/single-entries/2016/balance-bots.ts","webpack:///./src/entries/single-entries/2016/radioisotope-thermoelectric-generators.ts","webpack:///./src/entries/single-entries/2016/common/assembunny.ts","webpack:///./src/entries/single-entries/2016/leonardos-monorail.ts","webpack:///./src/support/labyrinth.ts","webpack:///./src/entries/single-entries/2016/a-maze-of-twisty-little-cubicles.ts","webpack:///./src/entries/single-entries/2016/one-time-pad.ts","webpack:///./src/entries/single-entries/2016/timing-is-everything.ts","webpack:///./src/entries/single-entries/2016/dragon-checksum.ts","webpack:///./src/entries/single-entries/2016/two-steps-forward.ts","webpack:///./src/entries/single-entries/2016/like-a-rogue.ts","webpack:///./src/entries/single-entries/2016/an-elephant-named-joseph.ts","webpack:///./src/entries/single-entries/2016/firewall-rules.ts","webpack:///./src/entries/single-entries/2016/scrambled-letters-and-hash.ts","webpack:///./src/entries/single-entries/2016/grid-computing.ts","webpack:///./src/entries/single-entries/2016/safe-cracking.ts","webpack:///./src/entries/single-entries/2016/air-duct-spelunking.ts","webpack:///./src/entries/single-entries/2016/clock-signal.ts","webpack:///./src/entries/single-entries/2016/index.ts","webpack:///./src/entries/single-entries/2017/a-maze-of-twisty-trampolines-all-alike.ts","webpack:///./src/entries/single-entries/2017/a-series-of-tubes.ts","webpack:///./src/entries/single-entries/2017/coprocessor-conflagration.ts","webpack:///./src/entries/single-entries/2017/corruption-checksum.ts","webpack:///./src/entries/single-entries/2017/digital-plumber.ts","webpack:///./src/entries/single-entries/2017/knot-hash.ts","webpack:///./src/entries/single-entries/2017/disk-defragmentation.ts","webpack:///./src/entries/single-entries/2017/dueling-generators.ts","webpack:///./src/entries/single-entries/2017/duet.ts","webpack:///./src/entries/single-entries/2017/electromagnetic-moat.ts","webpack:///./src/entries/single-entries/2017/fractal-art.ts","webpack:///./src/entries/single-entries/2017/heard-you-like-registers.ts","webpack:///./src/support/hex-geometry.ts","webpack:///./src/entries/single-entries/2017/hex-ed.ts","webpack:///./src/entries/single-entries/2017/high-entropy-passhprases.ts","webpack:///./src/entries/single-entries/2017/inverse-captcha.ts","webpack:///./src/entries/single-entries/2017/memory-reallocation.ts","webpack:///./src/entries/single-entries/2017/packet-scanners.ts","webpack:///./src/entries/single-entries/2017/particle-swarm.ts","webpack:///./src/entries/single-entries/2017/permutation-promenade.ts","webpack:///./src/entries/single-entries/2017/recursive-circus.ts","webpack:///./src/entries/single-entries/2017/spinlock.ts","webpack:///./src/support/ulam.ts","webpack:///./src/support/field.ts","webpack:///./src/entries/single-entries/2017/spiral-memory.ts","webpack:///./src/entries/single-entries/2017/sporifica-virus.ts","webpack:///./src/entries/single-entries/2017/stream-processing.ts","webpack:///./src/entries/single-entries/2017/the-halting-problem.ts","webpack:///./src/entries/single-entries/2017/index.ts","webpack:///./src/entries/single-entries/2018/frequency.ts","webpack:///./src/entries/single-entries/2018/inventory.ts","webpack:///./src/entries/single-entries/2018/no-matter-how-you-slice-it.ts","webpack:///./src/support/log.ts","webpack:///./src/entries/single-entries/2018/repose-record.ts","webpack:///./src/entries/single-entries/2018/alchemical-reduction.ts","webpack:///./src/entries/single-entries/2018/chronal-coordinates.ts","webpack:///./src/entries/single-entries/2018/the-sum-of-its-parts.ts","webpack:///./src/entries/single-entries/2018/memory-maneuver.ts","webpack:///./src/entries/single-entries/2018/marble-mania.ts","webpack:///./src/entries/single-entries/2018/the-stars-align.ts","webpack:///./src/entries/single-entries/2018/chronal-charge.ts","webpack:///./src/entries/single-entries/2018/subterranean.ts","webpack:///./src/entries/single-entries/2018/mine-cart-madness.ts","webpack:///./src/entries/single-entries/2018/chocolate-charts.ts","webpack:///./src/entries/single-entries/2018/beverage-bandits.ts","webpack:///./src/entries/single-entries/2018/chronal-classification.ts","webpack:///./src/entries/single-entries/2018/reservoir-research.ts","webpack:///./src/entries/single-entries/2018/settlers-of-the-north-pole.ts","webpack:///./src/entries/single-entries/2018/go-with-the-flow.ts","webpack:///./src/entries/single-entries/2018/a-regular-map.ts","webpack:///./src/entries/single-entries/2018/chronal-conversion.ts","webpack:///./src/entries/single-entries/2018/mode-maze.ts","webpack:///./src/entries/single-entries/2018/experimental-emergency-transportation.ts","webpack:///./src/entries/single-entries/2018/immune-system-simulator-20xx.ts","webpack:///./src/entries/single-entries/2018/four-dimensional-adventure.ts","webpack:///./src/entries/single-entries/2018/index.ts","webpack:///./src/entries/single-entries/2019/rocket-tyranny.ts","webpack:///./src/entries/single-entries/2019/program-alarm.ts","webpack:///./src/entries/single-entries/2019/crossed-wires.ts","webpack:///./src/entries/single-entries/2019/secure-container.ts","webpack:///./src/support/intcode.ts","webpack:///./src/entries/single-entries/2019/sunny-asteroids.ts","webpack:///./src/entries/single-entries/2019/universal-orbit-map.ts","webpack:///./src/entries/single-entries/2019/amplification-circuit.ts","webpack:///./src/entries/single-entries/2019/space-image-format.ts","webpack:///./src/entries/single-entries/2019/sensor-boost.ts","webpack:///./src/entries/single-entries/2019/monitoring-station.ts","webpack:///./src/entries/single-entries/2019/space-police.ts","webpack:///./src/entries/single-entries/2019/n-body-problem.ts","webpack:///./src/entries/single-entries/2019/care-package.ts","webpack:///./src/entries/single-entries/2019/space-stoichiometry.ts","webpack:///./src/entries/single-entries/2019/oxygen-system.ts","webpack:///./src/entries/single-entries/2019/flawed-frequency-transmission.ts","webpack:///./src/entries/single-entries/2019/set-and-forget.ts","webpack:///./src/entries/single-entries/2019/many-worlds-interpretation.ts","webpack:///./src/entries/single-entries/2019/tractor-beam.ts","webpack:///./src/entries/single-entries/2019/donut-maze.ts","webpack:///./src/entries/single-entries/2019/springroid-adventure.ts","webpack:///./src/entries/single-entries/2019/slam-shuffle.ts","webpack:///./src/entries/single-entries/2019/category-six.ts","webpack:///./src/entries/single-entries/2019/planet-of-discord.ts","webpack:///./src/entries/single-entries/2019/cryostasis.ts","webpack:///./src/entries/single-entries/2019/index.ts","webpack:///./src/entries/single-entries/2020/binary-boarding/visualizer.ts","webpack:///./src/entries/single-entries/2020/binary-boarding/index.ts","webpack:///./src/entries/single-entries/2020/passport-processing/visualizer.ts","webpack:///./src/entries/single-entries/2020/passport-processing/index.ts","webpack:///./src/entries/single-entries/2020/password-philosophy/visualizer.ts","webpack:///./src/entries/single-entries/2020/password-philosophy/index.ts","webpack:///./src/entries/single-entries/2020/custom-customs/visualizer.ts","webpack:///./src/entries/single-entries/2020/custom-customs/index.ts","webpack:///./src/entries/single-entries/2020/report-repair/visualizer.ts","webpack:///./src/entries/single-entries/2020/report-repair/index.ts","webpack:///./src/entries/single-entries/2020/toboggan-trajectory/visualizer.ts","webpack:///./src/entries/single-entries/2020/toboggan-trajectory/index.ts","webpack:///./src/entries/single-entries/2020/handy-haversacks/index.ts","webpack:///./src/entries/single-entries/2020/support/handheld.ts","webpack:///./src/entries/single-entries/2020/handheld-halting/visualizer.ts","webpack:///./src/entries/single-entries/2020/handheld-halting/index.ts","webpack:///./src/entries/single-entries/2020/encoding-error/visualizer.ts","webpack:///./src/entries/single-entries/2020/encoding-error/index.ts","webpack:///./src/entries/single-entries/2020/adapter-array/index.ts","webpack:///./src/entries/single-entries/2020/seating-system/visualizer.ts","webpack:///./src/entries/single-entries/2020/seating-system/index.ts","webpack:///./src/entries/single-entries/2020/rain-risk/index.ts","webpack:///./src/entries/single-entries/2020/shuttle-search/index.ts","webpack:///./src/entries/single-entries/2020/docking-data/index.ts","webpack:///./src/entries/single-entries/2020/rambunctious-recitation/index.ts","webpack:///./src/entries/single-entries/2020/ticket-translation/communication.ts","webpack:///./src/entries/single-entries/2020/ticket-translation/index.ts","webpack:///./src/entries/single-entries/2020/conway-cubes/communication.ts","webpack:///./src/entries/single-entries/2020/conway-cubes/index.ts","webpack:///./src/entries/single-entries/2020/operation-order/index.ts","webpack:///./src/entries/single-entries/2020/monster-messages/index.ts","webpack:///./src/entries/single-entries/2020/jurassic-jigsaw/index.ts","webpack:///./src/entries/single-entries/2020/crab-cups/index.ts","webpack:///./src/entries/single-entries/2020/allergen-assessment/index.ts","webpack:///./src/entries/single-entries/2020/crab-combat/index.ts","webpack:///./src/entries/single-entries/2020/lobby-layout/index.ts","webpack:///./src/entries/single-entries/2020/combo-breaker/index.ts","webpack:///./src/entries/single-entries/2020/index.ts","webpack:///./src/entries/entryList.ts","webpack:///./src/App.vue?ec60","webpack:///./src/App.vue?640d","webpack:///./src/App.vue","webpack:///./src/views/Home.vue?499f","webpack:///./src/views/Home.vue?42b8","webpack:///./src/views/Home.vue?102e","webpack:///./src/views/Home.vue","webpack:///./src/views/Entries.vue?5fd1","webpack:///./src/components/CalendarEntry.vue?8793","webpack:///./src/support/string.ts","webpack:///./src/components/CalendarEntry.vue?0689","webpack:///./src/components/CalendarEntry.vue?5c0d","webpack:///./src/components/CalendarEntry.vue","webpack:///./src/views/Entries.vue?a808","webpack:///./src/views/Entries.vue?2045","webpack:///./src/views/Entries.vue","webpack:///./src/views/entries/SimpleEntryTemplate.vue?1782","webpack:///./src/components/EntryTemplate.vue?6c11","webpack:///./src/components/EntryTitle.vue?4879","webpack:///./src/components/EntryTitle.vue?5bd7","webpack:///./src/components/EntryTitle.vue?2cb8","webpack:///./src/components/EntryTitle.vue","webpack:///./src/components/EntryInput.vue?2834","webpack:///./src/components/EntryFileInput.vue?8936","webpack:///./src/support/file-reader.ts","webpack:///./src/components/EntryFileInput.vue?c715","webpack:///./src/components/EntryFileInput.vue?eac7","webpack:///./src/components/EntryFileInput.vue","webpack:///./src/components/EntryChoice.vue?63e4","webpack:///./src/components/EntryChoice.vue?33bd","webpack:///./src/components/EntryChoice.vue?8ceb","webpack:///./src/components/EntryChoice.vue","webpack:///./src/entries/embeddedData.ts","webpack:///./src/components/EntryInput.vue?797d","webpack:///./src/components/EntryInput.vue?df56","webpack:///./src/components/EntryInput.vue","webpack:///./src/components/EntryTemplate.vue?a911","webpack:///./src/components/EntryTemplate.vue?ea80","webpack:///./src/components/EntryTemplate.vue","webpack:///./src/components/EntrySimpleOutput.vue?3713","webpack:///./src/components/EntrySimpleOutput.vue?8f54","webpack:///./src/components/EntrySimpleOutput.vue?64a1","webpack:///./src/components/EntrySimpleOutput.vue","webpack:///./src/views/entries/SimpleEntryTemplate.vue?8c9c","webpack:///./src/views/entries/SimpleEntryTemplate.vue?211a","webpack:///./src/views/entries/SimpleEntryTemplate.vue","webpack:///./src/views/entries/custom/2020/TicketTranslationView.vue?7166","webpack:///./src/views/entries/custom/BaseMessageTemplate.vue?00bc","webpack:///./src/views/entries/custom/BaseMessageTemplate.vue?74c6","webpack:///./src/views/entries/custom/BaseMessageTemplate.vue?94ce","webpack:///./src/views/entries/custom/BaseMessageTemplate.vue","webpack:///./src/views/entries/custom/2020/TicketTranslationView.vue?b828","webpack:///./src/views/entries/custom/2020/TicketTranslationView.vue?2f82","webpack:///./src/views/entries/custom/2020/TicketTranslationView.vue","webpack:///./src/views/entries/custom/2020/ConwayCubesView.vue?fbc3","webpack:///./src/support/error.ts","webpack:///./src/views/entries/custom/2020/ConwayCubesView.vue?6229","webpack:///./src/views/entries/custom/2020/ConwayCubesView.vue?a520","webpack:///./src/views/entries/custom/2020/ConwayCubesView.vue","webpack:///./src/views/entries/custom/2020/LobbyLayout.vue?318c","webpack:///./src/views/entries/custom/2020/LobbyLayout.vue?7377","webpack:///./src/views/entries/custom/2020/LobbyLayout.vue?ef1e","webpack:///./src/views/entries/custom/2020/LobbyLayout.vue","webpack:///./src/views/entries/EntryWithPauseAndRun.vue?09b4","webpack:///./src/views/entries/EntryWithPauseAndRun.vue?761f","webpack:///./src/views/entries/EntryWithPauseAndRun.vue?f96b","webpack:///./src/views/entries/EntryWithPauseAndRun.vue","webpack:///./src/entries/entryMap.ts","webpack:///./src/router.ts","webpack:///./src/main.ts","webpack:///./src/views/entries/custom/BaseMessageTemplate.vue?aaf6","webpack:///./src/views/entries/custom/2020/TicketTranslationView.vue?6526"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","jsonpScriptSrc","p","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","onScriptComplete","script","document","createElement","charset","timeout","nc","setAttribute","src","error","Error","event","onerror","onload","clearTimeout","chunk","errorType","type","realSrc","target","message","name","request","undefined","setTimeout","head","appendChild","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","slice","map","webpackAsyncContext","req","then","code","ids","id","keys","_vm","this","_h","$createElement","_c","_self","attrs","entryByYears","staticRenderFns","staticClass","on","toggleNavbar","_v","style","_l","year","selectedYear","$event","selectYear","_e","entry","_s","title","lastEntryName","$emit","extend","props","size","Number","computed","lineStyle","width","height","margin","selected","Boolean","baseState","dates","updateYear","parseInt","Choice","components","Year","Hamburger","watch","$route","to","from","navbarActivated","methods","entryList","list","fullEntryList","reducedList","Math","max","shouldTruncateList","years","navbarStyle","left","entryForFile","first","second","metadata","simpleOutputCallbackFactory","output","avoidOutput","outputLine","shouldClear","Array","isArray","join","JSON","stringify","isStop","executeEntry","choice","lines","outputCallback","isCancelled","pause","additionalInputReader","screen","isQuickRunning","stopTimer","sendMessage","callback","basePause","shouldAutoStop","wrappedPause","times","resultOutput","resultOutputCallback","line","setAutoStop","log","notQuiteLisp","count","split","reduce","acc","next","position","stars","iWasToldThereWouldBeNoMath","sizes","areas","minArea","min","totalArea","biggest","smallestPerimeter","volume","a","maxNumber","b","minNumber","ascending","comparator","currentBest","is4d","w","is3d","z","is2d","isBounds","x","y","isInBounds","topLeft","is","other","manhattanDistance","sum","sumCoordinate","CCoordinate","diff","scalarCoordinates","up","down","right","upLeft","upRight","downLeft","downRight","directionList","coordinate","direction","fillWithZero","ascendingCompare","bounds","getBoundaries","points","getRanges","maxX","minX","maxY","minY","oppositeCoordinate","diffCoordinate","abs","getFullSurrounding","filter","deltas","neighbour","minComparator","maxComparator","forEach","add","getCoordinateForGrid","index","rows","floor","serialization","serialize","els","deserialize4d","RangeError","deserialize3d","deserialize","multiplyCoordinate","perfectSphericalHousesInAVacuum","visited","Set","startPosition","directionMapper","currentPosition","currentPositions","hasLeadingZeros","theIdealStockingStuffer","trim","hashed","hashAsciiStr","calculateHasDuplicates","buildGroups","res","isNice","vowels","howManyVowels","indexOf","hasDuplicates","hasForbidden","conditions","hasNicePairs","pairs","lastIndexOf","hasNiceTrios","trios","trio","internElves","niceLines","forEachAsync","action","element","mapAsync","setTimeoutAsync","voidIsPromise","casted","isPromise","_delta","mapper","FixedSizeMatrix","coordinateCalculator","delta","fillValue","fillValueFactory","opposite","indexCalculator","startAccumulator","cell","predicate","findOneWithCoordinate","awaited","newMatrix","rowIndex","startIndex","endIndex","stringifier","serialized","overRows","row","toArray","customComparer","thisFlatData","otherFlatData","tuple","probablyAFireHazard","field","startsWith","_","tokens","top","bottom","set","fill","parsed","destination","operation","operator","input","parseNumberOrString","amount","isNumber","toString","wire","state","has","rule","handleOperation","isNaN","someAssemblyRequired","Map","newInput","newValue","countRealLetters","isEscaped","skip","sliced","realCount","countEncoded","matchsticks","overhead","encoded","subsequenceGenerator","subsetGenerator","permutationGenerator","buildGroupsFromSeparator","howManySameAtEnd","sequence","counter","lastElement","groupBy","current","array","start","end","howMany","sub","concat","startElement","otherElements","perm","step","isSeparator","hadItems","item","allInASingleNight","edges","distance","places","nodes","flatMap","bestResult","path","cost","stepCost","edge","includes","sayNumber","findSequenceLength","elvesLookElvesSay","transformed","limit","charCodeAt","reverse","carry","String","fromCharCode","allEqual","testPassword","corporatePolicy","startPassword","password","countNumbers","skipReds","values","abacusFramework","parse","numbers","participants","rules","sign","adjacents","calculateValue","assignment","assignees","matchingRules","knightsOfTheDinnerTable","bestValue","NEGATIVE_INFINITY","participant","parseReindeers","rest","movement","speed","duration","calculateDistance","reindeer","time","period","baseDistance","restOfTime","lastMovementTime","lastDistance","reindeerOlympics","reindeers","distances","sort","maxTime","winner","generateRecipes","endsWith","ingredient","capacity","durability","flavor","texture","calories","ingredients","total","otherIngredients","permutation","f","calculateSingleTotal","single","characteristic","recipe","totals","calculateCalories","scienceForHungryPeople","score","targetCalories","ticket","children","cats","samoyeds","pomeranians","akitas","vizslas","goldfish","trees","cars","perfumes","parseSues","firstSeparator","checkSue","sue","argTicket","checkSueRanges","auntSue","sues","findCombinations","quantities","noSuchThingAsTooMuch","setFlatData","leaveCornersOn","newField","copy","onEveryCell","onNeigbours","likeAGifForYourYard","iteration","steps","createStartState","ir","instr","args","instruction","arg","executeInstruction","newIr","program","turingLock","createCandidates","serializeRule","parseMolecule","flatTo","toUpperCase","separator","findIndex","molecule","medicineForRudolph","candidate","appearsInHowManyRules","bottomRules","noFromAtoms","tos","noFrom","isBottom","unique","infiniteElvesAndInfiniteHouses","flatData","ceil","shop","weapons","damage","armor","rings","hitPoints","fight","player","monster","fPlayer","fMonster","rpgSimulator20xx","bossState","minExpense","POSITIVE_INFINITY","weapon","chosenRings","expense","hasWon","maxExpense","startNode","append","iterator","remove","prev","removeNext","removePrev","_size","isEmpty","node","firstNode","lastNode","newFirst","toReturn","dictionary","ensureKey","maxLength","oldNext","newNext","DoubleLinkedNode","oldPrev","newPrev","subNodes","Tree","_next","_prev","CircularDoubleLinkedNode","toRemove","removePrevious","spellCost","spell","paySpell","mana","spentMana","launchSpell","playerState","poison","recharge","shield","applyEffects","newPlayerState","newBossState","bossDamageTurn","hurtPlayer","spells","canLaunchSpell","playTurn","playerHpLoss","afterStart","hasLost","afterEffects","afterSpell","afterSecondEffects","afterBoss","startGameState","hardMode","states","bestWinState","updateBestState","cast","initGameState","wizardSimulator20xx","gameState","startTime","Date","getTime","ratio","getDelta","serializeTime","getExpected","ms","seconds","minutes","hours","days","padStart","itHangsInTheBalance","packages","totalWeight","subsets","expectedTotal","interestingSubsets","timeCalculator","getExpectedSerialized","sorted","trunkCandidates","mod","exp","factorial","fromRowColumn","column","firstOfRow","increments","rightDelta","words","columnIndex","letItSnow","coordinates","base","factor","BigInt","noTimeForATaxicab","currentDirection","currentCoordinates","coordinateToNumber","coordinateToStrange","bathroomSecurity","parseSecondLines","started","squaresWithThreeSides","isValid","dashIndex","squareIndex","sectorID","checksum","encryptedName","room","newName","frequency","letter","entries","localeCompare","calculated","securityThroughObscurity","candidates","randrange","random","randomCharacter","getCharacter","hash","getCharacterAndPosition","howAboutANiceGameOfChess","lastTime","signalsAndNoise","section","hypernet","sections","hypernets","isHypernet","hasABBA","supportsTLS","ip","hyper","supportsSSL","babs","bab","internetProtocolVersion7","ips","matching","rect","rectangle","rotateRow","by","rotateColumn","el","twoFactorAuthentication","countExpandedLength","markerEnd","marker","repeat","toRepeat","nestedLength","explosivesInCyberspace","bot","high","low","toExecute","botState","outputState","stop","canExecute","doExecute","executePending","chips","getState","giveTo","chip","bin","createBot","balanceBots","instructions","machine","executeBeforeEveryInstruction","execute","getOutput","currentFloor","floors","_state","floorId","items","newFloorIndex","newFloor","newBuilding","clone","generators","isSubsetValid","Building","toColumn","elementMap","nextMapped","out","columns","serializedFloor","cleaned","replace","floorOrdinal","parseOrdinal","generatorIndexes","microchipIndexes","generatorIndex","microchipIndex","building","setFloors","ordinal","valid","toLowerCase","queue","visitedStates","serializeToEquivalent","candidateItems","currentFloorItems","candidatesToBring","moved","move","newSteps","isAllOnLastFloor","radioisotopeThermoelectricGenerators","additionalElements","types","addToFloor","isRegister","isSingleArgument","pop","parseArgument","argumentToValue","registers","shouldIncreaseCurrentInstruction","currentInstruction","instructionToChange","register","maxOutLength","simpleLine","executionCallback","programExecution","emptyState","leonardosMonorail","calculateDistancesGenericCoordinates","fieldGetter","distanceCalculator","getSurrounding","serializer","stopAt","distanceMap","visitQueue","startCell","forceStop","surrounding","withDistance","sWithDistance","v","calculateDistances","countParity","parity","calculatorBuilder","secretNumber","aMazeOfTwistyLittleCubicles","calculator","maze","tile","salt","incrementHashes","howManyToAdd","nextIndex","newLength","findTriplet","hasQuintuplet","rawTarget","hashes","triplet","targetIndex","oneTimePad","hashCalculator","currentIndex","level","moveDisc","disc","discs","_time","balls","addNewBall","moveDiscs","moveBalls","findWinner","removeInvalidBalls","debug","ball","launchedAt","find","matchingDisc","timingIsEverything","passTime","dragonStep","fillDisk","calculateChecksum","dragonEverything","diskSize","dragonChecksum","isString","secret","isValidCharacter","twoStepsForward","MIN_VALUE","spreads","getSafe","mapCell","center","traps","evolve","buildMap","startLine","prettify","cells","countSafe","likeARogue","lastLine","integerLogarithm","isLower","anElephantNamedJoseph","howManyElves","elves","presents","stealFrom","logarithm","lastSteal","elvesCount","_ranges","mergeRanges","ranges","addRanges","firewallRules","firstRange","minValue","maxValue","nextCandidate","range","applyRule","tokenized","rotate","rindex","rotateOf","reverseIndex","scrambledLettersAndHash","parseCoordinates","token","startFrom","substr","parseSize","parseLine","used","available","matrix","fullField","original","fromNode","toNode","isViable","onEveryCellSync","neighbours","coords","canMove","isTarget","BinaryHeap","command","gridComputing","myPosition","findOne","oldCommands","oldStates","read","rawInput","old","hasAdditionalInput","safeCracking","executingProgram","executingState","getValue","ln","customComponent","targets","serializeState","reachedTargets","airDuctSpelunking","outputField","bestReached","nextCell","newReached","matchingTarget","queueElement","clockSignal","addition","check","last","aMazeOfTwistyTrampolinesAllAlike","axisFromDirection","expectedFromDirection","axis","isLine","travel","letterCallback","currentCell","nextCoordinate","rotations","candidateDirections","rotation","resultStates","aSeriesOfTubes","trimEnd","maxLineSize","padEnd","flat","startingPoint","foundLetters","lastPosition","getConstantOrRegister","callbacks","increasedIndex","gcr","mulCallback","coprocessorConflagration","mulCount","isPrime","h","corruptionChecksum","internalChecksum","small","big","sourceToken","targetToken","source","_map","ensureLink","pipeDefinition","addLink","pipeDefinitions","definition","addDefinition","stack","toVisit","linked","getLinked","adjacency","digitalPlumber","definitions","graph","addDefinitions","dfs","getNodes","reverseWrap","elements","startPortionLength","reversePortion","reverseSimple","skipSize","knotHash","lengths","circle","calculateKnotHash","baseSequence","decodedInput","group","diskDefragmentation","bits","generateDisk","setBitsCount","disk","diskMatrix","regionCount","emptyRegion","generatedLines","seed","duelingGenerators","seedA","seedB","factorA","factorB","generator","getNext","mapped","same","isReceive","receive","recoverCallback","soundCallback","duet","lastSound","hasRecovered","sound","aIndex","bIndex","aRegisters","bRegisters","a2bPipe","b2aPipe","isAWaiting","isBWaiting","hasAEnded","hasBEnded","ports","findStrongestBridge","nextPort","component","remainingComponents","freePort","createAllBridges","bridge","recursiveBridges","tail","electromagneticMoat","bridges","interestingBridges","bridgesWithCounts","bestBridge","newGrid","generateAllSymmetries","symmetries","symmetry","isSameAs","grid","offset","gridResult","cOffset","splitWithDelta","fullGrid","subGrid","subSize","resultGrid","setCoordinate","leftFlat","rightFlat","leftSize","sqrt","rightSize","baseRuleMatch","rightGrid","iterate","splitGrids","mappedGrids","fractalArt","startGrid","currentMax","calc","existing","checkCondition","condition","leftValue","update","heardYouLikeRegisters","parseInstructions","executeInstructions","getValues","sumHexCoordinates","getHexSurrounding","pointyHexDirections","flatHexDirections","northWest","southEast","northEast","southWest","north","south","west","east","hexManhattanDistance","directions","hexEd","maxDistance","highEntropyPasshprases","uniqueLines","uniqueWords","word","findMatching","lastDigit","previous","inverseCaptcha","circular","matchingSequence","shiftIndex","maxIndex","newState","toDistribute","memoryReallocation","createdStates","lastSerialization","depth","tick","Scanner","cloneField","sparseField","maxDepth","scanner","tickField","packetScanners","collisions","currentScanner","delay","baseField","hasCollided","parseTuple","rawPos","rawSpeed","rawAcc","acceleration","updateParticle","particle","newSpeed","newPosition","serializeCoordinate","createCollided","particles","collision","particleSwarm","accelerations","vs","lowestAcceleration","lastCollision","currentStep","oldLength","permutationPromenade","programs","programListGenerator","reordered","dance","dances","currentRatio","requiredIndex","identifier","swap","temp","weightToParse","weight","buildTree","startTree","tree","subTrees","child","subTree","appendTree","isUnbalanced","findUnbalancedIndex","weights","isMinUnbalanced","checkWeight","headWeight","childrenResults","unbalancedResults","balancedResults","childrenWeights","unbalancedIndex","otherIndex","requiredWeight","recursiveCircus","bottomValue","findBottom","checkResult","withRightSide","onlyRightHand","rightHandValues","leftValues","spinlock","buffer","lastAdd","vArg","findSquareSize","sideDistance","sideCalculators","middle","middlePoint","findSideMiddlePoint","root","deserializeCoordinate","setDelta","fromCoordinate","spiralMemory","squareValue","getCoordinatesFromValue","toDo","nextIteration","directionOrder","sizeY","lineLengths","sizeX","sporificaVirus","startSize","toMatrix","midX","midY","virus","infectionCount","parseGarbage","parseGroup","suggestedIndex","garbage","isGarbage","baseScore","localScore","additionalScore","countGarbage","streamProcessing","getTape","turingData","tape","mainTape","negativeTape","getCell","setCell","calculateStep","nextState","instance","matchingState","matchingRule","write","getLastWord","lastToken","getLastNumber","getLastCell","number","parseRule","startState","0","1","haltingProblem","currentFrequency","trimmed","firstRoundOfFrequencies","foundFrequencies","found","some","createWordCounter","hasNLetters","currentCount","checksumCounter","hasTwoLetters","hasThreeLetters","amountOfTwoLetters","amountOfThreeLetters","stringLength","spliced","duplicates","hasFoundDuplicate","isFirstTime","parseRectangle","noSpaces","normalizedDelimiters","fromCoupleToCoordinate","argSplit","mapCreator","rectangles","isCandidate","executeOnMap","argMap","warn","guardID","minute","dateLastIndex","dateText","wakes","fallsAsleep","dateToken","idStartIndex","idEndIndex","post","compare","guardSleeps","parseSleeps","guardIDKey","nestedGuardID","sleeps","totalSleep","howMuch","curr","bestMinute","howManyIntervals","interval","isSleepingInMinute","mostSleepingMinute","totalMaxSleep","maxSleep","isAsleep","currentGuardSleep","polymerText","explodePolymer","unitList","unit","cleanPolymer","RegExp","exploded","parsePoints","territoryPoints","offsets","numberOffsets","nextElement","newCoordinate","newDistance","gridStatus","newElement","status","bestArea","manhattan","distanceSum","couple","dependency","nodeName","ensureNode","dependentFrom","wip","isDone","hasDependencies","dependencies","getNextNode","howManyWorkers","workers","done","currentSecond","nextNode","workerIndex","targetTime","subValue","getTree","numberOfChildren","numberOfMetadata","parsedMetadata","newStart","printMetadata","argTree","calcMetadataSum","numberOfPlayers","lastMarble","marbleNodes","nextMarble","lastPlayer","scores","playerID","marble","currentScore","currentHead","players","game","addMarble","switchPlayer","highestScores","MovablePoint","firstPart","secondPart","coordinateTokens","speedTokens","getArea","FromLine","lastBoundaries","lastPoints","newPoints","boundaries","mappedPoints","dataMatrix","iterationCounter","sumTable","table","originalTable","originalLine","currentValue","getFuelStatus","lesser","countNegative","greater","countPositive","currentSum","subtract","area","getRackID","powerLevel","cellSizes","serial","populate","bestPoint","toJSNumber","cellSize","getAreaSum","PlantStatus","toPlantStatus","full","empty","initialStatus","patterns","fixEmptyPots","newStatus","nextFive","visitToRight","foundDifferent","pattern","newGreenhouse","Greenhouse","emptyBufferSize","consecutiveEmptyPots","prepend","filled","greenhouse","passGeneration","lastSum","diffs","generations","todo","initialState","inputMatrix","isInputCart","inputToDirection","intersectionsPassed","crashed","intersectionRotations","inputGetter","handleTurn","handleIntersection","turn","getRotation","carts","internalTicks","crashList","cartDirection","hideCart","moveCarts","incrementTicks","skipCarts","matchingCarts","cart","squareSize","padding","baseCoordinates","color","isVertical","isHorizontal","isCrashed","cartList","getOrderedCarts","handleInput","checkCollision","colliding","crash","mineCartMadness","printer","requireScreen","toDrawable","hasCrashes","crashes","remainingCarts","moveElf","recipes","interestingRecipes","numberOfSteps","currentFirst","checkIfSame","addMemory","nestedMemory","targetPattern","memory","units","isAlive","isFieldType","isUnit","unitType","adjacentOffsets","adjacentCoordinates","inputLines","defaultPower","Units","u","powerGenerator","attackPower","hitpoints","attackInRange","editableField","rangePositions","enemiesInRange","enemyToAttack","suffersAttack","positionsToVisit","foundAt","interestingPositions","inRangeCoordinates","targetPosition","interestingFirstSteps","stepQueue","nextStep","nextStepValue","inRange","moveTo","newEditable","outputLines","gameScore","wrapOutputToClean","cleanEveryNOutput","forceShouldClear","fromLines","round","startingElves","survivors","codeList","lineNumber","Instruction","setCode","mapping","g","instructionPointerRegister","instructionRange","newI","nextInstructionAddress","calculatedValue","registerAddress","newRegisters","Machine","rab","ra","isTokenValid","before","sameAs","after","testMachineFactory","testCreator","opCode","tests","test","calibrationTokens","parseCalibrationTokens","validCodes","allCodes","toBeMapped","puzzleLines","ins","calibrationLines","groupped","getList","encodedInstruction","complete","splitLine","scanLineToClay","rangeToValues","xs","ys","clayCells","interestingCoordinates","waterCoordinate","takeTurn","oldWaterState","downer","downerCell","fillTowards","isStable","fillWith","isClosedOn","starts","ends","clayCoordinates","world","addWater","reachedCells","dryCells","isCell","worldStates","worldStateList","worldStateMap","worldStateLoop","loopBaseIndex","newWorld","World","adjacent","oldCell","calculateNew","takeTurns","lumberTally","treeTally","resourceValue","pointer","iterations","isExecutable","oldMachine","modVal","print","iterationBatch","groups","currentGroup","openCount","currentChar","isGroup","bfsVisit","dirs","visitCallback","argState","areStateEqual","firstElement","resultState","deduplicateStates","areStatesEqual","toKeep","toRoomCoordinates","doors","baseMatrix","resultMatrix","door","dx","dy","aRegularMap","newCellCount","alreadyVisited","nullTokens","resultRoom","interestingDistances","chronalConversion","uniques","lastFour","fourValue","nDelta","erode","serializeNode","tool","getValidTools","erosionLevel","matrixSerializer","modeMaze","erosionMatrix","createErosionMatrixFromInput","resultPath","calculatePath","weightedGraph","validTools","neighbourNodes","nCoord","nErosion","nTools","otherTool","addNode","posToken","rToken","radius","experimentalEmergencyTransportation","nanobotInfo","bestNanobot","nanobotsInRange","nanobot","distanceRanges","segments","pos","maxCount","bestPos","bestEnd","updateBestEnd","targetable","army","getDamage","getFightOrder","armies","chooseOrder","effectivePower","getEffectivePower","initiative","withTarget","immunities","abilities","damageType","basePower","weaknesses","fightRound","fightOrder","hp","parseAbilities","singleSections","damageTypes","parseGroups","damageWordIndex","initiativeIndex","abilitySection","rawArmy","armyLines","boostArmy","countUnits","immuneSystemSimulator20XX","winningArmy","hasImmuneWon","immuneSystemArmyName","boostingBy","isDraw","clonedArmies","lastUnits","newUnits","nodeMap","addDirectEdge","deserializeNode","allNodes","constellations","constellation","visit","nodeList","getNodeList","fourDimensionalAdventure","outer","inner","addEdge","findConstellations","fuelCalculator","mass","intelligentFuelCalculator","requirement","embeddedData","joined","handleSum","instructionPointer","handleCode","handleMult","aggregator","firstParameter","secondParameter","storageAddress","programAlarm","mapDirection","updatePosition","directionCoordinate","parseWire","getIntersection","comparer","comparison","crossedWires","firstWire","secondWire","firstCoordinates","getCoordinates","secondCoordinates","intersection","minDistance","sortedFirst","sortedSecond","movements","positions","isValidPassword","maxRepeating","stringed","hasSame","repeating","secureContainer","parameterMap","2","3","4","5","6","7","8","9","parseOperation","op","parameters","modes","parameterModes","missing","getMemoryAddress","operationExecutorMap","newPointer","inputGenerator","inputList","memoryDump","address","close","relativeBase","isStopExecution","closeResult","flag","stopExecution","parseMemory","getParameter","parameterMode","errorCode","getOperationParameter","getParameters","params","writeMemory","parameterNumber","parameter","ret","sunnyAsteroids","isFirst","orbiting","fillDistance","parentCode","parentNode","getChain","currentNode","getFirstIntersection","otherSet","planet","universalObritMap","orbit","mine","santa","mineChain","santaChain","firstIntersection","generateConnector","startingInput","additionalOutput","outputBuffer","nextReadIndex","resolver","rejector","isClosed","generatePermutations","subs","amplificationCircuit","baseMemory","permutations","signal","phase","isLast","hasExecuted","inConnector","outConnector","connector","loopConnector","spaceImageFormat","inputSize","layerSize","layers","newLayer","smallestLayer","layer","zeros","ones","twos","currentLayer","sensorBoost","rawCells","fillVisibilities","asteroids","asteroid","fillVisibility","asteroidsWithVisibility","isHidden","otherAsteroid","mainVector","candidateVector","coeff","xCoeff","yCoeff","canSee","monitoringStation","getVisibilities","maxVisibility","getAsteroids","station","topVisible","howManyKilled","howManyToKill","visible","killList","polar","atan2","PI","toKill","killedCoordinate","deserializeRotation","serializeColor","deserializeColor","spacePolice","currentPos","filtered","isPaint","stepComparer","distinct","outRows","addCoordinate","emptyCoordinate","parsePlanets","velocity","updater","extractor","toUpdate","pExtracted","oExtracted","baseUpdaters","positionExtractor","velocityExtractor","gravityStep","planets","updaters","outputPlanets","getSum","getEnergy","serializeCoordinates","serializePlanet","serializeTuple","getLcm","nBodyProblem","repetitions","currentPlanets","lcmRepetition","tileList","tileDeserializer","tileVisualize","tileColor","carePackage","tiles","parseTiels","blocks","visualization","screenMapTiles","visualizeTiles","currentPaddleX","currentBallX","updateTileFeedback","maxPadding","drawableSize","serializeElement","serializeChain","needs","serializeChains","parseElement","raw","targetName","baseName","remainingMap","ensure","howManyCanTake","k","oreRequirement","closed","intLog","toCreate","youNeed","_remainingMap","howManyRequired","askFor","chain","howManyNeedToBuild","price","prices","finalResult","spaceStoichiometry","chains","remain","targetAmount","storageOres","newTarget","under","over","guess","needed","commands","getCandidates","cellGetter","getEmptySurrounded","startingCells","coordinateToKey","getDistances","nearest","findNearestToDiscover","findCommandsForUnkown","lastKnown","unknown","localCommands","getCommand","canGo","where","firstOrDefault","cellMap","startingCell","visitingQueue","fromCell","toCell","lineIndex","cellIndex","Field","oxygenSystem","movingTo","suggestedCommands","oxygenPosition","currentIteration","answer","suggestion","findCommandsToNearestUnkown","getDistance","suggestedDelay","basePattern","applyPattern","applyPatternIteratively","howManyTimes","localBasePattern","realIndex","Pattern","flawedFrequencyTransmission","default","take","repeatedInput","interestingDigits","startIterationTime","getRobotDirection","intersections","isIntersection","getIntersections","alignment","shouldDebug","currentSteps","forward","moveForward","isNextIntersection","tryRight","tryLeft","every","context","newCellPosition","fieldLines","setAndForget","fromBuffer","getAlignment","getMovements","serializedMovements","findCompressed","functions","toSend","replaced","aCandidate","bCandidate","cCandidate","nextSend","totalIterations","isCandidateTooLong","aReplaced","replaceCandidate","bReplaced","cReplaced","candidateName","serializedCandidate","re","newMovements","xSize","ySize","isFixedCell","isRawKey","manyWorldInterpretation","matrixStart","expectedOpenDoors","traverseMatrix","matrixStarts","openDoors","cs","cache","serializedState","cachedValue","reachableKeys","origin","reachable","nestedTotals","newOpenDoors","nestedDistance","bestNestedTotal","serializePoint","tractorBeam","howManyPulled","toServe","nextToServe","startPoint","rowData","expectedSize","isPulled","rowStart","setRowData","lastRowInfo","rowLength","interestingTopRow","topRowInfo","deltaX","topStart","topLength","rowDataEntry","firstLetter","firstNeighbours","ci","isLetter","secondLetter","floorNeighbour","analyzeMatrix","portals","getBorder","bottomRight","isInBorder","donutMaze","portalMap","createPortalMap","portaled","border","depthIncrement","newDepth","endDistance","portalNameMap","portal","ls","springdroidAdventure","executeAscii","program5","nextInput","coefficients","newCoefficients","an","aInverted","getCoefficients","startCoefficients","coefficientCalculator","deal","increment","cut","slamShuffle","applyTo","newCoeff","invert","pow","checkCoeff","inv","isPacket","FLAG","categorySix","inputQueue","sentPackets","receivedPackets","shouldClose","emptyPromise","nextPacket","packetSender","packet","otherResolver","natPacket","lastNatY","isIdle","isFromNat","innerSize","getCenter","outerSize","bugCounter","main","adjacentCellPositions","adjacentCells","adjacentCellPosition","isExternalBorderCoordinate","passDepthTime","ps","extendDepths","nBugs","handleCellTimePass","passPlanetTime","newPlanet","getAdditionalDepths","externalBorderBugs","internalBorderBugs","sortDepths","additional","planetOfDiscord","simpleSerialize","basePlanet","depths","cryostasis","inputBuffer","exploration","exploringLocation","exploreResult","explored","autoMovements","inventory","isPopulating","hacking","isHacking","dropping","lastDrop","fullInventory","currentInventory","toRecover","isTooMuch","possibleMovements","populating","autoTake","enable","toTake","movementMap","handleCustomCommand","createMap","executeCommand","subset","hasDropped","drop","wouldDrop","toDrop","buildVisualizer","screenBuilder","seats","seat","constants","seatSize","internalSpacing","seatOffset","expected","screenSize","drawables","setManualRender","drawable","buildDrawable","forceRender","viewCoordinates","binaryBoarding","visualizer","boards","setup","setSeatOwned","supportsQuickRunning","passportIndex","passports","fields","fieldFullSize","fieldColumns","fieldRows","externalSpacing","passportSize","passportOffset","fieldOffset","screenWidth","heightCalculator","passportDrawables","screenPrinter","validFields","fieldCoordinates","passport","currentPassport","expectedKeys","delete","getInvalidFields","invalid","isValidField","hasFourDigits","intValue","suffix","expectedEyes","passportProcessing","setupPassports","validPassports","setWrongFields","setValid","constantsBuilder","expectedPasswords","spacing","lineHeight","passwordsPerColumn","indicatorSize","columnLength","lineMaxLength","passwords","indicators","letterSize","buildScreen","passwordIndex","indexes","drawablePassword","selectedLetters","header","minRepetitions","maxRepetitions","isLineValid","passwordLine","isLineReallyValid","targetIndexes","passwordPhilosophy","runEntry","passwordChecker","passwordLines","setupPasswords","satisfied","colorPassword","letterColumns","letterRows","letterSpacing","letterOffset","groupSpacing","groupSize","groupOffset","screenSizeBuilder","clear","ok","letters","clearLetters","getGroupIndex","getIndex","clearPreviousLetters","iLetter","letterCoordinates","letterViewCoordinates","totalDrawables","intersect","buildAnswers","customCustoms","startGroup","answers","addLetter","endGroup","setLetters","updateVisualizerFound","updateVisualizerCurrent","visualizerIndex","maxOrMin","seedVisualizer","seedInstructions","cellWidth","maxHeight","indicatorHeight","screenHeight","xCalculator","mapColor","minCurrent","maxCurrent","candidateCoordinates","newX","updateDeadCandidateVisualizer","toVisualize","findProd","reportRepair","fullCellSize","collides","tobogganTrajectory","setupField","slope","currentCoordinate","moveToboggan","candidateSlopes","resetField","parseContainingBags","bags","quantity","splitIndex","mainColor","contains","handyHaversacks","resultOutputcallback","reverseRules","results","mainTarget","toExplore","newCandidates","directRules","hasToHave","nested","nestedQuantity","interceptor","changeInstruction","instructionChanger","nextInstructionIndex","nextInstruction","shouldContinue","shouldChangeInstruction","programSize","indicatorSpacing","programSpacing","programOffset","sizeIncrement","programNumber","updateSize","instances","expectedFill","toDraw","drawableProgram","instructionsToDraw","indicator","handheldHalting","executed","setInterceptor","beforeOrAfter","setStatus","setExecuted","executions","inst","executionIndex","execution","setInstructionChanger","numberSize","numberSpacing","numberOffset","bagColumns","bagRows","bagSize","bag","hasBag","baseSize","bigBagSizeBuilder","weaknessScreenSizeBuilder","bs","bagItems","drawableNumbers","maxLog","MAX_VALUE","log2","calculateNumberSize","newIndex","newItem","newSize","preamble","findInvalid","setCurrent","lookingFor","changeBag","setWinnerBag","setCalculatedBag","setInvalid","encodingError","setupInvalidFinder","setupWeakness","sums","setWrongBag","updateBagSize","addBagItem","adapterArray","differences","factors","isOnStreak","fillFactory","mapState","getFlatData","occupied","findFirstSeat","realIterate","iterationCallback","seatingSystem","validDirections","isValidDirection","magnitude","waypointCoordinate","shipCoordinate","rainRisk","getBusIDs","parseEquations","shuttleSearch","ts","equations","mainMod","toSolve","equation","isMask","mask","match","emptyMemory","updateMemory","createAddress","remaining","updateMemory2","binaryAddress","addresses","dockingData","rambunctiousRecitation","startList","lastSpoken","newSpoken","lastAge","buildCommunicator","messageSender","buildMessage","kind","isTicketTranslationMessage","label","checkInvalidValues","ticketRules","foundValid","validity","myTicket","nearbyTickets","checkIfRuleCanBe","tickets","isTicketOK","buildIndex","validTickets","communicator","allRules","rulesToFind","takenIndexes","availableIndexes","possibleIndexes","foundLabel","ticketTranslation","ticketIndex","hasBuilt","interestingRules","isConwayCubesMessage","activeCubes","timedCubes","allCubes","cubes","cube","mainData","minDepth","maxHyper","minHyper","activeSurrounding","isActive","conwayCubes","affected","send3dData","send4dData","getNumber","getOperation","getExpressionParenth","getFlatExpression","currentToken","startEnd","expression","evaluateExpression","currentOperation","replaceAll","operationOrder","isMatchTerminal","isMatchList","clean","buildAll","toConcat","combine","elems","isBuiltFromStart","pool","isBuiltFromStartEnd","startPool","endPool","startCandidate","endCandidate","monsterMessages","built","lookup","as","col","colIndex","verticalMatch","horizontalMatch","easyMatch","inverted","makeMatch","rot","flipped","flippedB","flip","horizontalFlip","matches","isPlaced","adjust","fixed","movable","matcher","jurassicJigsaw","isMatching","matchesWith","operations","corners","tileIndex","topLeftCorner","currentLine","lastIndex","maxiTile","currentMaxiLine","tileSize","innerY","seaMonsterPattern","seaMonsterSize","clearSeaMonster","corner","nestedTileSize","seaMonsterMatch","countMonsters","seaMonsterCount","bestTile","currentFlipped","cups","getAllElements","currentCupLabel","pickedUp","destinationCup","toPut","startCup","createResult","cup","fillUp","upTo","crabCups","moves","clearIntersection","allergen","allergenCandidates","aIngredients","bIngredients","hasUpdated","allergens","updateAllergens","currentRecipeCandidates","checkCandidate","allergenIndex","allAllergens","allergenAssessment","allIngredients","safeIngredients","interesting","canonical","decks","winRecursiveRound","memo","playRecursiveRound","firstA","firstB","nestedState","playRound","deck","crabCombat","winnerDeck","modifier","lobbyLayout","reference","black","newBlack","blackNeighbours","isBlack","subjectNumber","hack","publicKey","loopSize","bigSubject","comboBreaker","card","doorLoopSize","encryptionKey","isEntryRouteBase","enrichList","date","2015","2016","2017","2018","2019","2020","Navbar","star","animationDuration","animationDelay","_m","yearIndex","yearsByRow","ordinalDate","visibility","isFull","ordinalOf","starObjects","CalendarEntry","disabled","readFile","directives","rawName","executing","domProps","quickRun","_i","$$a","$$el","$$c","checked","$$v","$$i","readFactory","_k","keyCode","sendInput","composing","inputLine","sendClose","entryKey","fileLoaded","_t","fullDate","link","noInput","marginBottom","forceEmbedded","readFileContent","useEmbedded","class","hidden","hideChoices","loadFile","clickSelectionAction","selectionLabel","ref","filesUpdated","isFileSelected","shownName","readFileFromInput","file","onSuccess","fileReader","FileReader","readAsText","chooseFile","fileName","getFileName","files","content","click","$refs","_q","show","disabledYear","embeddedLines","inputContent","contentToSplit","splitContent","required","EntryFileInput","EntryChoice","fileHandling","EntryTitle","EntryInput","canvasSize","hideOutput","text","shouldStopRenderer","pauseFor","manualRender","factory","startRender","renderIteration","newIds","changeColor","idOrIndex","val","oldVal","scrollTop","scrollHeight","canvas","getContext","render","clearRect","beginPath","point","lineTo","fillStyle","showInput","destroying","sendLine","stopper","clearScreen","reset","showAdditionalInput","createPause","lastPause","EntryTemplate","EntrySimpleOutput","messageHandler","shouldStop","that","currentTime","additionalReset","showTicket","ticketData","BaseMessageTemplate","modifiers","minTime","_n","$forceUpdate","getData","showGrid","get3dData","get4dData","innerHTML","draw","Hex","Grid","hexSymbol","symbol","polygon","stroke","hex","toPoint","use","translate","addTo","transparent","running","play","run","shouldRun","drawingPause","keyMap","tuples","map2020","LobbyLayout","routes","Home","config","productionTip","router","$mount"],"mappings":"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OACA,mCAED,+BAAgC,CAC/B,OACA,8BAED,gCAAiC,CAChC,OACA,+BAED,uCAAwC,CACvC,OACA,sCAED,oCAAqC,CACpC,OACA,mCAED,wCAAyC,CACxC,OACA,uCAED,yBAA0B,CACzB,OACA,wBAED,mCAAoC,CACnC,OACA,kCAED,8CAA+C,CAC9C,OACA,6CAED,iCAAkC,CACjC,OACA,gCAED,sCAAuC,CACtC,OACA,qCAED,0BAA2B,CAC1B,OACA,yBAED,+BAAgC,CAC/B,OACA,8BAED,0BAA2B,CAC1B,OACA,yBAED,6BAA8B,CAC7B,OACA,4BAED,sCAAuC,CACtC,OACA,qCAED,4BAA6B,CAC5B,OACA,2BAED,4BAA6B,CAC5B,OACA,2BAED,4CAA6C,CAC5C,OACA,2CAED,yCAA0C,CACzC,OACA,wCAED,gCAAiC,CAChC,OACA,+BAED,0BAA2B,CAC1B,OACA,yBAED,mCAAoC,CACnC,OACA,kCAED,0BAA2B,CAC1B,OACA,yBAED,oDAAqD,CACpD,OACA,mDAED,2BAA4B,CAC3B,OACA,0BAED,wCAAyC,CACxC,OACA,uCAED,wCAAyC,CACxC,OACA,uCAED,+BAAgC,CAC/B,OACA,8BAED,sCAAuC,CACtC,OACA,qCAED,kCAAmC,CAClC,OACA,iCAED,uCAAwC,CACvC,OACA,sCAED,+BAAgC,CAC/B,OACA,8BAED,oDAAqD,CACpD,OACA,mDAED,+BAAgC,CAC/B,OACA,8BAED,uCAAwC,CACvC,OACA,sCAED,iCAAkC,CACjC,OACA,gCAED,6BAA8B,CAC7B,OACA,4BAED,kCAAmC,CAClC,OACA,iCAED,gCAAiC,CAChC,OACA,+BAED,kBAAmB,CAClB,OACA,iBAED,kCAAmC,CAClC,OACA,iCAED,yBAA0B,CACzB,OACA,wBAED,sCAAuC,CACtC,OACA,qCAED,oBAAqB,CACpB,OACA,mBAED,sCAAuC,CACtC,OACA,qCAED,6BAA8B,CAC7B,OACA,4BAED,uBAAwB,CACvB,OACA,sBAED,iCAAkC,CACjC,OACA,gCAED,6BAA8B,CAC7B,OACA,4BAED,4BAA6B,CAC5B,OACA,2BAED,mCAAoC,CACnC,OACA,kCAED,8BAA+B,CAC9B,OACA,6BAED,sBAAuB,CACtB,OACA,qBAED,2BAA4B,CAC3B,OACA,0BAED,6BAA8B,CAC7B,OACA,4BAED,+BAAgC,CAC/B,OACA,8BAED,iCAAkC,CACjC,OACA,gCAED,iCAAkC,CACjC,OACA,gCAED,kCAAmC,CAClC,OACA,iCAED,wCAAyC,CACxC,OACA,uCAED,wCAAyC,CACxC,OACA,uCAED,6CAA8C,CAC7C,OACA,4CAED,sCAAuC,CACtC,OACA,qCAED,mCAAoC,CACnC,OACA,kCAED,2CAA4C,CAC3C,OACA,0CAED,8BAA+B,CAC9B,OACA,6BAED,iCAAkC,CACjC,OACA,gCAED,4BAA6B,CAC5B,OACA,2BAED,oCAAqC,CACpC,OACA,mCAED,gCAAiC,CAChC,OACA,+BAED,iCAAkC,CACjC,OACA,gCAED,mDAAoD,CACnD,OACA,kDAED,yCAA0C,CACzC,OACA,wCAED,sCAAuC,CACtC,OACA,qCAED,+CAAgD,CAC/C,OACA,8CAED,0CAA2C,CAC1C,OACA,yCAED,uBAAwB,CACvB,OACA,sBAED,0BAA2B,CAC1B,OACA,yBAED,6BAA8B,CAC7B,OACA,4BAED,4CAA6C,CAC5C,OACA,2CAED,qCAAsC,CACrC,OACA,oCAED,uBAAwB,CACvB,OACA,sBAED,wCAAyC,CACxC,OACA,uCAED,2BAA4B,CAC3B,OACA,0BAED,wCAAyC,CACxC,OACA,uCAED,mDAAoD,CACnD,OACA,kDAED,gDAAiD,CAChD,OACA,+CAED,8CAA+C,CAC9C,OACA,6CAED,+DAAgE,CAC/D,OACA,8DAED,uDAAwD,CACvD,OACA,sDAED,6BAA8B,CAC7B,OACA,4BAED,kCAAmC,CAClC,OACA,iCAED,wDAAyD,CACxD,OACA,uDAED,wDAAyD,CACxD,OACA,uDAED,yCAA0C,CACzC,OACA,wCAED,0BAA2B,CAC1B,OACA,yBAED,0BAA2B,CAC1B,OACA,yBAED,yCAA0C,CACzC,OACA,wCAED,mCAAoC,CACnC,OACA,kCAED,wBAAyB,CACxB,OACA,uBAED,wBAAyB,CACxB,OACA,uBAED,2CAA4C,CAC3C,OACA,0CAED,wCAAyC,CACxC,OACA,uCAED,4CAA6C,CAC5C,OACA,2CAED,0CAA2C,CAC1C,OACA,yCAED,0CAA2C,CAC1C,OACA,yCAED,sCAAuC,CACtC,OACA,qCAED,6CAA8C,CAC7C,OACA,4CAED,sCAAuC,CACtC,OACA,qCAED,sCAAuC,CACtC,OACA,qCAED,oDAAqD,CACpD,OACA,mDAED,2CAA4C,CAC3C,OACA,0CAED,2BAA4B,CAC3B,OACA,0BAED,+BAAgC,CAC/B,OACA,8BAED,qCAAsC,CACrC,OACA,oCAED,mCAAoC,CACnC,OACA,kCAED,iCAAkC,CACjC,OACA,gCAED,4BAA6B,CAC5B,OACA,2BAED,8BAA+B,CAC9B,OACA,6BAED,gCAAiC,CAChC,OACA,+BAED,uCAAwC,CACvC,OACA,sCAED,4BAA6B,CAC5B,OACA,2BAED,0BAA2B,CAC1B,OACA,yBAED,gCAAiC,CAChC,OACA,+BAED,0BAA2B,CAC1B,OACA,yBAED,2CAA4C,CAC3C,OACA,0CAED,uCAAwC,CACvC,OACA,sCAED,kCAAmC,CAClC,OACA,iCAED,qCAAsC,CACrC,OACA,oCAED,6CAA8C,CAC7C,OACA,4CAED,0BAA2B,CAC1B,OACA,yBAED,gDAAiD,CAChD,OACA,+CAED,qDAAsD,CACrD,OACA,oDAED,2BAA4B,CAC3B,OACA,0BAED,iCAAkC,CACjC,OACA,gCAED,6BAA8B,CAC7B,OACA,4BAED,2BAA4B,CAC3B,OACA,0BAED,0BAA2B,CAC1B,OACA,yBAED,yBAA0B,CACzB,OACA,wBAED,uBAAwB,CACvB,OACA,sBAED,4BAA6B,CAC5B,OACA,2BAED,0BAA2B,CAC1B,OACA,yBAED,4BAA6B,CAC5B,OACA,2BAED,8BAA+B,CAC9B,OACA,6BAED,8BAA+B,CAC9B,OACA,6BAED,6BAA8B,CAC7B,OACA,4BAED,0BAA2B,CAC1B,OACA,yBAED,8BAA+B,CAC9B,OACA,6BAED,6BAA8B,CAC7B,OACA,4BAED,iCAAkC,CACjC,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","file":"js/app.43aad57d.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"js/\" + ({\"2015-abacus-framework-txt\":\"2015-abacus-framework-txt\",\"2015-all-in-a-single-night-txt\":\"2015-all-in-a-single-night-txt\",\"2015-aunt-sue-txt\":\"2015-aunt-sue-txt\",\"2015-corporate-policy-txt\":\"2015-corporate-policy-txt\",\"2015-elves-look-elves-say-txt\":\"2015-elves-look-elves-say-txt\",\"2015-i-was-told-there-would-be-no-math-txt\":\"2015-i-was-told-there-would-be-no-math-txt\",\"2015-infinite-elves-and-infinite-houses-txt\":\"2015-infinite-elves-and-infinite-houses-txt\",\"2015-intern-elves-txt\":\"2015-intern-elves-txt\",\"2015-it-hangs-in-the-balance-txt\":\"2015-it-hangs-in-the-balance-txt\",\"2015-knights-of-the-dinner-table-txt\":\"2015-knights-of-the-dinner-table-txt\",\"2015-let-it-snow-txt\":\"2015-let-it-snow-txt\",\"2015-like-a-gif-for-your-yard-txt\":\"2015-like-a-gif-for-your-yard-txt\",\"2015-matchsticks-txt\":\"2015-matchsticks-txt\",\"2015-medicine-for-rudolph-txt\":\"2015-medicine-for-rudolph-txt\",\"2015-no-such-thing-as-too-much-txt\":\"2015-no-such-thing-as-too-much-txt\",\"2015-not-quite-lisp-txt\":\"2015-not-quite-lisp-txt\",\"2015-perfect-spherical-houses-in-a-vacuum-txt\":\"2015-perfect-spherical-houses-in-a-vacuum-txt\",\"2015-probably-a-fire-hazard-txt\":\"2015-probably-a-fire-hazard-txt\",\"2015-reindeer-olympics-txt\":\"2015-reindeer-olympics-txt\",\"2015-rpg-simulator-20xx-txt\":\"2015-rpg-simulator-20xx-txt\",\"2015-science-for-hungry-people-txt\":\"2015-science-for-hungry-people-txt\",\"2015-some-assembly-required-txt\":\"2015-some-assembly-required-txt\",\"2015-the-ideal-stocking-stuffer-txt\":\"2015-the-ideal-stocking-stuffer-txt\",\"2015-turing-lock-txt\":\"2015-turing-lock-txt\",\"2015-wizard-simulator-20xx-txt\":\"2015-wizard-simulator-20xx-txt\",\"2016-a-maze-of-twisty-little-cubicles-txt\":\"2016-a-maze-of-twisty-little-cubicles-txt\",\"2016-air-duct-spelunking-txt\":\"2016-air-duct-spelunking-txt\",\"2016-an-elephant-named-joseph-txt\":\"2016-an-elephant-named-joseph-txt\",\"2016-balance-bots-txt\":\"2016-balance-bots-txt\",\"2016-bathroom-security-txt\":\"2016-bathroom-security-txt\",\"2016-clock-signal-txt\":\"2016-clock-signal-txt\",\"2016-dragon-checksum-txt\":\"2016-dragon-checksum-txt\",\"2016-explosives-in-cyberspace-txt\":\"2016-explosives-in-cyberspace-txt\",\"2016-firewall-rules-txt\":\"2016-firewall-rules-txt\",\"2016-grid-computing-txt\":\"2016-grid-computing-txt\",\"2016-how-about-a-nice-game-of-chess-txt\":\"2016-how-about-a-nice-game-of-chess-txt\",\"2016-internet-protocol-version-7-txt\":\"2016-internet-protocol-version-7-txt\",\"2016-leonardos-monorail-txt\":\"2016-leonardos-monorail-txt\",\"2016-like-a-rogue-txt\":\"2016-like-a-rogue-txt\",\"2016-no-time-for-a-taxicab-txt\":\"2016-no-time-for-a-taxicab-txt\",\"2016-one-time-pad-txt\":\"2016-one-time-pad-txt\",\"2016-radioisotope-thermoelectric-generators-txt\":\"2016-radioisotope-thermoelectric-generators-txt\",\"2016-safe-cracking-txt\":\"2016-safe-cracking-txt\",\"2016-scrambled-letters-and-hash-txt\":\"2016-scrambled-letters-and-hash-txt\",\"2016-security-through-obscurity-txt\":\"2016-security-through-obscurity-txt\",\"2016-signals-and-noise-txt\":\"2016-signals-and-noise-txt\",\"2016-squares-with-three-sides-txt\":\"2016-squares-with-three-sides-txt\",\"2016-timing-is-everything-txt\":\"2016-timing-is-everything-txt\",\"2016-two-factor-authentication-txt\":\"2016-two-factor-authentication-txt\",\"2016-two-steps-forward-txt\":\"2016-two-steps-forward-txt\",\"2017-a-maze-of-twisty-trampolines-all-alike-txt\":\"2017-a-maze-of-twisty-trampolines-all-alike-txt\",\"2017-a-series-of-tubes-txt\":\"2017-a-series-of-tubes-txt\",\"2017-coprocessor-conflagration-txt\":\"2017-coprocessor-conflagration-txt\",\"2017-corruption-checksum-txt\":\"2017-corruption-checksum-txt\",\"2017-digital-plumber-txt\":\"2017-digital-plumber-txt\",\"2017-disk-defragmentation-txt\":\"2017-disk-defragmentation-txt\",\"2017-dueling-generators-txt\":\"2017-dueling-generators-txt\",\"2017-duet-txt\":\"2017-duet-txt\",\"2017-electromagnetic-moat-txt\":\"2017-electromagnetic-moat-txt\",\"2017-fractal-art-txt\":\"2017-fractal-art-txt\",\"2017-heard-you-like-registers-txt\":\"2017-heard-you-like-registers-txt\",\"2017-hex-ed-txt\":\"2017-hex-ed-txt\",\"2017-high-entropy-passphrases-txt\":\"2017-high-entropy-passphrases-txt\",\"2017-inverse-captcha-txt\":\"2017-inverse-captcha-txt\",\"2017-knot-hash-txt\":\"2017-knot-hash-txt\",\"2017-memory-reallocation-txt\":\"2017-memory-reallocation-txt\",\"2017-packet-scanners-txt\":\"2017-packet-scanners-txt\",\"2017-particle-swarm-txt\":\"2017-particle-swarm-txt\",\"2017-permutation-promenade-txt\":\"2017-permutation-promenade-txt\",\"2017-recursive-circus-txt\":\"2017-recursive-circus-txt\",\"2017-spinlock-txt\":\"2017-spinlock-txt\",\"2017-spiral-memory-txt\":\"2017-spiral-memory-txt\",\"2017-sporifica-virus-txt\":\"2017-sporifica-virus-txt\",\"2017-stream-processing-txt\":\"2017-stream-processing-txt\",\"2017-the-halting-problem-txt\":\"2017-the-halting-problem-txt\",\"2018-a-regular-map-input-txt\":\"2018-a-regular-map-input-txt\",\"2018-alchemical-reduction-txt\":\"2018-alchemical-reduction-txt\",\"2018-beverage-bandits-example-1-txt\":\"2018-beverage-bandits-example-1-txt\",\"2018-beverage-bandits-example-2-txt\":\"2018-beverage-bandits-example-2-txt\",\"2018-beverage-bandits-example-combat-txt\":\"2018-beverage-bandits-example-combat-txt\",\"2018-beverage-bandits-example-txt\":\"2018-beverage-bandits-example-txt\",\"2018-beverage-bandits-goal-txt\":\"2018-beverage-bandits-goal-txt\",\"2018-beverage-bandits-online-input-txt\":\"2018-beverage-bandits-online-input-txt\",\"2018-chocolate-charts-txt\":\"2018-chocolate-charts-txt\",\"2018-chronal-calibration-txt\":\"2018-chronal-calibration-txt\",\"2018-chronal-charge-txt\":\"2018-chronal-charge-txt\",\"2018-chronal-classification-txt\":\"2018-chronal-classification-txt\",\"2018-chronal-conversion-txt\":\"2018-chronal-conversion-txt\",\"2018-chronal-coordinates-txt\":\"2018-chronal-coordinates-txt\",\"2018-experimental-emergency-transportation-txt\":\"2018-experimental-emergency-transportation-txt\",\"2018-four-dimensional-adventures-txt\":\"2018-four-dimensional-adventures-txt\",\"2018-go-with-the-flow-example-txt\":\"2018-go-with-the-flow-example-txt\",\"2018-go-with-the-flow-go-with-the-flow-txt\":\"2018-go-with-the-flow-go-with-the-flow-txt\",\"2018-immune-system-simulator-20xx-txt\":\"2018-immune-system-simulator-20xx-txt\",\"2018-inventory-txt\":\"2018-inventory-txt\",\"2018-marble-mania-txt\":\"2018-marble-mania-txt\",\"2018-memory-maneuver-txt\":\"2018-memory-maneuver-txt\",\"2018-mine-cart-madness-base-example-txt\":\"2018-mine-cart-madness-base-example-txt\",\"2018-mine-cart-madness-input-txt\":\"2018-mine-cart-madness-input-txt\",\"2018-mode-maze-txt\":\"2018-mode-maze-txt\",\"2018-no-matter-how-you-slice-it-txt\":\"2018-no-matter-how-you-slice-it-txt\",\"2018-repose-record-txt\":\"2018-repose-record-txt\",\"2018-reservoir-research-example-txt\":\"2018-reservoir-research-example-txt\",\"2018-reservoir-research-reservoir-research-txt\":\"2018-reservoir-research-reservoir-research-txt\",\"2018-settlers-of-the-north-pole-example-txt\":\"2018-settlers-of-the-north-pole-example-txt\",\"2018-settlers-of-the-north-pole-input-txt\":\"2018-settlers-of-the-north-pole-input-txt\",\"2018-subterranean-substainability-subterranean-example-txt\":\"2018-subterranean-substainability-subterranean-example-txt\",\"2018-subterranean-substainability-subterranean-txt\":\"2018-subterranean-substainability-subterranean-txt\",\"2018-the-stars-align-txt\":\"2018-the-stars-align-txt\",\"2018-the-sum-of-its-parts-txt\":\"2018-the-sum-of-its-parts-txt\",\"2019-amplification-circuit-example-result-43210-txt\":\"2019-amplification-circuit-example-result-43210-txt\",\"2019-amplification-circuit-example-result-54321-txt\":\"2019-amplification-circuit-example-result-54321-txt\",\"2019-amplification-circuit-input-txt\":\"2019-amplification-circuit-input-txt\",\"2019-care-package-txt\":\"2019-care-package-txt\",\"2019-category-six-txt\":\"2019-category-six-txt\",\"2019-crossed-wires-crossed-wires-txt\":\"2019-crossed-wires-crossed-wires-txt\",\"2019-crossed-wires-example-txt\":\"2019-crossed-wires-example-txt\",\"2019-cryostasis-txt\":\"2019-cryostasis-txt\",\"2019-donut-maze-txt\":\"2019-donut-maze-txt\",\"2019-flawed-frequency-transmission-txt\":\"2019-flawed-frequency-transmission-txt\",\"2019-many-worlds-interpretation-txt\":\"2019-many-worlds-interpretation-txt\",\"2019-monitoring-station-big-example-txt\":\"2019-monitoring-station-big-example-txt\",\"2019-monitoring-station-example-1-txt\":\"2019-monitoring-station-example-1-txt\",\"2019-monitoring-station-example-2-txt\":\"2019-monitoring-station-example-2-txt\",\"2019-monitoring-station-input-txt\":\"2019-monitoring-station-input-txt\",\"2019-monitoring-station-kill-example-txt\":\"2019-monitoring-station-kill-example-txt\",\"2019-n-body-problem-example-1-txt\":\"2019-n-body-problem-example-1-txt\",\"2019-n-body-problem-example-3-txt\":\"2019-n-body-problem-example-3-txt\",\"2019-n-body-problem-long-repetition-example-txt\":\"2019-n-body-problem-long-repetition-example-txt\",\"2019-n-body-problem-n-body-problem-txt\":\"2019-n-body-problem-n-body-problem-txt\",\"2019-oxygen-system-txt\":\"2019-oxygen-system-txt\",\"2019-planet-of-discord-txt\":\"2019-planet-of-discord-txt\",\"2019-program-alarm-example-4-txt\":\"2019-program-alarm-example-4-txt\",\"2019-program-alarm-example-txt\":\"2019-program-alarm-example-txt\",\"2019-program-alarm-input-txt\":\"2019-program-alarm-input-txt\",\"2019-rocket-tyranny-txt\":\"2019-rocket-tyranny-txt\",\"2019-secure-container-txt\":\"2019-secure-container-txt\",\"2019-sensor-boost-quine-txt\":\"2019-sensor-boost-quine-txt\",\"2019-sensor-boost-sensor-boost-txt\":\"2019-sensor-boost-sensor-boost-txt\",\"2019-set-and-forget-txt\":\"2019-set-and-forget-txt\",\"2019-slam-shuffle-txt\":\"2019-slam-shuffle-txt\",\"2019-space-image-format-txt\":\"2019-space-image-format-txt\",\"2019-space-police-txt\":\"2019-space-police-txt\",\"2019-space-stoichiometry-example-1-txt\":\"2019-space-stoichiometry-example-1-txt\",\"2019-space-stoichiometry-input-txt\":\"2019-space-stoichiometry-input-txt\",\"2019-springroid-adventure-txt\":\"2019-springroid-adventure-txt\",\"2019-sunny-asteroids-example-txt\":\"2019-sunny-asteroids-example-txt\",\"2019-sunny-asteroids-sunny-asteroids-txt\":\"2019-sunny-asteroids-sunny-asteroids-txt\",\"2019-tractor-beam-txt\":\"2019-tractor-beam-txt\",\"2019-universal-orbit-map-example-second-txt\":\"2019-universal-orbit-map-example-second-txt\",\"2019-universal-orbit-map-universal-orbit-map-txt\":\"2019-universal-orbit-map-universal-orbit-map-txt\",\"2020-adapter-array-txt\":\"2020-adapter-array-txt\",\"2020-allergen-assessment-txt\":\"2020-allergen-assessment-txt\",\"2020-binary-boarding-txt\":\"2020-binary-boarding-txt\",\"2020-combo-breaker-txt\":\"2020-combo-breaker-txt\",\"2020-conway-cubes-txt\":\"2020-conway-cubes-txt\",\"2020-crab-combat-txt\":\"2020-crab-combat-txt\",\"2020-crab-cups-txt\":\"2020-crab-cups-txt\",\"2020-custom-customs-txt\":\"2020-custom-customs-txt\",\"2020-docking-data-txt\":\"2020-docking-data-txt\",\"2020-encoding-error-txt\":\"2020-encoding-error-txt\",\"2020-handheld-halting-txt\":\"2020-handheld-halting-txt\",\"2020-handy-haversacks-txt\":\"2020-handy-haversacks-txt\",\"2020-jurassic-jigsaw-txt\":\"2020-jurassic-jigsaw-txt\",\"2020-lobby-layout-txt\":\"2020-lobby-layout-txt\",\"2020-monster-messages-txt\":\"2020-monster-messages-txt\",\"2020-operation-order-txt\":\"2020-operation-order-txt\",\"2020-passport-processing-txt\":\"2020-passport-processing-txt\",\"2020-password-philosophy-txt\":\"2020-password-philosophy-txt\",\"2020-rain-risk-txt\":\"2020-rain-risk-txt\",\"2020-rambunctious-recitation-txt\":\"2020-rambunctious-recitation-txt\",\"2020-report-repair-txt\":\"2020-report-repair-txt\",\"2020-seating-system-txt\":\"2020-seating-system-txt\",\"2020-shuttle-search-txt\":\"2020-shuttle-search-txt\",\"2020-ticket-translation-txt\":\"2020-ticket-translation-txt\",\"2020-toboggan-trajectory-txt\":\"2020-toboggan-trajectory-txt\"}[chunkId]||chunkId) + \".\" + {\"2015-abacus-framework-txt\":\"4b435d7b\",\"2015-all-in-a-single-night-txt\":\"84247816\",\"2015-aunt-sue-txt\":\"b521a59a\",\"2015-corporate-policy-txt\":\"641af702\",\"2015-elves-look-elves-say-txt\":\"b4f7e522\",\"2015-i-was-told-there-would-be-no-math-txt\":\"1e1d1be6\",\"2015-infinite-elves-and-infinite-houses-txt\":\"051015ab\",\"2015-intern-elves-txt\":\"32f01fa0\",\"2015-it-hangs-in-the-balance-txt\":\"21b79030\",\"2015-knights-of-the-dinner-table-txt\":\"9dfc02ca\",\"2015-let-it-snow-txt\":\"b5035a7d\",\"2015-like-a-gif-for-your-yard-txt\":\"d4e21862\",\"2015-matchsticks-txt\":\"fe4d1483\",\"2015-medicine-for-rudolph-txt\":\"fc740c7d\",\"2015-no-such-thing-as-too-much-txt\":\"e53fa4ce\",\"2015-not-quite-lisp-txt\":\"5264c5cf\",\"2015-perfect-spherical-houses-in-a-vacuum-txt\":\"7eaccad0\",\"2015-probably-a-fire-hazard-txt\":\"15b1b40c\",\"2015-reindeer-olympics-txt\":\"1794c6dd\",\"2015-rpg-simulator-20xx-txt\":\"1f7e29d2\",\"2015-science-for-hungry-people-txt\":\"5460588e\",\"2015-some-assembly-required-txt\":\"7be2aa51\",\"2015-the-ideal-stocking-stuffer-txt\":\"04c6f4b6\",\"2015-turing-lock-txt\":\"f1a1955f\",\"2015-wizard-simulator-20xx-txt\":\"49a97b0c\",\"2016-a-maze-of-twisty-little-cubicles-txt\":\"e4f2518d\",\"2016-air-duct-spelunking-txt\":\"0270e79b\",\"2016-an-elephant-named-joseph-txt\":\"54cf12fd\",\"2016-balance-bots-txt\":\"66a71b02\",\"2016-bathroom-security-txt\":\"51ee8dd0\",\"2016-clock-signal-txt\":\"e18bf0e5\",\"2016-dragon-checksum-txt\":\"19b6e816\",\"2016-explosives-in-cyberspace-txt\":\"80aa2f4f\",\"2016-firewall-rules-txt\":\"2700f37f\",\"2016-grid-computing-txt\":\"b09728ea\",\"2016-how-about-a-nice-game-of-chess-txt\":\"8bdd2da1\",\"2016-internet-protocol-version-7-txt\":\"63a3e6b4\",\"2016-leonardos-monorail-txt\":\"c6347ffa\",\"2016-like-a-rogue-txt\":\"e35de3fa\",\"2016-no-time-for-a-taxicab-txt\":\"a55f6c7d\",\"2016-one-time-pad-txt\":\"2b5941bc\",\"2016-radioisotope-thermoelectric-generators-txt\":\"e602a6e3\",\"2016-safe-cracking-txt\":\"235ad9fa\",\"2016-scrambled-letters-and-hash-txt\":\"0ce1c67f\",\"2016-security-through-obscurity-txt\":\"90a33b11\",\"2016-signals-and-noise-txt\":\"9df425ec\",\"2016-squares-with-three-sides-txt\":\"f1ba2115\",\"2016-timing-is-everything-txt\":\"fb2ac36c\",\"2016-two-factor-authentication-txt\":\"a6949946\",\"2016-two-steps-forward-txt\":\"b6e9b02c\",\"2017-a-maze-of-twisty-trampolines-all-alike-txt\":\"5b2cca08\",\"2017-a-series-of-tubes-txt\":\"ebdf7f38\",\"2017-coprocessor-conflagration-txt\":\"981e67ab\",\"2017-corruption-checksum-txt\":\"b21eeaae\",\"2017-digital-plumber-txt\":\"5a663c4a\",\"2017-disk-defragmentation-txt\":\"6f7b49a9\",\"2017-dueling-generators-txt\":\"b39558da\",\"2017-duet-txt\":\"f9655771\",\"2017-electromagnetic-moat-txt\":\"cce2deaf\",\"2017-fractal-art-txt\":\"27a1e9c9\",\"2017-heard-you-like-registers-txt\":\"31b29cb8\",\"2017-hex-ed-txt\":\"c5a21754\",\"2017-high-entropy-passphrases-txt\":\"51f314fb\",\"2017-inverse-captcha-txt\":\"31855bad\",\"2017-knot-hash-txt\":\"b00906e0\",\"2017-memory-reallocation-txt\":\"58902957\",\"2017-packet-scanners-txt\":\"f4447d94\",\"2017-particle-swarm-txt\":\"cae45545\",\"2017-permutation-promenade-txt\":\"cc6a47f1\",\"2017-recursive-circus-txt\":\"1cb546b0\",\"2017-spinlock-txt\":\"e4492681\",\"2017-spiral-memory-txt\":\"bf1dc975\",\"2017-sporifica-virus-txt\":\"dfe5c048\",\"2017-stream-processing-txt\":\"b8003978\",\"2017-the-halting-problem-txt\":\"93253531\",\"2018-a-regular-map-input-txt\":\"00145bf4\",\"2018-alchemical-reduction-txt\":\"d163769a\",\"2018-beverage-bandits-example-1-txt\":\"d810ec9f\",\"2018-beverage-bandits-example-2-txt\":\"3f28a737\",\"2018-beverage-bandits-example-combat-txt\":\"6e361b96\",\"2018-beverage-bandits-example-txt\":\"79ec0714\",\"2018-beverage-bandits-goal-txt\":\"407a33a3\",\"2018-beverage-bandits-online-input-txt\":\"45e65e15\",\"2018-chocolate-charts-txt\":\"49491564\",\"2018-chronal-calibration-txt\":\"ca0002f8\",\"2018-chronal-charge-txt\":\"d34b9b5b\",\"2018-chronal-classification-txt\":\"5e41a9b4\",\"2018-chronal-conversion-txt\":\"3703f9cd\",\"2018-chronal-coordinates-txt\":\"4c132d05\",\"2018-experimental-emergency-transportation-txt\":\"767ad853\",\"2018-four-dimensional-adventures-txt\":\"d9ccea5e\",\"2018-go-with-the-flow-example-txt\":\"2c5a9c96\",\"2018-go-with-the-flow-go-with-the-flow-txt\":\"d1bbf598\",\"2018-immune-system-simulator-20xx-txt\":\"e52e845a\",\"2018-inventory-txt\":\"8dc0a89f\",\"2018-marble-mania-txt\":\"7bbd3966\",\"2018-memory-maneuver-txt\":\"bfe0202f\",\"2018-mine-cart-madness-base-example-txt\":\"be0ea31b\",\"2018-mine-cart-madness-input-txt\":\"0df7e569\",\"2018-mode-maze-txt\":\"f1bd447e\",\"2018-no-matter-how-you-slice-it-txt\":\"7652d163\",\"2018-repose-record-txt\":\"251c85da\",\"2018-reservoir-research-example-txt\":\"b6efafd3\",\"2018-reservoir-research-reservoir-research-txt\":\"61af5d78\",\"2018-settlers-of-the-north-pole-example-txt\":\"d30f1e48\",\"2018-settlers-of-the-north-pole-input-txt\":\"ec9d92ba\",\"2018-subterranean-substainability-subterranean-example-txt\":\"3fe3c8f8\",\"2018-subterranean-substainability-subterranean-txt\":\"8afc3e4d\",\"2018-the-stars-align-txt\":\"9a5ad8ab\",\"2018-the-sum-of-its-parts-txt\":\"2d80e1ba\",\"2019-amplification-circuit-example-result-43210-txt\":\"62ef8e72\",\"2019-amplification-circuit-example-result-54321-txt\":\"7581acca\",\"2019-amplification-circuit-input-txt\":\"dbc439a3\",\"2019-care-package-txt\":\"d0b13d3f\",\"2019-category-six-txt\":\"68d2e19b\",\"2019-crossed-wires-crossed-wires-txt\":\"b90db675\",\"2019-crossed-wires-example-txt\":\"bfed0b6f\",\"2019-cryostasis-txt\":\"f8a9abe1\",\"2019-donut-maze-txt\":\"afb95813\",\"2019-flawed-frequency-transmission-txt\":\"5cefa95d\",\"2019-many-worlds-interpretation-txt\":\"1b212d27\",\"2019-monitoring-station-big-example-txt\":\"7bca19d9\",\"2019-monitoring-station-example-1-txt\":\"3c80bcb6\",\"2019-monitoring-station-example-2-txt\":\"819a6680\",\"2019-monitoring-station-input-txt\":\"a81c44ff\",\"2019-monitoring-station-kill-example-txt\":\"9a882ad1\",\"2019-n-body-problem-example-1-txt\":\"0173174c\",\"2019-n-body-problem-example-3-txt\":\"6206e316\",\"2019-n-body-problem-long-repetition-example-txt\":\"88d00117\",\"2019-n-body-problem-n-body-problem-txt\":\"b19edcc8\",\"2019-oxygen-system-txt\":\"11c12495\",\"2019-planet-of-discord-txt\":\"d6547624\",\"2019-program-alarm-example-4-txt\":\"1997e8a4\",\"2019-program-alarm-example-txt\":\"41074cee\",\"2019-program-alarm-input-txt\":\"a3c85e75\",\"2019-rocket-tyranny-txt\":\"6ae54409\",\"2019-secure-container-txt\":\"9d25e76b\",\"2019-sensor-boost-quine-txt\":\"a40bb835\",\"2019-sensor-boost-sensor-boost-txt\":\"7f20c46e\",\"2019-set-and-forget-txt\":\"694bc92e\",\"2019-slam-shuffle-txt\":\"7ab17b97\",\"2019-space-image-format-txt\":\"92fdd443\",\"2019-space-police-txt\":\"48cd6008\",\"2019-space-stoichiometry-example-1-txt\":\"e9b2859f\",\"2019-space-stoichiometry-input-txt\":\"d56f1288\",\"2019-springroid-adventure-txt\":\"8c8dbcd8\",\"2019-sunny-asteroids-example-txt\":\"0fc6edbe\",\"2019-sunny-asteroids-sunny-asteroids-txt\":\"477c9373\",\"2019-tractor-beam-txt\":\"ec88feb5\",\"2019-universal-orbit-map-example-second-txt\":\"55af9edf\",\"2019-universal-orbit-map-universal-orbit-map-txt\":\"6bca7866\",\"2020-adapter-array-txt\":\"6973f977\",\"2020-allergen-assessment-txt\":\"21323831\",\"2020-binary-boarding-txt\":\"9ddd1e8e\",\"2020-combo-breaker-txt\":\"75cb4b27\",\"2020-conway-cubes-txt\":\"df419622\",\"2020-crab-combat-txt\":\"f784e3c2\",\"2020-crab-cups-txt\":\"575ca678\",\"2020-custom-customs-txt\":\"eec0233f\",\"2020-docking-data-txt\":\"02680c78\",\"2020-encoding-error-txt\":\"263b1a42\",\"2020-handheld-halting-txt\":\"9c708ccb\",\"2020-handy-haversacks-txt\":\"4b3e74c8\",\"2020-jurassic-jigsaw-txt\":\"3dc06d44\",\"2020-lobby-layout-txt\":\"ca783926\",\"2020-monster-messages-txt\":\"e5148990\",\"2020-operation-order-txt\":\"e46ab196\",\"2020-passport-processing-txt\":\"2ab4b49b\",\"2020-password-philosophy-txt\":\"bf9b8137\",\"2020-rain-risk-txt\":\"c79b1850\",\"2020-rambunctious-recitation-txt\":\"35db4f1d\",\"2020-report-repair-txt\":\"5f0f6be7\",\"2020-seating-system-txt\":\"7d57ca1f\",\"2020-shuttle-search-txt\":\"ac39df38\",\"2020-ticket-translation-txt\":\"19126123\",\"2020-toboggan-trajectory-txt\":\"a609166f\"}[chunkId] + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/aoc/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navbar.vue?vue&type=style&index=0&lang=scss&\"","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryWithPauseAndRun.vue?vue&type=style&index=0&lang=scss&\"","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SimpleEntryTemplate.vue?vue&type=style&index=0&id=1edd1b0a&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTitle.vue?vue&type=style&index=0&id=2d88f678&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntrySimpleOutput.vue?vue&type=style&index=0&id=94bbbadc&lang=scss&scoped=true&\"","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./LobbyLayout.vue?vue&type=style&index=0&id=d2e217b2&lang=scss&scoped=true&\"","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConwayCubesView.vue?vue&type=style&index=0&id=2d0c2e8a&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Hamburger.vue?vue&type=style&index=0&lang=scss&\"","var map = {\n\t\"./2015/abacus-framework.txt\": [\n\t\t\"0d3d\",\n\t\t\"2015-abacus-framework-txt\"\n\t],\n\t\"./2015/all-in-a-single-night.txt\": [\n\t\t\"7407\",\n\t\t\"2015-all-in-a-single-night-txt\"\n\t],\n\t\"./2015/aunt-sue.txt\": [\n\t\t\"b20c\",\n\t\t\"2015-aunt-sue-txt\"\n\t],\n\t\"./2015/corporate-policy.txt\": [\n\t\t\"d42e\",\n\t\t\"2015-corporate-policy-txt\"\n\t],\n\t\"./2015/elves-look-elves-say.txt\": [\n\t\t\"6431\",\n\t\t\"2015-elves-look-elves-say-txt\"\n\t],\n\t\"./2015/i-was-told-there-would-be-no-math.txt\": [\n\t\t\"e46b\",\n\t\t\"2015-i-was-told-there-would-be-no-math-txt\"\n\t],\n\t\"./2015/infinite-elves-and-infinite-houses.txt\": [\n\t\t\"0a13\",\n\t\t\"2015-infinite-elves-and-infinite-houses-txt\"\n\t],\n\t\"./2015/intern-elves.txt\": [\n\t\t\"9f37\",\n\t\t\"2015-intern-elves-txt\"\n\t],\n\t\"./2015/it-hangs-in-the-balance.txt\": [\n\t\t\"8e79\",\n\t\t\"2015-it-hangs-in-the-balance-txt\"\n\t],\n\t\"./2015/knights-of-the-dinner-table.txt\": [\n\t\t\"96e0\",\n\t\t\"2015-knights-of-the-dinner-table-txt\"\n\t],\n\t\"./2015/let-it-snow.txt\": [\n\t\t\"039c\",\n\t\t\"2015-let-it-snow-txt\"\n\t],\n\t\"./2015/like-a-gif-for-your-yard.txt\": [\n\t\t\"b8fd\",\n\t\t\"2015-like-a-gif-for-your-yard-txt\"\n\t],\n\t\"./2015/matchsticks.txt\": [\n\t\t\"1b0d\",\n\t\t\"2015-matchsticks-txt\"\n\t],\n\t\"./2015/medicine-for-rudolph.txt\": [\n\t\t\"a1ac\",\n\t\t\"2015-medicine-for-rudolph-txt\"\n\t],\n\t\"./2015/no-such-thing-as-too-much.txt\": [\n\t\t\"f542\",\n\t\t\"2015-no-such-thing-as-too-much-txt\"\n\t],\n\t\"./2015/not-quite-lisp.txt\": [\n\t\t\"d1fc\",\n\t\t\"2015-not-quite-lisp-txt\"\n\t],\n\t\"./2015/perfect-spherical-houses-in-a-vacuum.txt\": [\n\t\t\"a713\",\n\t\t\"2015-perfect-spherical-houses-in-a-vacuum-txt\"\n\t],\n\t\"./2015/probably-a-fire-hazard.txt\": [\n\t\t\"c3e0\",\n\t\t\"2015-probably-a-fire-hazard-txt\"\n\t],\n\t\"./2015/reindeer-olympics.txt\": [\n\t\t\"1c77\",\n\t\t\"2015-reindeer-olympics-txt\"\n\t],\n\t\"./2015/rpg-simulator-20xx.txt\": [\n\t\t\"8c86\",\n\t\t\"2015-rpg-simulator-20xx-txt\"\n\t],\n\t\"./2015/science-for-hungry-people.txt\": [\n\t\t\"3a8f\",\n\t\t\"2015-science-for-hungry-people-txt\"\n\t],\n\t\"./2015/some-assembly-required.txt\": [\n\t\t\"3d78\",\n\t\t\"2015-some-assembly-required-txt\"\n\t],\n\t\"./2015/the-ideal-stocking-stuffer.txt\": [\n\t\t\"5d3a\",\n\t\t\"2015-the-ideal-stocking-stuffer-txt\"\n\t],\n\t\"./2015/turing-lock.txt\": [\n\t\t\"46c6\",\n\t\t\"2015-turing-lock-txt\"\n\t],\n\t\"./2015/wizard-simulator-20xx.txt\": [\n\t\t\"6fe2\",\n\t\t\"2015-wizard-simulator-20xx-txt\"\n\t],\n\t\"./2016/a-maze-of-twisty-little-cubicles.txt\": [\n\t\t\"20db\",\n\t\t\"2016-a-maze-of-twisty-little-cubicles-txt\"\n\t],\n\t\"./2016/air-duct-spelunking.txt\": [\n\t\t\"b8a4\",\n\t\t\"2016-air-duct-spelunking-txt\"\n\t],\n\t\"./2016/an-elephant-named-joseph.txt\": [\n\t\t\"8b7f\",\n\t\t\"2016-an-elephant-named-joseph-txt\"\n\t],\n\t\"./2016/balance-bots.txt\": [\n\t\t\"ee1b\",\n\t\t\"2016-balance-bots-txt\"\n\t],\n\t\"./2016/bathroom-security.txt\": [\n\t\t\"234b\",\n\t\t\"2016-bathroom-security-txt\"\n\t],\n\t\"./2016/clock-signal.txt\": [\n\t\t\"f4af\",\n\t\t\"2016-clock-signal-txt\"\n\t],\n\t\"./2016/dragon-checksum.txt\": [\n\t\t\"9d55\",\n\t\t\"2016-dragon-checksum-txt\"\n\t],\n\t\"./2016/explosives-in-cyberspace.txt\": [\n\t\t\"deab\",\n\t\t\"2016-explosives-in-cyberspace-txt\"\n\t],\n\t\"./2016/firewall-rules.txt\": [\n\t\t\"4c4e\",\n\t\t\"2016-firewall-rules-txt\"\n\t],\n\t\"./2016/grid-computing.txt\": [\n\t\t\"cabf\",\n\t\t\"2016-grid-computing-txt\"\n\t],\n\t\"./2016/how-about-a-nice-game-of-chess.txt\": [\n\t\t\"d1d7\",\n\t\t\"2016-how-about-a-nice-game-of-chess-txt\"\n\t],\n\t\"./2016/internet-protocol-version-7.txt\": [\n\t\t\"b0f4\",\n\t\t\"2016-internet-protocol-version-7-txt\"\n\t],\n\t\"./2016/leonardos-monorail.txt\": [\n\t\t\"61ff\",\n\t\t\"2016-leonardos-monorail-txt\"\n\t],\n\t\"./2016/like-a-rogue.txt\": [\n\t\t\"36ee\",\n\t\t\"2016-like-a-rogue-txt\"\n\t],\n\t\"./2016/no-time-for-a-taxicab.txt\": [\n\t\t\"3c3a\",\n\t\t\"2016-no-time-for-a-taxicab-txt\"\n\t],\n\t\"./2016/one-time-pad.txt\": [\n\t\t\"5a2b\",\n\t\t\"2016-one-time-pad-txt\"\n\t],\n\t\"./2016/radioisotope-thermoelectric-generators.txt\": [\n\t\t\"9ea3\",\n\t\t\"2016-radioisotope-thermoelectric-generators-txt\"\n\t],\n\t\"./2016/safe-cracking.txt\": [\n\t\t\"1206\",\n\t\t\"2016-safe-cracking-txt\"\n\t],\n\t\"./2016/scrambled-letters-and-hash.txt\": [\n\t\t\"22f5\",\n\t\t\"2016-scrambled-letters-and-hash-txt\"\n\t],\n\t\"./2016/security-through-obscurity.txt\": [\n\t\t\"49f6\",\n\t\t\"2016-security-through-obscurity-txt\"\n\t],\n\t\"./2016/signals-and-noise.txt\": [\n\t\t\"3c70\",\n\t\t\"2016-signals-and-noise-txt\"\n\t],\n\t\"./2016/squares-with-three-sides.txt\": [\n\t\t\"5508\",\n\t\t\"2016-squares-with-three-sides-txt\"\n\t],\n\t\"./2016/timing-is-everything.txt\": [\n\t\t\"fcc4\",\n\t\t\"2016-timing-is-everything-txt\"\n\t],\n\t\"./2016/two-factor-authentication.txt\": [\n\t\t\"b17e\",\n\t\t\"2016-two-factor-authentication-txt\"\n\t],\n\t\"./2016/two-steps-forward.txt\": [\n\t\t\"db37\",\n\t\t\"2016-two-steps-forward-txt\"\n\t],\n\t\"./2017/a-maze-of-twisty-trampolines-all-alike.txt\": [\n\t\t\"4132\",\n\t\t\"2017-a-maze-of-twisty-trampolines-all-alike-txt\"\n\t],\n\t\"./2017/a-series-of-tubes.txt\": [\n\t\t\"a7fe\",\n\t\t\"2017-a-series-of-tubes-txt\"\n\t],\n\t\"./2017/coprocessor-conflagration.txt\": [\n\t\t\"9678\",\n\t\t\"2017-coprocessor-conflagration-txt\"\n\t],\n\t\"./2017/corruption-checksum.txt\": [\n\t\t\"56b8\",\n\t\t\"2017-corruption-checksum-txt\"\n\t],\n\t\"./2017/digital-plumber.txt\": [\n\t\t\"03d0\",\n\t\t\"2017-digital-plumber-txt\"\n\t],\n\t\"./2017/disk-defragmentation.txt\": [\n\t\t\"7c87\",\n\t\t\"2017-disk-defragmentation-txt\"\n\t],\n\t\"./2017/dueling-generators.txt\": [\n\t\t\"1a62\",\n\t\t\"2017-dueling-generators-txt\"\n\t],\n\t\"./2017/duet.txt\": [\n\t\t\"40d9\",\n\t\t\"2017-duet-txt\"\n\t],\n\t\"./2017/electromagnetic-moat.txt\": [\n\t\t\"89a3\",\n\t\t\"2017-electromagnetic-moat-txt\"\n\t],\n\t\"./2017/fractal-art.txt\": [\n\t\t\"2917\",\n\t\t\"2017-fractal-art-txt\"\n\t],\n\t\"./2017/heard-you-like-registers.txt\": [\n\t\t\"bfb4\",\n\t\t\"2017-heard-you-like-registers-txt\"\n\t],\n\t\"./2017/hex-ed.txt\": [\n\t\t\"9124\",\n\t\t\"2017-hex-ed-txt\"\n\t],\n\t\"./2017/high-entropy-passphrases.txt\": [\n\t\t\"5ba1\",\n\t\t\"2017-high-entropy-passphrases-txt\"\n\t],\n\t\"./2017/inverse-captcha.txt\": [\n\t\t\"bc57\",\n\t\t\"2017-inverse-captcha-txt\"\n\t],\n\t\"./2017/knot-hash.txt\": [\n\t\t\"e98b\",\n\t\t\"2017-knot-hash-txt\"\n\t],\n\t\"./2017/memory-reallocation.txt\": [\n\t\t\"f108\",\n\t\t\"2017-memory-reallocation-txt\"\n\t],\n\t\"./2017/packet-scanners.txt\": [\n\t\t\"bc2c\",\n\t\t\"2017-packet-scanners-txt\"\n\t],\n\t\"./2017/particle-swarm.txt\": [\n\t\t\"0579\",\n\t\t\"2017-particle-swarm-txt\"\n\t],\n\t\"./2017/permutation-promenade.txt\": [\n\t\t\"ffb1\",\n\t\t\"2017-permutation-promenade-txt\"\n\t],\n\t\"./2017/recursive-circus.txt\": [\n\t\t\"fac4\",\n\t\t\"2017-recursive-circus-txt\"\n\t],\n\t\"./2017/spinlock.txt\": [\n\t\t\"dcf5\",\n\t\t\"2017-spinlock-txt\"\n\t],\n\t\"./2017/spiral-memory.txt\": [\n\t\t\"c6e7\",\n\t\t\"2017-spiral-memory-txt\"\n\t],\n\t\"./2017/sporifica-virus.txt\": [\n\t\t\"7fa0\",\n\t\t\"2017-sporifica-virus-txt\"\n\t],\n\t\"./2017/stream-processing.txt\": [\n\t\t\"b854\",\n\t\t\"2017-stream-processing-txt\"\n\t],\n\t\"./2017/the-halting-problem.txt\": [\n\t\t\"1f94\",\n\t\t\"2017-the-halting-problem-txt\"\n\t],\n\t\"./2018/a-regular-map/input.txt\": [\n\t\t\"10dd\",\n\t\t\"2018-a-regular-map-input-txt\"\n\t],\n\t\"./2018/alchemical-reduction.txt\": [\n\t\t\"11ba\",\n\t\t\"2018-alchemical-reduction-txt\"\n\t],\n\t\"./2018/beverage-bandits/example-1.txt\": [\n\t\t\"639a\",\n\t\t\"2018-beverage-bandits-example-1-txt\"\n\t],\n\t\"./2018/beverage-bandits/example-2.txt\": [\n\t\t\"2a61\",\n\t\t\"2018-beverage-bandits-example-2-txt\"\n\t],\n\t\"./2018/beverage-bandits/example-combat.txt\": [\n\t\t\"2bb4\",\n\t\t\"2018-beverage-bandits-example-combat-txt\"\n\t],\n\t\"./2018/beverage-bandits/example.txt\": [\n\t\t\"fe0f\",\n\t\t\"2018-beverage-bandits-example-txt\"\n\t],\n\t\"./2018/beverage-bandits/goal.txt\": [\n\t\t\"80f6\",\n\t\t\"2018-beverage-bandits-goal-txt\"\n\t],\n\t\"./2018/beverage-bandits/online-input.txt\": [\n\t\t\"4238\",\n\t\t\"2018-beverage-bandits-online-input-txt\"\n\t],\n\t\"./2018/chocolate-charts.txt\": [\n\t\t\"f156\",\n\t\t\"2018-chocolate-charts-txt\"\n\t],\n\t\"./2018/chronal-calibration.txt\": [\n\t\t\"b640\",\n\t\t\"2018-chronal-calibration-txt\"\n\t],\n\t\"./2018/chronal-charge.txt\": [\n\t\t\"9fe3\",\n\t\t\"2018-chronal-charge-txt\"\n\t],\n\t\"./2018/chronal-classification.txt\": [\n\t\t\"a86f\",\n\t\t\"2018-chronal-classification-txt\"\n\t],\n\t\"./2018/chronal-conversion.txt\": [\n\t\t\"5517\",\n\t\t\"2018-chronal-conversion-txt\"\n\t],\n\t\"./2018/chronal-coordinates.txt\": [\n\t\t\"ea1c\",\n\t\t\"2018-chronal-coordinates-txt\"\n\t],\n\t\"./2018/experimental-emergency-transportation.txt\": [\n\t\t\"e3e2\",\n\t\t\"2018-experimental-emergency-transportation-txt\"\n\t],\n\t\"./2018/four-dimensional-adventures.txt\": [\n\t\t\"0747\",\n\t\t\"2018-four-dimensional-adventures-txt\"\n\t],\n\t\"./2018/go-with-the-flow/example.txt\": [\n\t\t\"87b7\",\n\t\t\"2018-go-with-the-flow-example-txt\"\n\t],\n\t\"./2018/go-with-the-flow/go-with-the-flow.txt\": [\n\t\t\"7356\",\n\t\t\"2018-go-with-the-flow-go-with-the-flow-txt\"\n\t],\n\t\"./2018/immune-system-simulator-20xx.txt\": [\n\t\t\"bd65\",\n\t\t\"2018-immune-system-simulator-20xx-txt\"\n\t],\n\t\"./2018/inventory.txt\": [\n\t\t\"eba9\",\n\t\t\"2018-inventory-txt\"\n\t],\n\t\"./2018/marble-mania.txt\": [\n\t\t\"dac5\",\n\t\t\"2018-marble-mania-txt\"\n\t],\n\t\"./2018/memory-maneuver.txt\": [\n\t\t\"403f\",\n\t\t\"2018-memory-maneuver-txt\"\n\t],\n\t\"./2018/mine-cart-madness/base-example.txt\": [\n\t\t\"1ddb\",\n\t\t\"2018-mine-cart-madness-base-example-txt\"\n\t],\n\t\"./2018/mine-cart-madness/input.txt\": [\n\t\t\"294f\",\n\t\t\"2018-mine-cart-madness-input-txt\"\n\t],\n\t\"./2018/mode-maze.txt\": [\n\t\t\"d7cb\",\n\t\t\"2018-mode-maze-txt\"\n\t],\n\t\"./2018/no-matter-how-you-slice-it.txt\": [\n\t\t\"a780\",\n\t\t\"2018-no-matter-how-you-slice-it-txt\"\n\t],\n\t\"./2018/repose-record.txt\": [\n\t\t\"51e5\",\n\t\t\"2018-repose-record-txt\"\n\t],\n\t\"./2018/reservoir-research/example.txt\": [\n\t\t\"4340\",\n\t\t\"2018-reservoir-research-example-txt\"\n\t],\n\t\"./2018/reservoir-research/reservoir-research.txt\": [\n\t\t\"4aa9\",\n\t\t\"2018-reservoir-research-reservoir-research-txt\"\n\t],\n\t\"./2018/settlers-of-the-north-pole/example.txt\": [\n\t\t\"2e56\",\n\t\t\"2018-settlers-of-the-north-pole-example-txt\"\n\t],\n\t\"./2018/settlers-of-the-north-pole/input.txt\": [\n\t\t\"dff7\",\n\t\t\"2018-settlers-of-the-north-pole-input-txt\"\n\t],\n\t\"./2018/subterranean-substainability/subterranean-example.txt\": [\n\t\t\"f77c\",\n\t\t\"2018-subterranean-substainability-subterranean-example-txt\"\n\t],\n\t\"./2018/subterranean-substainability/subterranean.txt\": [\n\t\t\"b72f\",\n\t\t\"2018-subterranean-substainability-subterranean-txt\"\n\t],\n\t\"./2018/the-stars-align.txt\": [\n\t\t\"83d7\",\n\t\t\"2018-the-stars-align-txt\"\n\t],\n\t\"./2018/the-sum-of-its-parts.txt\": [\n\t\t\"9a0d\",\n\t\t\"2018-the-sum-of-its-parts-txt\"\n\t],\n\t\"./2019/amplification-circuit/example-result-43210.txt\": [\n\t\t\"a9d2\",\n\t\t\"2019-amplification-circuit-example-result-43210-txt\"\n\t],\n\t\"./2019/amplification-circuit/example-result-54321.txt\": [\n\t\t\"b3f8\",\n\t\t\"2019-amplification-circuit-example-result-54321-txt\"\n\t],\n\t\"./2019/amplification-circuit/input.txt\": [\n\t\t\"312f\",\n\t\t\"2019-amplification-circuit-input-txt\"\n\t],\n\t\"./2019/care-package.txt\": [\n\t\t\"7a7a\",\n\t\t\"2019-care-package-txt\"\n\t],\n\t\"./2019/category-six.txt\": [\n\t\t\"047c\",\n\t\t\"2019-category-six-txt\"\n\t],\n\t\"./2019/crossed-wires/crossed-wires.txt\": [\n\t\t\"796c\",\n\t\t\"2019-crossed-wires-crossed-wires-txt\"\n\t],\n\t\"./2019/crossed-wires/example.txt\": [\n\t\t\"1f03\",\n\t\t\"2019-crossed-wires-example-txt\"\n\t],\n\t\"./2019/cryostasis.txt\": [\n\t\t\"07fe\",\n\t\t\"2019-cryostasis-txt\"\n\t],\n\t\"./2019/donut-maze.txt\": [\n\t\t\"c494\",\n\t\t\"2019-donut-maze-txt\"\n\t],\n\t\"./2019/flawed-frequency-transmission.txt\": [\n\t\t\"f0a3\",\n\t\t\"2019-flawed-frequency-transmission-txt\"\n\t],\n\t\"./2019/many-worlds-interpretation.txt\": [\n\t\t\"0eb5\",\n\t\t\"2019-many-worlds-interpretation-txt\"\n\t],\n\t\"./2019/monitoring-station/big-example.txt\": [\n\t\t\"1010\",\n\t\t\"2019-monitoring-station-big-example-txt\"\n\t],\n\t\"./2019/monitoring-station/example-1.txt\": [\n\t\t\"4763\",\n\t\t\"2019-monitoring-station-example-1-txt\"\n\t],\n\t\"./2019/monitoring-station/example-2.txt\": [\n\t\t\"b571\",\n\t\t\"2019-monitoring-station-example-2-txt\"\n\t],\n\t\"./2019/monitoring-station/input.txt\": [\n\t\t\"3383\",\n\t\t\"2019-monitoring-station-input-txt\"\n\t],\n\t\"./2019/monitoring-station/kill-example.txt\": [\n\t\t\"020b\",\n\t\t\"2019-monitoring-station-kill-example-txt\"\n\t],\n\t\"./2019/n-body-problem/example-1.txt\": [\n\t\t\"9172\",\n\t\t\"2019-n-body-problem-example-1-txt\"\n\t],\n\t\"./2019/n-body-problem/example-3.txt\": [\n\t\t\"881a\",\n\t\t\"2019-n-body-problem-example-3-txt\"\n\t],\n\t\"./2019/n-body-problem/long-repetition-example.txt\": [\n\t\t\"8860\",\n\t\t\"2019-n-body-problem-long-repetition-example-txt\"\n\t],\n\t\"./2019/n-body-problem/n-body-problem.txt\": [\n\t\t\"5a33\",\n\t\t\"2019-n-body-problem-n-body-problem-txt\"\n\t],\n\t\"./2019/oxygen-system.txt\": [\n\t\t\"39cb\",\n\t\t\"2019-oxygen-system-txt\"\n\t],\n\t\"./2019/planet-of-discord.txt\": [\n\t\t\"ae66\",\n\t\t\"2019-planet-of-discord-txt\"\n\t],\n\t\"./2019/program-alarm/example-4.txt\": [\n\t\t\"e2b8\",\n\t\t\"2019-program-alarm-example-4-txt\"\n\t],\n\t\"./2019/program-alarm/example.txt\": [\n\t\t\"d219\",\n\t\t\"2019-program-alarm-example-txt\"\n\t],\n\t\"./2019/program-alarm/input.txt\": [\n\t\t\"2823\",\n\t\t\"2019-program-alarm-input-txt\"\n\t],\n\t\"./2019/rocket-tyranny.txt\": [\n\t\t\"3324\",\n\t\t\"2019-rocket-tyranny-txt\"\n\t],\n\t\"./2019/secure-container.txt\": [\n\t\t\"35a6\",\n\t\t\"2019-secure-container-txt\"\n\t],\n\t\"./2019/sensor-boost/quine.txt\": [\n\t\t\"2059\",\n\t\t\"2019-sensor-boost-quine-txt\"\n\t],\n\t\"./2019/sensor-boost/sensor-boost.txt\": [\n\t\t\"f178\",\n\t\t\"2019-sensor-boost-sensor-boost-txt\"\n\t],\n\t\"./2019/set-and-forget.txt\": [\n\t\t\"bd57\",\n\t\t\"2019-set-and-forget-txt\"\n\t],\n\t\"./2019/slam-shuffle.txt\": [\n\t\t\"fca4\",\n\t\t\"2019-slam-shuffle-txt\"\n\t],\n\t\"./2019/space-image-format.txt\": [\n\t\t\"c6d2\",\n\t\t\"2019-space-image-format-txt\"\n\t],\n\t\"./2019/space-police.txt\": [\n\t\t\"4d72\",\n\t\t\"2019-space-police-txt\"\n\t],\n\t\"./2019/space-stoichiometry/example-1.txt\": [\n\t\t\"f43c\",\n\t\t\"2019-space-stoichiometry-example-1-txt\"\n\t],\n\t\"./2019/space-stoichiometry/input.txt\": [\n\t\t\"7e8d\",\n\t\t\"2019-space-stoichiometry-input-txt\"\n\t],\n\t\"./2019/springroid-adventure.txt\": [\n\t\t\"5b58\",\n\t\t\"2019-springroid-adventure-txt\"\n\t],\n\t\"./2019/sunny-asteroids/example.txt\": [\n\t\t\"d4a0\",\n\t\t\"2019-sunny-asteroids-example-txt\"\n\t],\n\t\"./2019/sunny-asteroids/sunny-asteroids.txt\": [\n\t\t\"cc81\",\n\t\t\"2019-sunny-asteroids-sunny-asteroids-txt\"\n\t],\n\t\"./2019/tractor-beam.txt\": [\n\t\t\"01e8\",\n\t\t\"2019-tractor-beam-txt\"\n\t],\n\t\"./2019/universal-orbit-map/example-second.txt\": [\n\t\t\"3d53\",\n\t\t\"2019-universal-orbit-map-example-second-txt\"\n\t],\n\t\"./2019/universal-orbit-map/universal-orbit-map.txt\": [\n\t\t\"79bc\",\n\t\t\"2019-universal-orbit-map-universal-orbit-map-txt\"\n\t],\n\t\"./2020/adapter-array.txt\": [\n\t\t\"5705\",\n\t\t\"2020-adapter-array-txt\"\n\t],\n\t\"./2020/allergen-assessment.txt\": [\n\t\t\"ed1a\",\n\t\t\"2020-allergen-assessment-txt\"\n\t],\n\t\"./2020/binary-boarding.txt\": [\n\t\t\"1a9d\",\n\t\t\"2020-binary-boarding-txt\"\n\t],\n\t\"./2020/combo-breaker.txt\": [\n\t\t\"a129\",\n\t\t\"2020-combo-breaker-txt\"\n\t],\n\t\"./2020/conway-cubes.txt\": [\n\t\t\"43db\",\n\t\t\"2020-conway-cubes-txt\"\n\t],\n\t\"./2020/crab-combat.txt\": [\n\t\t\"54aa\",\n\t\t\"2020-crab-combat-txt\"\n\t],\n\t\"./2020/crab-cups.txt\": [\n\t\t\"2b45\",\n\t\t\"2020-crab-cups-txt\"\n\t],\n\t\"./2020/custom-customs.txt\": [\n\t\t\"5b0c\",\n\t\t\"2020-custom-customs-txt\"\n\t],\n\t\"./2020/docking-data.txt\": [\n\t\t\"e0a4\",\n\t\t\"2020-docking-data-txt\"\n\t],\n\t\"./2020/encoding-error.txt\": [\n\t\t\"bb47\",\n\t\t\"2020-encoding-error-txt\"\n\t],\n\t\"./2020/handheld-halting.txt\": [\n\t\t\"d5d4\",\n\t\t\"2020-handheld-halting-txt\"\n\t],\n\t\"./2020/handy-haversacks.txt\": [\n\t\t\"e078\",\n\t\t\"2020-handy-haversacks-txt\"\n\t],\n\t\"./2020/jurassic-jigsaw.txt\": [\n\t\t\"ad2e\",\n\t\t\"2020-jurassic-jigsaw-txt\"\n\t],\n\t\"./2020/lobby-layout.txt\": [\n\t\t\"727a\",\n\t\t\"2020-lobby-layout-txt\"\n\t],\n\t\"./2020/monster-messages.txt\": [\n\t\t\"1e76\",\n\t\t\"2020-monster-messages-txt\"\n\t],\n\t\"./2020/operation-order.txt\": [\n\t\t\"bed8\",\n\t\t\"2020-operation-order-txt\"\n\t],\n\t\"./2020/passport-processing.txt\": [\n\t\t\"f75f\",\n\t\t\"2020-passport-processing-txt\"\n\t],\n\t\"./2020/password-philosophy.txt\": [\n\t\t\"3ffc\",\n\t\t\"2020-password-philosophy-txt\"\n\t],\n\t\"./2020/rain-risk.txt\": [\n\t\t\"570f\",\n\t\t\"2020-rain-risk-txt\"\n\t],\n\t\"./2020/rambunctious-recitation.txt\": [\n\t\t\"b274\",\n\t\t\"2020-rambunctious-recitation-txt\"\n\t],\n\t\"./2020/report-repair.txt\": [\n\t\t\"1f77\",\n\t\t\"2020-report-repair-txt\"\n\t],\n\t\"./2020/seating-system.txt\": [\n\t\t\"3af5\",\n\t\t\"2020-seating-system-txt\"\n\t],\n\t\"./2020/shuttle-search.txt\": [\n\t\t\"0d13\",\n\t\t\"2020-shuttle-search-txt\"\n\t],\n\t\"./2020/ticket-translation.txt\": [\n\t\t\"328f\",\n\t\t\"2020-ticket-translation-txt\"\n\t],\n\t\"./2020/toboggan-trajectory.txt\": [\n\t\t\"d7ea\",\n\t\t\"2020-toboggan-trajectory-txt\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = \"70f5\";\nmodule.exports = webpackAsyncContext;","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryInput.vue?vue&type=style&index=0&id=269a8728&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryFileInput.vue?vue&type=style&index=0&id=27b03c87&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=style&index=0&id=001738db&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTemplate.vue?vue&type=style&index=0&id=088c78a5&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryChoice.vue?vue&type=style&index=0&id=a70d5e66&lang=scss&scoped=true&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CalendarEntry.vue?vue&type=style&index=0&id=1bd1c98b&scoped=true&lang=css&\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Entries.vue?vue&type=style&index=0&lang=scss&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('Navbar',{attrs:{\"entryByYears\":_vm.entryByYears}}),_c('div',{attrs:{\"id\":\"content\"}},[_c('router-view')],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"nav\"}},[_c('div',{staticClass:\"header\"},[_c('Hamburger',{staticClass:\"hamburger\",attrs:{\"size\":25},on:{\"click\":_vm.toggleNavbar}}),_c('div',{staticClass:\"title\"},[_vm._v(\"Advent of Code\")]),_c('div',{staticClass:\"author\"},[_vm._v(\"gicali\")])],1),_c('hr'),_c('div',{staticClass:\"links\",style:(_vm.navbarStyle)},[_c('div',{staticClass:\"years\"},_vm._l((_vm.years),function(year){return _c('Year',{key:year,attrs:{\"year\":year,\"selected\":year === _vm.selectedYear},on:{\"click\":function($event){return _vm.selectYear(year)}}})}),1),_c('router-link',{attrs:{\"to\":\"/\"}},[_vm._v(\"Home\")]),_c('router-link',{attrs:{\"to\":{name: 'entries'}}},[_vm._v(\"Entries\")]),_c('div',{staticClass:\"nav-entry\"},[(_vm.shouldTruncateList)?_c('router-link',{staticClass:\"shortened\",attrs:{\"to\":{name: 'entries' }}},[_vm._v(\"(...)\")]):_vm._e(),_vm._l((_vm.entryList),function(entry){return _c('router-link',{key:entry.name,attrs:{\"to\":{name: entry.name}}},[_vm._v(_vm._s(entry.title))])})],2),_c('router-link',{staticClass:\"last-entry\",attrs:{\"to\":{name: _vm.lastEntryName}}},[_vm._v(\"Last Entry\")])],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"hamburger\",on:{\"click\":function($event){return _vm.$emit('click')}}},[_c('div',{staticClass:\"hamburger-line\",style:(_vm.lineStyle)}),_c('div',{staticClass:\"hamburger-line\",style:(_vm.lineStyle)}),_c('div',{staticClass:\"hamburger-line\",style:(_vm.lineStyle)})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\nimport Vue from \"vue\";\nexport default Vue.extend({\n\n    props: {\n        size: Number\n    },\n    computed: {\n        lineStyle() {\n            return {\n                width: `${this.size}px`,\n                height: `${this.size as number / 6}px`,\n                margin: `${this.size as number / 6}px 0`\n            };\n        }\n    }\n\n});\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Hamburger.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Hamburger.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Hamburger.vue?vue&type=template&id=54573fe0&lang=pug&\"\nimport script from \"./Hamburger.vue?vue&type=script&lang=ts&\"\nexport * from \"./Hamburger.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Hamburger.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{staticClass:\"year-wrapper\",on:{\"click\":function($event){return _vm.$emit('click')}}},[(_vm.selected)?_c('span',[_vm._v(\">\")]):_vm._e(),_c('span',[_vm._v(_vm._s(_vm.year))]),(_vm.selected)?_c('span',[_vm._v(\"<\")]):_vm._e()])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\nimport Vue from \"vue\";\nexport default Vue.extend({\n    props: {\n        year: Number,\n        selected: Boolean\n    }\n});\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Year.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Year.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Year.vue?vue&type=template&id=1e2a6608&lang=pug&\"\nimport script from \"./Year.vue?vue&type=script&lang=ts&\"\nexport * from \"./Year.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","export const baseState = {\n    dates: {\n        year: 2020\n    }\n};\n\nexport function updateYear(year: number | string) {\n    if (typeof (year) === \"string\") {\n        year = parseInt(year, 10);\n    }\n    baseState.dates.year = year;\n}\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from \"vue\";\n\nimport Hamburger from \"./Hamburger.vue\";\nimport Year from \"./Year.vue\";\nimport { EntryRoute } from \"../entries/entryList\";\nimport { baseState, updateYear } from \"../state/state\";\n\nexport default Vue.extend({\n    components: {\n        Year,\n        Hamburger\n    },\n    props: {\n        entryByYears: Object as () => { [key: string]: EntryRoute[] }\n    },\n    watch: {\n        $route(to, from) {\n            this.navbarActivated = false;\n        }\n    },\n    data() {\n        return {\n            dates: baseState.dates,\n            navbarActivated: false\n        };\n    },\n    methods: {\n        selectYear(year: number) {\n            updateYear(year);\n        },\n        toggleNavbar() {\n            this.navbarActivated = !this.navbarActivated;\n        }\n    },\n    computed: {\n        entryList(): EntryRoute[] {\n            const list = this.fullEntryList;\n            const reducedList = list.slice(Math.max(0, list.length - 10), list.length);\n            return reducedList;\n        },\n        fullEntryList(): EntryRoute[] {\n            return this.entryByYears[this.selectedYear + \"\"];\n        },\n        selectedYear(): number {\n            return this.dates.year;\n        },\n        shouldTruncateList(): boolean {\n            return this.entryList.length !== this.fullEntryList.length;\n        },\n        lastEntryName(): string {\n            return this.entryList[this.entryList.length - 1].name;\n        },\n        years(): number[] {\n            return Object.keys(this.entryByYears).map((e) => parseInt(e, 10));\n        },\n        navbarStyle() {\n            if (!this.navbarActivated) {\n                return {\n                    left: \"-60vw\"\n                };\n            } else {\n                return {\n                    left: \"0\"\n                };\n            }\n        }\n    }\n});\n","export enum Choice {\n    first = \"first\",\n    second = \"second\"\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navbar.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navbar.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Navbar.vue?vue&type=template&id=459a144c&lang=pug&\"\nimport script from \"./Navbar.vue?vue&type=script&lang=ts&\"\nexport * from \"./Navbar.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Navbar.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import { Choice } from \"../constants/choice\";\nimport { Coordinate } from \"../support/geometry\";\nimport { Message } from \"./entryStatusMessages\";\n\nexport interface ScreenBuilder {requireScreen: (size?: Coordinate) => Promise<ScreenPrinter>; }\n\nexport interface EntryCallbackArg {\n    lines: string[];\n    outputCallback: OutputCallback;\n    resultOutputCallback: ResultOutputCallback;\n    pause: Pause;\n    isCancelled: (() => boolean);\n    setAutoStop: () => void;\n    additionalInputReader?: {\n        read: () => Promise<string | null>;\n        close: () => void;\n    };\n    screen?: ScreenBuilder;\n    isQuickRunning: boolean;\n    sendMessage?: MessageSender;\n}\n\nexport type Pause = (times?: number) => Promise<void>;\n\ntype OldEntryCallback = (\n    lines: string[],\n    outputCallback: ((outputLine: any) => Promise<void>),\n    statusCallback?: ((outputStatus: Message) => Promise<void>)\n) => Promise<void>;\n\nexport type OutputCallback = (outputLine: any, shouldClear?: boolean) => Promise<void>;\nexport type ResultOutputCallback = (outputLine: any) => Promise<void>;\n\ntype EntryCallback = (arg: EntryCallbackArg) => Promise<void>;\n\ninterface EntryMetadata {\n    key: string;\n    stars?: 1 | 2;\n    title: string;\n    date?: number;\n    hasAdditionalInput?: boolean;\n    suggestedDelay?: number;\n    customComponent?: \"pause-and-run\";\n    supportsQuickRunning?: boolean;\n    embeddedData?: string | true;\n}\n\nexport interface Entry {\n    first: EntryCallback;\n    second: EntryCallback;\n    metadata?: EntryMetadata;\n}\n\nexport function entryForFile(first: EntryCallback, second: EntryCallback, metadata?: EntryMetadata): Entry {\n    return {\n        first,\n        second,\n        metadata\n    };\n}\nexport function oldEntryForFile(first: OldEntryCallback, second: OldEntryCallback): Entry {\n    return {\n        first: (args: EntryCallbackArg) => (first(args.lines, args.outputCallback)),\n        second: (args: EntryCallbackArg) => (second(args.lines, args.outputCallback))\n    };\n}\n\nexport interface EntryFileHandling {\n    choice: Choice;\n    content: string[];\n}\n\nexport function simpleOutputCallbackFactory(output: string[], avoidOutput?: () => boolean) {\n    return (outputLine: any, shouldClear?: boolean): Promise<void> => {\n        if (avoidOutput && avoidOutput()) {\n            return new Promise((resolve) => resolve());\n        }\n        if (shouldClear) {\n            output.length = 0;\n        }\n\n        if (outputLine === null) {\n            output.length = 0;\n        } else if (typeof (outputLine) === \"string\") {\n            output.push(outputLine);\n        } else if (Array.isArray(outputLine)) {\n            output.push(outputLine.join(\"\\n\"));\n        } else {\n            output.push(JSON.stringify(outputLine, undefined, 4));\n        }\n        return new Promise<void>((resolve) => setTimeout(resolve, 0));\n    };\n}\n\nexport type Drawable = {\n    id: string;\n    color: string;\n} & ({\n    type: \"rectangle\";\n    c: Coordinate;\n    size: Coordinate;\n} | {\n    type: \"points\";\n    points: Coordinate[];\n});\n\nexport interface ScreenPrinter {\n    add: (item: Drawable) => Promise<void>;\n    remove: (id: string) => Promise<void>;\n    stop: () => Promise<void>;\n    replace: (items: Drawable[]) => Promise<void>;\n    changeColor: (indexOrId: string | number, color: string) => Promise<void>;\n    pause: () => (() => void);\n    forceRender: () => void;\n    setManualRender: () => void;\n}\n\nexport type MessageSender = (message: any) => Promise<void>;\ninterface ExecutionArgs {\n    entry: Entry;\n    choice: Choice;\n    lines: string[];\n    outputCallback: EntryCallbackArg[\"outputCallback\"];\n    isCancelled: (() => boolean);\n    pause?: () => Promise<void>;\n    sendMessage?: MessageSender;\n    additionalInputReader?: {\n        read: () => Promise<string | null>;\n        close: () => void;\n    };\n    screen?: {\n        requireScreen: (size?: Coordinate) => Promise<ScreenPrinter>;\n    };\n    isQuickRunning: boolean;\n    stopTimer: () => void;\n}\n\nexport class StopException extends Error {\n    public isStop = true;\n}\n\nexport async function executeEntry({\n    entry,\n    choice,\n    lines,\n    outputCallback,\n    isCancelled,\n    pause,\n    additionalInputReader,\n    screen,\n    isQuickRunning,\n    stopTimer,\n    sendMessage\n}: ExecutionArgs\n) {\n    let callback: EntryCallback;\n    if (choice === Choice.first) {\n        callback = entry.first;\n    } else {\n        callback = entry.second;\n    }\n    try {\n        const basePause = pause || (() => new Promise<void>((resolve) => setTimeout(resolve, 0)));\n        let shouldAutoStop = false;\n        const wrappedPause = async (times?: number) => {\n            if (isQuickRunning) {\n                return;\n            }\n            times = times || 1;\n            for (let i = 0; i < times; i++) {\n                if (shouldAutoStop && isCancelled()) {\n                    throw new StopException();\n                }\n                await basePause();\n                if (shouldAutoStop && isCancelled()) {\n                    throw new StopException();\n                }\n            }\n        };\n        let resultOutput = 0;\n        await callback({\n            lines,\n            outputCallback: !isQuickRunning ? outputCallback : async () => {},\n            resultOutputCallback: isQuickRunning ? async (line: any, shouldClear?: boolean) => {\n                if (resultOutput > 0) {\n                    throw new Error(\"Cannot output results more than once\");\n                }\n                stopTimer();\n                resultOutput++;\n                await outputCallback(line, shouldClear);\n            } : outputCallback,\n            pause: wrappedPause,\n            isCancelled,\n            additionalInputReader,\n            screen: isQuickRunning ? undefined : screen,\n            setAutoStop: () => shouldAutoStop = true,\n            isQuickRunning,\n            sendMessage\n        });\n    } catch (e) {\n        if ((e as StopException).isStop) {\n            console.log(\"Stopped, all fine\");\n            return;\n        }\n        await outputCallback(\"ERROR: \" + (e as Error).message);\n        console.error(e);\n    }\n}\n","import { entryForFile } from \"../../entry\";\r\n\r\nexport const notQuiteLisp = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const line = lines[0];\r\n        const count = line.split(\"\").reduce((acc, next) => acc + (next === \"(\" ? 1 : -1), 0);\r\n        await outputCallback(count);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const line = lines[0];\r\n\r\n        let position = 0;\r\n        for (let i = 0; i < line.length; i++) {\r\n            position += (line[i] === \"(\" ? 1 : -1);\r\n            if (position < 0) {\r\n                await outputCallback(\"Found it! \" + (i + 1));\r\n                return;\r\n            }\r\n        }\r\n\r\n        await outputCallback(\"Never gone to the basement\");\r\n    },\r\n    { key: \"not-quite-lisp\", title: \"Not Quite Lisp\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nexport const iWasToldThereWouldBeNoMath = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const sizes = lines.map((line) => {\r\n            return line.split(\"x\").map((e) => parseInt(e, 10));\r\n        })\r\n            .map((size) => ({\r\n                areas: [\r\n                    size[0] * size[1],\r\n                    size[0] * size[2],\r\n                    size[1] * size[2]\r\n                ]\r\n            }))\r\n            .map((areas) => ({\r\n                minArea: areas.areas.reduce((acc, next) => Math.min(acc, next)),\r\n                totalArea: areas.areas.reduce((acc, next) => acc + next) * 2\r\n            }))\r\n            .reduce((acc, next) => acc + (next.minArea + next.totalArea), 0);\r\n\r\n        await outputCallback(sizes);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const sizes = lines.map((line) => {\r\n            return line.split(\"x\").map((e) => parseInt(e, 10));\r\n        })\r\n            .map((size) => {\r\n                const biggest = size.reduce((acc, next) => Math.max(acc, next));\r\n                const smallestPerimeter = (size.reduce((acc, next) => acc + next) - biggest) * 2;\r\n                const volume = size.reduce((acc, next) => acc * next);\r\n                return {\r\n                    smallestPerimeter,\r\n                    volume\r\n                };\r\n            })\r\n            .map((a) => a.smallestPerimeter + a.volume)\r\n            .reduce((acc, next) => acc + next);\r\n\r\n        await outputCallback(sizes);\r\n\r\n    },\r\n    {\r\n        key: \"i-was-told-there-would-be-no-math\",\r\n        title: \"I Was Told There Would Be No Math\",\r\n        stars: 2\r\n    }\r\n);\r\n","export interface BestArg<T, U> {\n    key: T;\n    value: U;\n}\n\ntype Comparator<T> = (a: T, b: T) => number;\n\nexport const maxNumber: Comparator<number> = (a, b) => a - b;\nexport const minNumber: Comparator<number> = (a, b) => maxNumber(a, b) * -1;\n\nexport const ascending = maxNumber;\nexport const descending = minNumber;\n\n\nexport class CustomBest<T, U> {\n    public currentBest: BestArg<T, U> | null = null;\n    constructor(private comparator: Comparator<T>) {\n    }\n    public add(e: BestArg<T, U>) {\n        if ((this.currentBest === null) || this.comparator(this.currentBest.key, e.key) < 0) {\n            this.currentBest = e;\n        }\n    }\n}\n\nexport default class Best<U> extends CustomBest<number, U> {\n    constructor() {\n        super((a, b) => a - b);\n    }\n}\n\nexport class SimpleBest<T> {\n    public currentBest: T | null = null;\n\n    constructor(private comparator: Comparator<T>) {\n    }\n\n    public add(e: T) {\n        if ((this.currentBest === null) || this.comparator(this.currentBest, e) < 0) {\n            this.currentBest = e;\n        }\n    }\n}\n","import { SimpleBest, ascending } from \"./best\";\nimport { coordinateToKey } from \"../entries/single-entries/2019/oxygen-system\";\n\nexport interface Coordinate {\n    x: number;\n    y: number;\n}\n\nexport interface Coordinate3d extends Coordinate {\n    z: number;\n}\n\nexport interface Coordinate4d extends Coordinate3d {\n    w: number;\n}\n\nexport type FullCoordinate = Coordinate | Coordinate3d | Coordinate4d;\n\nfunction is4d(c: FullCoordinate): c is Coordinate4d {\n    return (c as Coordinate4d).w !== undefined;\n}\nfunction is3d(c: FullCoordinate): c is Coordinate3d {\n    return (c as Coordinate3d).z !== undefined && (c as Coordinate4d).w === undefined;\n}\n\nfunction is2d(c: FullCoordinate): c is Coordinate {\n    return (c as Coordinate3d).z === undefined;\n}\n\nfunction isBounds(c: Coordinate | Bounds): c is Bounds {\n    return (c as Bounds).size !== undefined;\n}\n\nexport class CCoordinate implements Coordinate {\n\n    public get opposite() {\n        return new CCoordinate(-this.x, -this.y);\n    }\n\n    public static fromCoordinate(c: Coordinate) {\n        return new CCoordinate(c.x, c.y);\n    }\n    public constructor(public x: number, public y: number) {\n\n    }\n\n    public isInBounds = (b: Bounds | Coordinate): boolean => {\n        if (isBounds(b)) {\n            return isInBounds(this, b);\n        } else {\n            return isInBounds(this, {\n                size: b,\n                topLeft: {\n                    x: 0,\n                    y: 0\n                }\n            });\n        }\n    }\n\n    public is = (other: Coordinate) => {\n        return manhattanDistance(this, other) === 0;\n    }\n\n    public sum = (other: Coordinate) => {\n        const result = sumCoordinate(this, other);\n        return new CCoordinate(result.x, result.y);\n    }\n\n    public diff = (other: Coordinate) => {\n        const result = sumCoordinate(this, { x: -other.x, y: -other.y });\n        return new CCoordinate(result.x, result.y);\n    }\n\n    public toString(): string {\n        return `(${this.x},${this.y})`;\n    }\n\n    public times = (t: number): CCoordinate => {\n        const result = scalarCoordinates(this, t);\n        return new CCoordinate(result.x, result.y);\n    }\n}\n\nexport const directions = {\n    up: new CCoordinate(0, -1),\n    down: new CCoordinate(0, 1),\n    left: new CCoordinate(-1, 0),\n    right: new CCoordinate(1, 0),\n    upLeft: new CCoordinate(-1, -1),\n    upRight: new CCoordinate(1, -1),\n    downLeft: new CCoordinate(-1, 1),\n    downRight: new CCoordinate(1, 1)\n};\n\nexport const directionList = [\n    directions.up,\n    directions.down,\n    directions.left,\n    directions.right,\n    directions.upLeft,\n    directions.upRight,\n    directions.downLeft,\n    directions.downRight\n];\n\nexport type Rotation = \"Clockwise\" | \"Counterclockwise\" | \"None\";\nexport function rotate(\n    coordinate: CCoordinate,\n    direction: Rotation,\n    times: number = 1\n    ): CCoordinate {\n    if (times > 1) {\n        coordinate = rotate(coordinate, direction, times - 1);\n    }\n    switch (direction) {\n        case \"Counterclockwise\":\n            return new CCoordinate(coordinate.y, -coordinate.x);\n        case \"Clockwise\":\n            return new CCoordinate(-coordinate.y, coordinate.x);\n        case \"None\":\n            return coordinate;\n    }\n}\n\n\nfunction fillWithZero(c: Coordinate): Coordinate;\nfunction fillWithZero(c: Coordinate3d): Coordinate3d;\nfunction fillWithZero(c: Coordinate4d): Coordinate4d;\nfunction fillWithZero(c: FullCoordinate): FullCoordinate {\n    if (is4d(c)) {\n        if (!c.w) {\n            c.w = 0;\n        }\n        if (!c.z) {\n            c.z = 0;\n        }\n    }\n    if (is3d(c)) {\n        if (!c.z) {\n            c.z = 0;\n        }\n    }\n    if (!c.x) {\n        c.x = 0;\n    }\n    if (!c.y) {\n        c.y = 0;\n    }\n    return c;\n}\n\nexport interface Bounds {\n    topLeft: Coordinate;\n    size: Coordinate;\n}\n\nexport function ascendingCompare(a: Coordinate, b: Coordinate): number {\n    if (b.y === a.y) {\n        return ascending(a.x, b.x);\n    } else {\n        return ascending(a.y, b.y);\n    }\n}\n\nexport function isInBounds(c: Coordinate, bounds: Bounds) {\n    return (\n        c.x >= bounds.topLeft.x &&\n        c.y >= bounds.topLeft.y &&\n        c.x < bounds.topLeft.x + bounds.size.x &&\n        c.y < bounds.topLeft.y + bounds.size.y\n    );\n}\nexport const getBoundaries = (points: Coordinate[]): Bounds => {\n    if (points.length === 0) {\n        return {\n            topLeft: { x: 0, y: 0 },\n            size: { x: 0, y: 0 }\n        };\n    }\n    const { maxX, minX, maxY, minY } = getRanges(points);\n    const size = {\n        x: (maxX.currentBest! - minX.currentBest! + 1),\n        y: (maxY.currentBest! - minY.currentBest! + 1),\n    };\n    return {\n        topLeft: {\n            x: minX.currentBest!,\n            y: minY.currentBest!,\n        },\n        size,\n    };\n};\n\n\nexport function sumCoordinate(a: Coordinate4d, b: Coordinate4d): Coordinate4d;\nexport function sumCoordinate(a: Coordinate3d, b: Coordinate3d): Coordinate3d;\nexport function sumCoordinate(a: Coordinate, b: Coordinate): Coordinate;\nexport function sumCoordinate(a: FullCoordinate, b: FullCoordinate): FullCoordinate {\n    a = fillWithZero(a);\n    b = fillWithZero(b);\n    if (is4d(a) && is4d(b)) {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y,\n            z: a.z + b.z,\n            w: a.w + b.w,\n        };\n    } else if (is3d(a) && is3d(b)) {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y,\n            z: a.z + b.z\n        };\n    } else {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y,\n        };\n    }\n}\n\nexport function getDirection(from: Coordinate, to: Coordinate): CCoordinate {\n    if (manhattanDistance(from, to) !== 1) {\n        throw new RangeError(\"Cannot move to distant cell\");\n    }\n    if (from.x > to.x) {\n        return directions.left;\n    } else if (from.x < to.x) {\n        return directions.right;\n    } else if (from.y > to.y) {\n        return directions.up;\n    } else if (from.y < to.y) {\n        return directions.down;\n    } else {\n        throw new Error(\"Something went wrong :(\");\n    }\n}\n\nexport const scalarCoordinates = (a: Coordinate, l: number) => ({ x: a.x * l, y: a.y * l });\n\nexport const oppositeCoordinate = (a: Coordinate): Coordinate => ({ x: -a.x, y: -a.y });\n\nexport const diffCoordinate = (a: Coordinate, b: Coordinate): Coordinate => sumCoordinate(a, oppositeCoordinate(b));\nexport const manhattanDistance = (a: FullCoordinate, b: FullCoordinate) => {\n    const w = (is4d(a) && is4d(b)) ? Math.abs(a.w - b.w) : 0;\n    const z = ((is3d(a) && is3d(b)) || (is4d(a) && is4d(b))) ? Math.abs(a.z - b.z) : 0;\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + z + w;\n};\n\nexport function getSurrounding(c: Coordinate): Coordinate[];\nexport function getSurrounding(c: Coordinate3d): Coordinate3d[];\nexport function getSurrounding(c: Coordinate4d): Coordinate4d[];\nexport function getSurrounding(c: FullCoordinate): FullCoordinate[] {\n    if (is2d(c)) {\n        return [\n            directions.up,\n            directions.left,\n            directions.down,\n            directions.right\n        ].map((d) => d.sum(c));\n    } else {\n        return getFullSurrounding(c).filter((e) => manhattanDistance(c, e) === 1);\n    }\n}\n\nexport function getFullSurrounding(coordinate: Coordinate): Coordinate[];\nexport function getFullSurrounding(coordinate: Coordinate3d): Coordinate3d[];\nexport function getFullSurrounding(coordinate: Coordinate4d): Coordinate4d[];\nexport function getFullSurrounding(coordinate: FullCoordinate): FullCoordinate[] {\n    if (is4d(coordinate)) {\n        const result: Coordinate4d[] = [];\n        const deltas = [-1, 0, 1];\n        for (const x of deltas) {\n            for (const y of deltas) {\n                for (const z of deltas) {\n                    for (const w of deltas) {\n                        const neighbour = sumCoordinate(coordinate, {x, y, z, w});\n                        if (manhattanDistance(neighbour, coordinate) === 0) {\n                            continue;\n                        }\n                        result.push(neighbour);\n                    }\n                }\n            }\n        }\n        return result;\n    } else if (is2d(coordinate)) {\n        const c = coordinate;\n        return [\n            directions.up,\n            directions.left,\n            directions.down,\n            directions.right,\n            directions.upLeft,\n            directions.upRight,\n            directions.downLeft,\n            directions.downRight,\n        ].map((d) => d.sum(c));\n    } else {\n        const result: Coordinate3d[] = [];\n        const deltas = [-1, 0, 1];\n        for (const x of deltas) {\n            for (const y of deltas) {\n                for (const z of deltas) {\n                    const neighbour = sumCoordinate(coordinate, {x, y, z});\n                    if (manhattanDistance(neighbour, coordinate) === 0) {\n                        continue;\n                    }\n                    result.push(neighbour);\n                }\n            }\n        }\n        return result;\n    }\n}\n\n\nexport function getRanges(points: Coordinate[]) {\n    const minComparator = (a: number, b: number) => b - a;\n    const maxComparator = (a: number, b: number) => a - b;\n    const minX = new SimpleBest<number>(minComparator);\n    const maxX = new SimpleBest<number>(maxComparator);\n    const minY = new SimpleBest<number>(minComparator);\n    const maxY = new SimpleBest<number>(maxComparator);\n    points.forEach((p) => {\n        minX.add(p.x);\n        maxX.add(p.x);\n        minY.add(p.y);\n        maxY.add(p.y);\n    });\n    return { maxX, minX, maxY, minY };\n}\n\nexport function getCoordinateForGrid(index: number, rows: number): Coordinate {\n    return {\n        x: Math.floor(index / rows),\n        y: index % rows\n    };\n}\n\n\nexport const serialization = {\n    serialize(c: FullCoordinate): string {\n        const els = [c.x, c.y];\n        if (is3d(c)) {\n            els.push(c.z);\n        } else if (is4d(c)) {\n            els.push(c.z);\n            els.push(c.w);\n        }\n        return els.join(\"|\");\n    },\n    deserialize4d(s: string): Coordinate4d {\n        const split = s.split(\"|\").map((e) => parseInt(e, 10));\n        if (split.length !== 4) {\n            throw new RangeError(\"Could not deserialize \" + s);\n        }\n        return {\n            x: split[0],\n            y: split[1],\n            z: split[2],\n            w: split[3],\n        };\n    },\n    deserialize3d(s: string): Coordinate3d {\n        const split = s.split(\"|\").map((e) => parseInt(e, 10));\n        if (split.length !== 3) {\n            throw new RangeError(\"Could not deserialize \" + s);\n        }\n        return {\n            x: split[0],\n            y: split[1],\n            z: split[2]\n        };\n    },\n    deserialize(s: string): Coordinate {\n        const split = s.split(\"|\");\n        if (split.length !== 2) {\n            throw new RangeError(\"Could not deserialize \" + s);\n        }\n        return {\n            x: parseInt(split[0], 10),\n            y: parseInt(split[1], 10)\n        };\n    }\n};\n\nexport const euclidean3dDistance = (a: Coordinate3d, b: Coordinate3d): number => {\n    return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2);\n};\n\nexport const multiplyCoordinate = (a: Coordinate, b: Coordinate): Coordinate => {\n    return {\n        x: a.x * b.x,\n        y: a.y * b.y\n    };\n};\n","import { entryForFile } from \"../../entry\";\r\nimport { directions, serialization, CCoordinate } from \"../../../support/geometry\";\r\n\r\ntype Directions = \">\" | \"<\" | \"^\" | \"v\";\r\n\r\nexport const perfectSphericalHousesInAVacuum = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const visited = new Set<string>();\r\n        const startPosition = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        const directionMapper: {[key: string]: CCoordinate} = {\r\n            \">\": directions.right,\r\n            \"<\": directions.left,\r\n            \"^\": directions.up,\r\n            \"v\": directions.down\r\n        };\r\n        let currentPosition = {...startPosition};\r\n\r\n        visited.add(serialization.serialize(currentPosition));\r\n\r\n        lines[0].split(\"\").forEach((c) => {\r\n            currentPosition = directionMapper[c].sum(currentPosition);\r\n            visited.add(serialization.serialize(currentPosition));\r\n        });\r\n        await outputCallback(visited.size);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const visited = new Set<string>();\r\n        const startPosition = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        const directionMapper: {[key: string]: CCoordinate} = {\r\n            \">\": directions.right,\r\n            \"<\": directions.left,\r\n            \"^\": directions.up,\r\n            \"v\": directions.down\r\n        };\r\n        const currentPositions = [{...startPosition}, {...startPosition}];\r\n\r\n        visited.add(serialization.serialize(startPosition));\r\n\r\n        let next = 0;\r\n        lines[0].split(\"\").forEach((c) => {\r\n            currentPositions[next] = directionMapper[c].sum(currentPositions[next]);\r\n            visited.add(serialization.serialize(currentPositions[next]));\r\n            next = (next + 1) % currentPositions.length;\r\n        });\r\n        await outputCallback(visited.size);\r\n    },\r\n    {\r\n        key: \"perfect-spherical-houses-in-a-vacuum\",\r\n        title: \"Perfect Spherical Houses in a Vacuum\",\r\n        stars: 2\r\n    }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport {Md5} from \"ts-md5\";\r\n\r\nconst hasLeadingZeros = (s: string, n: number): boolean => {\r\n    for (let i = 0; i < n; i++) {\r\n        if (s[i] !== \"0\") {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const theIdealStockingStuffer = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const key = lines[0].trim();\r\n        let i = 1;\r\n        while (true) {\r\n            const hashed = Md5.hashAsciiStr(key + i) as string;\r\n            if (hasLeadingZeros(hashed, 5)) {\r\n                await outputCallback(\"Found it: \" + i);\r\n                return;\r\n            }\r\n            i++;\r\n        }\r\n\r\n        await outputCallback(hasLeadingZeros(Md5.hashAsciiStr(key) as string, 1));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const key = lines[0].trim();\r\n        let i = 1;\r\n        while (true) {\r\n            const hashed = Md5.hashAsciiStr(key + i) as string;\r\n            if (hasLeadingZeros(hashed, 6)) {\r\n                await outputCallback(\"Found it: \" + i);\r\n                return;\r\n            }\r\n            i++;\r\n        }\r\n    },\r\n    {\r\n        key: \"the-ideal-stocking-stuffer\",\r\n        title: \"The Ideal Stocking Stuffer\",\r\n        stars: 2\r\n    }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nconst calculateHasDuplicates = (s: string): boolean => {\r\n    for (let i = 1; i < s.length; i++) {\r\n        if (s[i] === s[i - 1]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nconst buildGroups = (s: string, size: number): string[] => {\r\n    const res: string[] = [];\r\n    for (let i = 0; i <= s.length - size; i++) {\r\n        res.push(s.slice(i, i + size));\r\n    }\r\n    return res;\r\n};\r\nconst isNice = (s: string): boolean => {\r\n    const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\r\n    const howManyVowels = s.split(\"\").filter((c) => vowels.indexOf(c) >= 0).length;\r\n    const hasDuplicates = calculateHasDuplicates(s);\r\n    const hasForbidden = [\"ab\", \"cd\", \"pq\", \"xy\"].filter((e) => s.indexOf(e) >= 0).length > 0;\r\n\r\n    const conditions = [(howManyVowels >= 3), hasDuplicates, !hasForbidden];\r\n    return conditions.reduce((acc, next) => acc && next);\r\n};\r\n\r\nconst hasNicePairs = (s: string): boolean => {\r\n    const pairs = buildGroups(s, 2);\r\n    for (let i = 0; i < pairs.length; i++) {\r\n        if (pairs.lastIndexOf(pairs[i]) > i + 1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nconst hasNiceTrios = (s: string): boolean => {\r\n    const trios = buildGroups(s, 3);\r\n    for (const trio of trios) {\r\n        if (trio[0] === trio[2]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nexport const internElves = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const niceLines = lines.filter(isNice);\r\n        await outputCallback(niceLines.length);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const niceLines = lines.filter((line) => hasNicePairs(line) && hasNiceTrios(line));\r\n        await outputCallback(niceLines.length);\r\n    },\r\n    {\r\n        key: \"intern-elves\",\r\n        title: \"Doesn't He Have Intern-Elves For This?\",\r\n        stars: 2\r\n    }\r\n);\r\n","export async function forEachAsync<T>(data: T[], action: ((e: T) => Promise<void>)) {\n    for (const element of data) {\n        await action(element);\n    }\n}\n\nexport async function mapAsync<T, U>(data: T[], action: ((e: T) => Promise<U>)): Promise<U[]> {\n    const res = [];\n    for (const element of data) {\n        res.push(await action(element));\n    }\n    return res;\n}\n\nexport function setTimeoutAsync(timeout: number): Promise<void> {\n    return new Promise<void>((resolve, reject) => setTimeout(() => resolve(), timeout));\n}\nexport function voidIsPromise(e: void | Promise<void>): e is Promise<void> {\n    const casted = e as Promise<void>;\n    return casted && casted.then !== undefined;\n}\n\nexport function isPromise(e: void | Promise<any>): e is Promise<any> {\n    const casted = e as Promise<any>;\n    return casted && casted.then !== undefined;\n}\n","import { Coordinate, CCoordinate, manhattanDistance } from \"./geometry\";\nimport wu, { zip } from \"wu\";\nimport { voidIsPromise, isPromise } from \"./async\";\n\nexport class FixedSizeMatrix<T> {\n\n    public get delta() {\n        return this._delta;\n    }\n    public data: Array<T | undefined>;\n\n    private _delta: CCoordinate = new CCoordinate(0, 0);\n    constructor(public size: Coordinate) {\n        this.data = new Array<(T | undefined)>(size.x * size.y);\n    }\n\n    public getFlatData(): T[] {\n        return this.data.filter((e) => e) as T[];\n    }\n\n    public map<U>(mapper: (e: T | undefined, c: Coordinate) => U): FixedSizeMatrix<U> {\n        const result = new FixedSizeMatrix<U>(this.size);\n        for (let i = 0; i < this.data.length; i++) {\n            const c = this.coordinateCalculator(i);\n            result.data[i] = mapper(this.data[i], c);\n        }\n        return result;\n    }\n\n    public setDelta(delta: CCoordinate) {\n        this._delta = delta;\n    }\n\n    public fill(fillValue: T | undefined) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] = fillValue;\n        }\n    }\n\n    public fillFactory(fillValueFactory: (c: Coordinate) => T) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] = fillValueFactory(this.coordinateCalculator(i));\n        }\n    }\n\n    public setFlatData(a: T[]) {\n        if (a.length !== this.data.length) {\n            throw new Error(\"Wrong size!\");\n        }\n        this.data = [...a];\n    }\n    public get(c: Coordinate): T | undefined {\n        c = this._delta.opposite.sum(c);\n        const index = this.indexCalculator(c);\n        if (index !== null) {\n            return this.data[index];\n        }\n    }\n\n    public reduce<TAcc>(\n        callback: ((accumulator: TAcc, next: {coordinate: Coordinate, cell: T | undefined}) => TAcc),\n        startAccumulator: TAcc\n    ): TAcc {\n        for (let y = 0; y < this.size.y; y++) {\n            for (let x = 0; x < this.size.x; x++) {\n                startAccumulator = callback(startAccumulator, {coordinate: {x, y}, cell: this.get({x, y})});\n            }\n        }\n        return startAccumulator;\n    }\n\n    public findOne(predicate: (cell: T) => boolean): Coordinate | null {\n        return this.findOneWithCoordinate((cell, coordinate) => predicate(cell));\n    }\n\n    public findOneWithCoordinate(predicate: (cell: T, coordinate: Coordinate) => boolean): Coordinate | null {\n        for (let x = 0; x < this.size.x; x++) {\n            for (let y = 0; y < this.size.y; y++) {\n                if (predicate(this.get({ x, y })!, {x, y})) {\n                    return this._delta.sum({ x, y });\n                }\n            }\n        }\n        return null;\n    }\n\n    public async onEveryCell<U>(\n        callback: (c: Coordinate, e: T | undefined) =>\n            Promise<U | undefined> | void\n    ): Promise<U | undefined> {\n        for (let x = 0; x < this.size.x; x++) {\n            for (let y = 0; y < this.size.y; y++) {\n                const res = callback(this._delta.sum({ x, y }), this.get(this._delta.sum({ x, y })));\n                if (isPromise(res)) {\n                    const awaited = await res;\n                    if (awaited !== undefined) {\n                        return awaited;\n                    }\n                }\n            }\n        }\n    }\n\n    public onEveryCellSync<U>(callback: (c: Coordinate, e: T | undefined) => void | U): void | U {\n        for (let x = 0; x < this.size.x; x++) {\n            for (let y = 0; y < this.size.y; y++) {\n                const res = callback(this._delta.sum({ x, y }), this.get(this._delta.sum({ x, y })));\n                if (res !== undefined) {\n                    return res;\n                }\n            }\n        }\n    }\n\n    public set(c: Coordinate, value: T | undefined) {\n        c = this._delta.opposite.sum(c);\n        const index = this.indexCalculator(c);\n        if (index !== null) {\n            this.data[index] = value;\n        }\n    }\n\n    public copy(): FixedSizeMatrix<T> {\n        const newMatrix = new FixedSizeMatrix<T>(this.size);\n        newMatrix.data = this.data.slice();\n        return newMatrix;\n    }\n\n    public *overRows() {\n        for (let rowIndex = 0; rowIndex < this.size.y; rowIndex++) {\n            const startIndex = this.indexCalculator({ x: 0, y: rowIndex });\n            const endIndex = this.indexCalculator({ x: this.size.x - 1, y: rowIndex });\n            if (startIndex !== null && endIndex !== null) {\n                yield this.data.slice(\n                    startIndex,\n                    endIndex + 1\n                );\n            }\n        }\n    }\n\n    public toString(stringifier: (cell: T | undefined, coordinate?: Coordinate) => string): string {\n        let rowIndex = -1;\n        const serialized = wu(this.overRows()).map((row) => {\n            rowIndex++;\n            const res = [];\n            for (let i = 0; i < row.length; i++) {\n                res.push(stringifier(row[i], this._delta.sum({x: i, y: rowIndex})));\n            }\n            return res.join(\"\");\n        }).toArray().join(\"\\n\");\n        return serialized;\n    }\n\n    public simpleSerialize(): string {\n        return this.data.join(\"\");\n    }\n\n    public isSameAs(\n        other: FixedSizeMatrix<T>,\n        customComparer?: (a: (T | undefined), b: (T | undefined)\n    ) => boolean): boolean {\n        if (manhattanDistance(this.size, other.size) !== 0) {\n            return false;\n        }\n        const thisFlatData = this.data;\n        const otherFlatData = other.data;\n        for (const tuple of zip(thisFlatData, otherFlatData)) {\n            if (customComparer) {\n                return customComparer(tuple[0], tuple[1]);\n            }\n            if (tuple[0] !== tuple[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private indexCalculator(c: Coordinate): number | null {\n        if (c.y < 0 || c.x < 0 || c.x >= this.size.x || c.y >= this.size.y) {\n            return null;\n        }\n        return c.y * this.size.x + c.x;\n    }\n\n    private coordinateCalculator(i: number): Coordinate {\n        if (i < 0 || i >= this.data.length) {\n            throw new Error(\"Invalid index\");\n        }\n        return {x: i % this.size.x, y: Math.floor(i / this.size.x)};\n    }\n}\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\n\r\nexport const probablyAFireHazard = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const field = new FixedSizeMatrix<boolean>({x: 1000, y: 1000});\r\n        lines.forEach((line) => {\r\n            let delta: number | null = null;\r\n            let mapper: ((original: boolean) => boolean) | null = null;\r\n            if (line.startsWith(\"turn on\")) {\r\n                delta = 2;\r\n                mapper = ((_) => true);\r\n            } else if (line.startsWith(\"toggle\")) {\r\n                delta = 1;\r\n                mapper = ((x) => !x);\r\n            } else if (line.startsWith(\"turn off\")) {\r\n                delta = 2;\r\n                mapper = ((_) => false);\r\n            } else {\r\n                throw new Error(\"Unexpected line\");\r\n            }\r\n            const tokens = line.split(\" \");\r\n            const [top, left] = tokens[delta].split(\",\").map((e) => parseInt(e, 10));\r\n            const [bottom, right] = tokens[delta + 2].split(\",\").map((e) => parseInt(e, 10));\r\n            for (let x = left; x <= right; x++) {\r\n                for (let y = top; y <= bottom; y++) {\r\n                    field.set({x, y}, mapper(field.get({x, y}) || false));\r\n                }\r\n            }\r\n        });\r\n        const count = field.reduce((acc, next) => acc + (next.cell ? 1 : 0), 0);\r\n        await outputCallback(count);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const field = new FixedSizeMatrix<number>({x: 1000, y: 1000});\r\n        field.fill(0);\r\n        lines.forEach((line) => {\r\n            let delta: number | null = null;\r\n            let mapper: ((original: number) => number) | null = null;\r\n            if (line.startsWith(\"turn on\")) {\r\n                delta = 2;\r\n                mapper = ((n) => n + 1);\r\n            } else if (line.startsWith(\"toggle\")) {\r\n                delta = 1;\r\n                mapper = ((n) => n + 2);\r\n            } else if (line.startsWith(\"turn off\")) {\r\n                delta = 2;\r\n                mapper = ((n) => Math.max(n - 1, 0));\r\n            } else {\r\n                throw new Error(\"Unexpected line\");\r\n            }\r\n            const tokens = line.split(\" \");\r\n            const [top, left] = tokens[delta].split(\",\").map((e) => parseInt(e, 10));\r\n            const [bottom, right] = tokens[delta + 2].split(\",\").map((e) => parseInt(e, 10));\r\n            for (let x = left; x <= right; x++) {\r\n                for (let y = top; y <= bottom; y++) {\r\n                    field.set({x, y}, mapper(field.get({x, y}) || 0));\r\n                }\r\n            }\r\n        });\r\n        const count = field.reduce((acc, next) => acc + (next.cell || 0), 0);\r\n        await outputCallback(count);\r\n    },\r\n    { key: \"probably-a-fire-hazard\", title: \"Probably a Fire Hazard\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\ntype State = Map<string, number>;\r\n\r\ntype Operation = {\r\n    operator: \"NOT\",\r\n    input: number | string;\r\n} | {\r\n    operator: \"AND\",\r\n    a: string | number;\r\n    b: string;\r\n} | {\r\n    operator: \"OR\",\r\n    a: string;\r\n    b: string;\r\n} | {\r\n    operator: \"RSHIFT\",\r\n    input: string;\r\n    amount: number;\r\n} | {\r\n    operator: \"LSHIFT\",\r\n    input: string,\r\n    amount: number\r\n} | {\r\n    operator: \"VALUE\",\r\n    amount: number | string\r\n};\r\n\r\ninterface InputLine {\r\n    destination: string;\r\n    operation: Operation;\r\n}\r\n\r\nconst parseInput = (lines: string[]): InputLine[] => {\r\n    const parsed: InputLine[] = lines.map((line) => {\r\n        const [left, destination] = line.split(\" -> \");\r\n        const tokens = left.split(\" \");\r\n        if (tokens[0] === \"NOT\") {\r\n            return {\r\n                destination,\r\n                operation: {\r\n                    operator: \"NOT\",\r\n                    input: parseNumberOrString(tokens[1])\r\n                }\r\n            };\r\n        }\r\n        switch (tokens[1]) {\r\n            case \"OR\":\r\n                return {\r\n                    destination,\r\n                    operation: {\r\n                        operator: \"OR\",\r\n                        a: tokens[0],\r\n                        b: tokens[2]\r\n                    }\r\n                };\r\n            case \"AND\":\r\n                return {\r\n                    destination,\r\n                    operation: {\r\n                        operator: \"AND\",\r\n                        a: parseNumberOrString(tokens[0]),\r\n                        b: tokens[2]\r\n                    }\r\n                };\r\n            case \"RSHIFT\":\r\n                return {\r\n                    destination,\r\n                    operation: {\r\n                        operator: \"RSHIFT\",\r\n                        input: tokens[0],\r\n                        amount: parseInt(tokens[2], 10)\r\n                    }\r\n                };\r\n            case \"LSHIFT\":\r\n                return {\r\n                    destination,\r\n                    operation: {\r\n                        operator: \"LSHIFT\",\r\n                        input: tokens[0],\r\n                        amount: parseInt(tokens[2], 10)\r\n                    }\r\n                };\r\n            default:\r\n                return {\r\n                    destination,\r\n                    operation: {\r\n                        operator: \"VALUE\",\r\n                        amount: parseNumberOrString(tokens[0])\r\n                    }\r\n                };\r\n        }\r\n    });\r\n    return parsed;\r\n};\r\n\r\nconst parseNumberOrString = (s: string): number | string => {\r\n    const parsed = parseInt(s, 10);\r\n    const isNumber = parsed.toString() === s;\r\n    return isNumber ? parsed : s;\r\n};\r\n\r\nconst calculate = (wire: string | number, state: State, input: InputLine[]): number => {\r\n    if (typeof(wire) !== \"string\") {\r\n        return wire;\r\n    }\r\n    if (state.has(wire)) {\r\n        return state.get(wire)!;\r\n    }\r\n    const [rule] = input.filter((line) => line.destination === wire);\r\n    if (!rule) {\r\n        throw new Error(\"Cannot parse rule for: \" + wire);\r\n    }\r\n    const value = handleOperation(rule, state, input);\r\n    if (Number.isNaN(value)) {\r\n        throw new Error(\"Got none from: \" + JSON.stringify(rule));\r\n    }\r\n    state.set(wire, value);\r\n    return value;\r\n\r\n};\r\n\r\nconst handleOperation = (rule: InputLine, state: State, input: InputLine[]): number => {\r\n    switch (rule.operation.operator) {\r\n        case \"VALUE\": {\r\n                if (typeof(rule.operation.amount) === \"string\") {\r\n                    return calculate(rule.operation.amount, state, input);\r\n                } else {\r\n                    return rule.operation.amount;\r\n                }\r\n            }\r\n        case \"AND\": {\r\n                const a = calculate(rule.operation.a, state, input);\r\n                const b = calculate(rule.operation.b, state, input);\r\n                return a & b;\r\n            }\r\n        case \"OR\": {\r\n                const a = calculate(rule.operation.a, state, input);\r\n                const b = calculate(rule.operation.b, state, input);\r\n                return a | b;\r\n            }\r\n        case \"LSHIFT\": {\r\n                const i = calculate(rule.operation.input, state, input);\r\n                return i << calculate(rule.operation.amount, state, input);\r\n            }\r\n        case \"RSHIFT\": {\r\n                const i = calculate(rule.operation.input, state, input);\r\n                return i >>> calculate(rule.operation.amount, state, input);\r\n            }\r\n        case \"NOT\": {\r\n                const i = calculate(rule.operation.input, state, input);\r\n                return ~i;\r\n            }\r\n    }\r\n};\r\n\r\nexport const someAssemblyRequired = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const state = new Map<string, number>();\r\n        const input = parseInput(lines);\r\n        const value = calculate(\"a\", state, input);\r\n        await outputCallback(value);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const state = new Map<string, number>();\r\n        const input = parseInput(lines);\r\n        const value = calculate(\"a\", state, input);\r\n        const newInput: InputLine[] = input.map((line) => line.destination === \"b\" ? {\r\n            ...line,\r\n            operation: {\r\n                operator: \"VALUE\",\r\n                amount: value\r\n            }\r\n        } : line);\r\n        const newValue = calculate(\"a\", new Map<string, number>(), newInput);\r\n        await outputCallback(newValue);\r\n    },\r\n    { key: \"some-assembly-required\", title: \"Some Assembly Required\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nconst countRealLetters = (line: string): number => {\r\n    let isEscaped = false;\r\n    let skip = 0;\r\n    const sliced = line.slice(1, line.length - 1);\r\n    let realCount = 0;\r\n    for (const c of sliced) {\r\n        if (skip > 0) {\r\n            skip--;\r\n        } else if (isEscaped) {\r\n            if (c === \"x\") {\r\n                skip = 2;\r\n            }\r\n            isEscaped = false;\r\n        } else {\r\n            if (c === \"\\\\\") {\r\n                isEscaped = true;\r\n            }\r\n            realCount++;\r\n        }\r\n    }\r\n    return realCount;\r\n};\r\n\r\nconst countEncoded = (line: string): number => {\r\n    let count = 2;\r\n    for (const c of line) {\r\n        if (c === \"\\\"\" || c === \"\\\\\") {\r\n            count++;\r\n        }\r\n        count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nexport const matchsticks = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const overhead = lines\r\n            .map((line) => line.length - countRealLetters(line))\r\n            .reduce((acc, next) => acc + next);\r\n        await outputCallback(overhead);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const encoded = lines\r\n            .map((line) => countEncoded(line) - line.length)\r\n            .reduce((acc, next) => acc + next);\r\n        await outputCallback(encoded);\r\n    },\r\n    { key: \"matchsticks\", title: \"Matchsticks\", stars: 2}\r\n);\r\n","export function howManySameAtEnd<T>(sequence: T[]): number {\r\n    if (!sequence || sequence.length === 0) {\r\n        return 0;\r\n    }\r\n    let counter = 1;\r\n    const lastElement: T = sequence[sequence.length - 1];\r\n    for (let i = sequence.length - 2; i >= 0; i--) {\r\n        if (lastElement === sequence[i]) {\r\n            counter++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return counter;\r\n}\r\n\r\nexport function groupBy<T>(sequence: T[], n: number): T[][] {\r\n    const result = [];\r\n    let next = [];\r\n    let current = 0;\r\n    for (const e of sequence) {\r\n        next.push(e);\r\n        if (++current === n) {\r\n            result.push(next);\r\n            next = [];\r\n            current = 0;\r\n        }\r\n    }\r\n    if (next.length > 0) {\r\n        result.push(next);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function* range(n: number) {\r\n    for (let i = 0; i < n; i++) {\r\n        yield i;\r\n    }\r\n}\r\n\r\nexport function* subsequenceGenerator<T>(array: T[]): Iterable<T[]> {\r\n    const start = 0;\r\n    const end = array.length;\r\n\r\n    for (let s = start; s < end; s++) {\r\n        for (let e = s + 1; e < end; e++) {\r\n            yield array.slice(s, e + 1);\r\n        }\r\n    }\r\n}\r\n\r\nexport function* subsetGenerator<T>(array: T[], start: number, howMany: number | null = null): Iterable<T[]> {\r\n    if (start >= array.length || howMany === 0) {\r\n        yield [];\r\n    } else {\r\n        if (howMany !== null) {\r\n            for (const sub of subsetGenerator(array, start + 1, howMany)) {\r\n                yield sub;\r\n            }\r\n            for (const sub of subsetGenerator(array, start + 1, howMany - 1)) {\r\n                yield [array[start]].concat(sub);\r\n            }\r\n        } else {\r\n            for (const sub of subsetGenerator(array, start + 1)) {\r\n                yield sub;\r\n                yield [array[start]].concat(sub);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function* permutationGenerator<T>(array: T[]): Iterable<T[]> {\r\n    if (array.length === 1) {\r\n        yield [array[0]];\r\n    } else {\r\n        for (let i = 0; i < array.length; i++) {\r\n            const startElement = array[i];\r\n            const otherElements = [...array];\r\n            otherElements.splice(i, 1);\r\n            for (const perm of permutationGenerator(otherElements)) {\r\n                yield [startElement].concat(perm);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function* buildGroups<T>(data: T[], size: number, step: number = 1): Iterable<T[]> {\r\n    for (let i = 0; i <= data.length - size; i += step) {\r\n        yield data.slice(i, i + size);\r\n    }\r\n}\r\n\r\nexport function* buildGroupsFromSeparator<T>(data: Iterable<T>, isSeparator: (e: T) => boolean): Iterable<T[]> {\r\n    let current: T[] = [];\r\n    let hadItems = false;\r\n    for (const item of data) {\r\n        hadItems = true;\r\n        if (isSeparator(item)) {\r\n            yield current;\r\n            current = [];\r\n        } else {\r\n            current.push(item);\r\n        }\r\n    }\r\n    if (hadItems && current.length > 0) {\r\n        yield current;\r\n    }\r\n}\r\n","import { entryForFile } from \"../../entry\";\r\nimport Graph from \"node-dijkstra\";\r\nimport { permutationGenerator, buildGroups } from \"../../../support/sequences\";\r\n\r\nexport const allInASingleNight = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const edges = lines.map((line) => {\r\n            const [left, distance] = line.split(\" = \");\r\n            const places = left.split(\" to \");\r\n            return {\r\n                places,\r\n                distance: parseInt(distance, 10)\r\n            };\r\n        });\r\n\r\n        const nodes = [...new Set<string>(edges.flatMap((e) => e.places))];\r\n\r\n        let bestResult: null | number = null;\r\n        for (const path of permutationGenerator(nodes)) {\r\n            let cost = 0;\r\n            for (const step of buildGroups(path, 2)) {\r\n                const stepCost = edges.filter((edge) =>\r\n                    edge.places.includes(step[0]) && edge.places.includes(step[1])\r\n                )[0].distance;\r\n                cost += stepCost;\r\n            }\r\n            if (bestResult === null || cost < bestResult) {\r\n                bestResult = cost;\r\n            }\r\n        }\r\n\r\n        await outputCallback(bestResult);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const edges = lines.map((line) => {\r\n            const [left, distance] = line.split(\" = \");\r\n            const places = left.split(\" to \");\r\n            return {\r\n                places,\r\n                distance: parseInt(distance, 10)\r\n            };\r\n        });\r\n\r\n        const nodes = [...new Set<string>(edges.flatMap((e) => e.places))];\r\n\r\n        let bestResult: null | number = null;\r\n        for (const path of permutationGenerator(nodes)) {\r\n            let cost = 0;\r\n            for (const step of buildGroups(path, 2)) {\r\n                const stepCost = edges.filter(\r\n                    (edge) => edge.places.includes(step[0]) && edge.places.includes(step[1])\r\n                )[0].distance;\r\n                cost += stepCost;\r\n            }\r\n            if (bestResult === null || cost > bestResult) {\r\n                bestResult = cost;\r\n            }\r\n        }\r\n\r\n        await outputCallback(bestResult);\r\n    },\r\n    { key: \"all-in-a-single-night\", title: \"All in a Single Night\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nconst sayNumber = (s: string): string => {\r\n    const res: string[] = [];\r\n    let i = 0;\r\n    while (i < s.length) {\r\n        const length = findSequenceLength(s, i);\r\n        res.push(`${length}${s[i]}`);\r\n        i += length;\r\n    }\r\n    return res.join(\"\");\r\n};\r\n\r\nconst findSequenceLength = (s: string, start: number): number => {\r\n    const c = s[start];\r\n    let i: number;\r\n    for (i = start + 1; i < s.length; i++) {\r\n        if (s[i] !== c) {\r\n            break;\r\n        }\r\n    }\r\n    return i - start;\r\n};\r\n\r\nexport const elvesLookElvesSay = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const input = lines[0];\r\n        let transformed = input;\r\n        for (let i = 0; i < 40; i++) {\r\n            transformed = sayNumber(transformed);\r\n        }\r\n        await outputCallback(transformed.length);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const input = lines[0];\r\n        let transformed = input;\r\n        for (let i = 0; i < 50; i++) {\r\n            transformed = sayNumber(transformed);\r\n        }\r\n        await outputCallback(transformed.length);\r\n    },\r\n    { key: \"elves-look-elves-say\", title: \"Elves Look, Elves Say\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { buildGroups } from \"../../../support/sequences\";\r\n\r\nconst limit = \"z\".charCodeAt(0);\r\nconst base = \"a\".charCodeAt(0);\r\n\r\nconst increment = (s: string): string => {\r\n    const tokens = s.split(\"\").reverse();\r\n    let carry = 1;\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        let c = tokens[i].charCodeAt(0);\r\n        c = c + carry;\r\n        carry = 0;\r\n        if (c > limit) {\r\n            c = base + (c - limit - 1);\r\n            carry++;\r\n        }\r\n        tokens[i] = String.fromCharCode(c);\r\n    }\r\n    return tokens.reverse().join(\"\");\r\n};\r\n\r\nconst testPairs = (s: string): boolean => {\r\n    const pairs = [...buildGroups(s.split(\"\"), 2)];\r\n    const allEqual = pairs\r\n        .map((p, i) => ({ p, i }))\r\n        .filter((e) => e.p[0] === e.p[1]);\r\n    return allEqual.length >= 2 && (allEqual[allEqual.length - 1].i - allEqual[0].i) >= 2;\r\n};\r\n\r\nconst testIncreasing = (s: string): boolean => {\r\n    const trios = buildGroups(s.split(\"\"), 3);\r\n    for (const trio of trios) {\r\n        if (\r\n            trio[2] === increment(trio[1]) &&\r\n            trio[1] === increment(trio[0]) &&\r\n            trio[0].charCodeAt(0) < trio[2].charCodeAt(0)\r\n        ) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nconst testPassword = (s: string): boolean => {\r\n    if (s.includes(\"i\") || s.includes(\"o\") || s.includes(\"l\")) {\r\n        return false;\r\n    }\r\n    if (!testPairs(s)) {\r\n        return false;\r\n    }\r\n    return testIncreasing(s);\r\n};\r\n\r\nexport const corporatePolicy = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const startPassword = lines[0];\r\n        let password = startPassword;\r\n        do {\r\n            password = increment(password);\r\n            if (password === startPassword) {\r\n                throw new Error(\"Finished domain, no result\");\r\n            }\r\n        } while (!testPassword(password));\r\n\r\n        await outputCallback(password);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const startPassword = lines[0];\r\n        let password = startPassword;\r\n        for (let i = 0; i < 2; i++) {\r\n            do {\r\n                password = increment(password);\r\n                if (password === startPassword) {\r\n                    throw new Error(\"Finished domain, no result\");\r\n                }\r\n            } while (!testPassword(password));\r\n        }\r\n\r\n        await outputCallback(password);\r\n    },\r\n    { key: \"corporate-policy\", title: \"Corporate Policy\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nconst countNumbers = (parsed: any, skipReds: boolean = false): number => {\r\n    if (typeof(parsed) === \"number\") {\r\n        return parsed as number;\r\n    } else if (typeof(parsed) === \"string\") {\r\n        return 0;\r\n    } else if (Array.isArray(parsed)) {\r\n        const array = parsed as any[];\r\n        return array.reduce((acc, next) => acc + countNumbers(next, skipReds), 0);\r\n    } else {\r\n        const keys = Object.keys(parsed);\r\n        if (skipReds) {\r\n            if (Object.values(parsed).includes(\"red\")) {\r\n                return 0;\r\n            }\r\n        }\r\n        return keys.reduce((acc, next) => acc + countNumbers(parsed[next], skipReds), 0);\r\n    }\r\n};\r\n\r\nexport const abacusFramework = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const parsed = JSON.parse(lines[0]);\r\n        const numbers = countNumbers(parsed);\r\n        await outputCallback(numbers);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const parsed = JSON.parse(lines[0]);\r\n        const numbers = countNumbers(parsed, true);\r\n        await outputCallback(numbers);\r\n    },\r\n    { key: \"abacus-framework\", title: \"JSAbacusFramework.io\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { permutationGenerator } from \"../../../support/sequences\";\r\n\r\ninterface AdjacencyRule {\r\n    adjacents: [string, string];\r\n    value: number;\r\n}\r\n\r\nconst parseRules = (lines: string[]): {\r\n    participants: string[],\r\n    rules: AdjacencyRule[]\r\n} => {\r\n    const participants = [...new Set<string>(\r\n        lines.map((l) => l.split(\" \")[0])\r\n    ).values()];\r\n\r\n    const rules = lines.map((line) => {\r\n        const tokens = line.split(\" \");\r\n        const sign = tokens.includes(\"gain\") ? 1 : -1;\r\n        const value = parseInt(tokens[3], 10);\r\n        const rule: AdjacencyRule = {\r\n            adjacents: [tokens[0], tokens[tokens.length - 1].slice(0, -1)],\r\n            value: sign * value\r\n        };\r\n        return rule;\r\n    });\r\n\r\n    return {\r\n        participants,\r\n        rules\r\n    };\r\n};\r\n\r\nconst calculateValue = (assignment: string[], rules: AdjacencyRule[]): number => {\r\n    let value = 0;\r\n    for (let i = 0; i < assignment.length; i++) {\r\n        const assignees = [assignment[i], assignment[(i + 1) % assignment.length]];\r\n        const matchingRules = rules.filter(\r\n            (rule) => rule.adjacents.includes(assignees[0]) && rule.adjacents.includes(assignees[1])\r\n        );\r\n        if (matchingRules.length !== 2) {\r\n            throw new Error(\"Could not find enough rules for \" + JSON.stringify(assignees));\r\n        }\r\n        value += matchingRules.reduce((acc, next) => acc + next.value, 0);\r\n    }\r\n    return value;\r\n};\r\n\r\nexport const knightsOfTheDinnerTable = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const { participants, rules } = parseRules(lines);\r\n\r\n        await outputCallback({\r\n            length: participants.length,\r\n            participants\r\n        });\r\n\r\n        let bestValue = Number.NEGATIVE_INFINITY;\r\n        for (const p of permutationGenerator(participants)) {\r\n            bestValue = Math.max(bestValue, calculateValue(p, rules));\r\n        }\r\n        await outputCallback(\"Best: \" + bestValue);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const { participants, rules } = parseRules(lines);\r\n\r\n        participants.push(\"Myself\");\r\n\r\n        participants.forEach((participant) => {\r\n            rules.push({\r\n                adjacents: [\"Myself\", participant],\r\n                value: 0\r\n            });\r\n            rules.push({\r\n                adjacents: [participant, \"Myself\"],\r\n                value: 0\r\n            });\r\n        });\r\n\r\n        await outputCallback({\r\n            length: participants.length,\r\n            participants\r\n        });\r\n\r\n        let bestValue = Number.NEGATIVE_INFINITY;\r\n        for (const p of permutationGenerator(participants)) {\r\n            bestValue = Math.max(bestValue, calculateValue(p, rules));\r\n        }\r\n        await outputCallback(\"Best: \" + bestValue);\r\n    },\r\n    {\r\n        key: \"knights-of-the-dinner-table\",\r\n        title: \"Knights of the Dinner Table\",\r\n        stars: 2\r\n    }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\ninterface Reindeer {\r\n    movement: {\r\n        speed: number,\r\n        duration: number\r\n    };\r\n    rest: number;\r\n    name: string;\r\n}\r\n\r\nconst parseReindeers = (lines: string[]): Reindeer[] => {\r\n    return lines.map((line) => {\r\n        const tokens = line.split(\" \");\r\n        return {\r\n            name: tokens[0],\r\n            rest: parseInt(tokens[tokens.length - 2], 10),\r\n            movement: {\r\n                speed: parseInt(tokens[3], 10),\r\n                duration: parseInt(tokens[6], 10)\r\n            }\r\n        };\r\n    });\r\n};\r\n\r\nconst calculateDistance = (reindeer: Reindeer, time: number): number => {\r\n    const period = reindeer.rest + reindeer.movement.duration;\r\n    const baseDistance = Math.floor(time / period) * (reindeer.movement.speed * reindeer.movement.duration);\r\n    const restOfTime = time % period;\r\n    const lastMovementTime = Math.min(reindeer.movement.duration, restOfTime);\r\n    const lastDistance = lastMovementTime * reindeer.movement.speed;\r\n    return baseDistance + lastDistance;\r\n};\r\n\r\nexport const reindeerOlympics = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const time = 2503;\r\n        const reindeers = parseReindeers(lines);\r\n        const distances = reindeers.map((r) => ({\r\n            reindeer: r.name,\r\n            distance: calculateDistance(r, time)\r\n        })).sort((a, b) => a.distance - b.distance);\r\n        await outputCallback(distances);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const maxTime = 2503;\r\n        const reindeers = parseReindeers(lines);\r\n        const points = new Map<string, number>();\r\n        reindeers.forEach((r) => points.set(r.name, 0));\r\n        for (let time = 1; time <= maxTime; time++) {\r\n            const distances = reindeers.map((r) => ({\r\n                reindeer: r.name,\r\n                distance: calculateDistance(r, time)\r\n            })).sort((a, b) => b.distance - a.distance);\r\n            const [winner] = distances;\r\n            points.set(winner.reindeer, points.get(winner.reindeer)! + 1);\r\n        }\r\n        await outputCallback([...points.values()].sort((a, b) => a - b));\r\n    },\r\n    { key: \"reindeer-olympics\", title: \"Reindeer Olympics\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { buildGroups } from \"../../../support/sequences\";\r\n\r\ninterface Ingredient {\r\n    name: string;\r\n    capacity: number;\r\n    durability: number;\r\n    flavor: number;\r\n    texture: number;\r\n    calories: number;\r\n}\r\n\r\nconst parseIngredients = (lines: string[]): Ingredient[] => {\r\n    return lines.map((line) => {\r\n        const tokens = line.split(\" \").map((e) => e.endsWith(\":\") || e.endsWith(\",\") ?\r\n            e.slice(0, -1) : e);\r\n        const name = tokens[0];\r\n        const values = [...buildGroups(tokens.slice(1), 2, 2)].map((e) => {\r\n            return {\r\n                type: e[0],\r\n                value: parseInt(e[1], 10)\r\n            };\r\n        });\r\n        const ingredient: Ingredient = {\r\n            name,\r\n            capacity: 0,\r\n            durability: 0,\r\n            flavor: 0,\r\n            texture: 0,\r\n            calories: 0\r\n        };\r\n        for (const t of values) {\r\n            (ingredient as any)[t.type] = t.value;\r\n        }\r\n        return ingredient;\r\n\r\n    });\r\n};\r\n\r\nfunction* generateRecipes(ingredients: Ingredient[], total: number): Iterable<Recipe[]> {\r\n    if (ingredients.length === 0) {\r\n        if (total === 0) {\r\n            return;\r\n        }\r\n        throw new Error(\"Wrong total: \" + total);\r\n    }\r\n    if (ingredients.length === 1) {\r\n        yield [{\r\n            amount: total,\r\n            ingredient: ingredients[0]\r\n        }];\r\n        return;\r\n    }\r\n    const [ingredient] = ingredients;\r\n    const otherIngredients = ingredients.slice(1);\r\n    for (let i = 1; i <= total - (ingredients.length - 1); i++) {\r\n        for (const permutation of generateRecipes(otherIngredients, total - i)) {\r\n            yield [{\r\n                ingredient,\r\n                amount: i\r\n            }].concat(permutation);\r\n        }\r\n    }\r\n}\r\n\r\nconst calculateSingleTotal = (single: Array<{ characteristic: number, amount: number }>): number => {\r\n    return Math.max(0, single.reduce((acc, next) => acc + (next.characteristic * next.amount), 0));\r\n};\r\n\r\ninterface Recipe { ingredient: Ingredient; amount: number; }\r\n\r\nconst calculateScore = (recipe: Recipe[]): number => {\r\n    if (recipe.reduce((acc, next) => acc + next.amount, 0) !== 100) {\r\n        throw new Error(\"Invalid amount\");\r\n    }\r\n    const totals = [\r\n        calculateSingleTotal(recipe.map((e) => ({\r\n            characteristic: e.ingredient.capacity,\r\n            amount: e.amount\r\n        }))),\r\n        calculateSingleTotal(recipe.map((e) => ({\r\n            characteristic: e.ingredient.durability,\r\n            amount: e.amount\r\n        }))),\r\n        calculateSingleTotal(recipe.map((e) => ({\r\n            characteristic: e.ingredient.flavor,\r\n            amount: e.amount\r\n        }))),\r\n        calculateSingleTotal(recipe.map((e) => ({\r\n            characteristic: e.ingredient.texture,\r\n            amount: e.amount\r\n        })))\r\n    ];\r\n\r\n    return totals.reduce((acc, next) => acc * next, 1);\r\n};\r\n\r\nconst calculateCalories = (recipe: Recipe[]): number => {\r\n    return recipe.reduce((acc, next) => acc + (next.ingredient.calories * next.amount), 0);\r\n};\r\n\r\nexport const scienceForHungryPeople = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const ingredients = parseIngredients(lines);\r\n        let bestResult = Number.NEGATIVE_INFINITY;\r\n        for (const permutation of generateRecipes(ingredients, 100)) {\r\n            const score = calculateScore(permutation);\r\n            bestResult = Math.max(bestResult, score);\r\n        }\r\n        await outputCallback(bestResult);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const ingredients = parseIngredients(lines);\r\n        const targetCalories = 500;\r\n        let bestResult = Number.NEGATIVE_INFINITY;\r\n        for (const permutation of generateRecipes(ingredients, 100)) {\r\n            if (calculateCalories(permutation) === targetCalories) {\r\n                const score = calculateScore(permutation);\r\n                bestResult = Math.max(bestResult, score);\r\n            }\r\n        }\r\n        await outputCallback(bestResult);\r\n    },\r\n    { key: \"science-for-hungry-people\", title: \"Science for Hungry People\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\ninterface DetectionData { [key: string]: number; }\r\nconst ticket: DetectionData = {\r\n    children: 3,\r\n    cats: 7,\r\n    samoyeds: 2,\r\n    pomeranians: 3,\r\n    akitas: 0,\r\n    vizslas: 0,\r\n    goldfish: 5,\r\n    trees: 3,\r\n    cars: 2,\r\n    perfumes: 1\r\n};\r\n\r\ninterface Sue {\r\n    id: number;\r\n    data: DetectionData;\r\n}\r\n\r\nconst parseSues = (lines: string[]): Sue[] => {\r\n    return lines.map((line) => {\r\n        const firstSeparator = line.indexOf(\":\");\r\n        const left = line.slice(0, firstSeparator);\r\n        const right = line.slice(firstSeparator + 2);\r\n        const id = parseInt(left.split(\" \")[1], 10);\r\n        const data = right.split(\", \").map((e) => {\r\n            const split = e.split(\": \");\r\n            return {\r\n                name: split[0],\r\n                value: parseInt(split[1], 10)\r\n            };\r\n        }).reduce((acc: DetectionData, next) => {\r\n            acc[next.name] = next.value;\r\n            return acc;\r\n        }, {});\r\n        return {\r\n            id,\r\n            data\r\n        };\r\n    });\r\n};\r\n\r\nconst checkSue = (sue: Sue, argTicket: DetectionData): boolean => {\r\n    for (const key of Object.keys(sue.data)) {\r\n        if (sue.data[key] !== argTicket[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nconst checkSueRanges = (sue: Sue, argTicket: DetectionData): boolean => {\r\n    for (const key of Object.keys(sue.data)) {\r\n        if (key === \"cats\" || key === \"trees\") {\r\n            if (sue.data[key] <= argTicket[key]) {\r\n                return false;\r\n            }\r\n        } else if (key === \"pomeranians\" || key === \"goldfish\") {\r\n            if (sue.data[key] >= argTicket[key]) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (sue.data[key] !== argTicket[key]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nexport const auntSue = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const sues = parseSues(lines);\r\n        for (const sue of sues) {\r\n            if (checkSue(sue, ticket)) {\r\n                await outputCallback(\"Found Sue: \" + sue.id);\r\n                return;\r\n            }\r\n        }\r\n        await outputCallback(\"Sue not found\");\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const sues = parseSues(lines);\r\n        for (const sue of sues) {\r\n            if (checkSueRanges(sue, ticket)) {\r\n                await outputCallback(\"Found Sue: \" + sue.id);\r\n                return;\r\n            }\r\n        }\r\n        await outputCallback(\"Sue not found\");\r\n    },\r\n    { key: \"aunt-sue\", title: \"Aunt Sue\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nconst findCombinations = (quantities: number[], amount: number, index: number, selected: number): number[] => {\r\n    if (amount === 0) {\r\n        return [selected];\r\n    }\r\n    if (index >= quantities.length) {\r\n        return [];\r\n    }\r\n    if (amount < quantities[index]) {\r\n        return findCombinations(quantities, amount, index + 1, selected);\r\n    }\r\n    return findCombinations(quantities, amount, index + 1, selected).concat(\r\n           findCombinations(quantities, amount - quantities[index], index + 1, selected + 1)\r\n    );\r\n};\r\n\r\nexport const noSuchThingAsTooMuch = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const quantities = lines.map((e) => parseInt(e, 10)).sort((a, b) => b - a);\r\n        await outputCallback(findCombinations(quantities, 150, 0, 0).length);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const quantities = lines.map((e) => parseInt(e, 10)).sort((a, b) => b - a);\r\n        const selected = findCombinations(quantities, 150, 0, 0).sort((a, b) => a - b);\r\n        const min = selected[0];\r\n        await outputCallback(selected.filter((e) => e === min).length);\r\n    },\r\n    { key: \"no-such-thing-as-too-much\", title: \"No Such Thing as Too Much\", stars: 2}\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { setTimeoutAsync } from \"../../../support/async\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { getSurrounding, manhattanDistance, getFullSurrounding } from \"../../../support/geometry\";\r\n\r\ntype Field = FixedSizeMatrix<\"#\" | \".\">;\r\n\r\nconst parseField = (lines: string[]): Field => {\r\n    const size = { x: lines[0].length, y: lines.length };\r\n    const field = new FixedSizeMatrix<\"#\" | \".\">(size);\r\n    field.setFlatData(lines.flatMap((l) => l.split(\"\").map((e) => e as \"#\" | \".\")));\r\n    return field;\r\n};\r\n\r\nconst iterateGame = (field: Field, leaveCornersOn: boolean = false): Field => {\r\n    const newField = field.copy();\r\n    field.onEveryCell((coordinate, cell) => {\r\n        if (leaveCornersOn &&\r\n            (manhattanDistance(coordinate, { x: 0, y: 0 }) === 0\r\n                || manhattanDistance(coordinate, { x: 0, y: field.size.y - 1 }) === 0\r\n                || manhattanDistance(coordinate, { x: field.size.x - 1, y: 0 }) === 0\r\n                || manhattanDistance(coordinate, { x: field.size.x - 1, y: field.size.y - 1 }) === 0)\r\n        ) {\r\n            return;\r\n        }\r\n        const onNeigbours = getFullSurrounding(coordinate)\r\n            .map((c) => field.get(c))\r\n            .filter((e) => e === \"#\")\r\n            .length;\r\n        if (cell === \"#\") {\r\n            if (onNeigbours !== 2 && onNeigbours !== 3) {\r\n                newField.set(coordinate, \".\");\r\n            }\r\n        } else if (cell === \".\") {\r\n            if (onNeigbours === 3) {\r\n                newField.set(coordinate, \"#\");\r\n            }\r\n        }\r\n    });\r\n    return newField;\r\n};\r\n\r\nexport const likeAGifForYourYard = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const field = parseField(lines);\r\n        let iteration = field;\r\n        const steps = 100;\r\n        for (let i = 0; i < steps; i++) {\r\n            iteration = iterateGame(iteration);\r\n        }\r\n        await outputCallback(iteration.reduce(\r\n            (acc, next) => acc + (next.cell === \"#\" ? 1 : 0),\r\n            0\r\n        ));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const field = parseField(lines);\r\n        let iteration = field;\r\n        const steps = 100;\r\n        for (let i = 0; i < steps; i++) {\r\n            iteration = iterateGame(iteration, true);\r\n        }\r\n        await outputCallback(iteration.reduce(\r\n            (acc, next) => acc + (next.cell === \"#\" ? 1 : 0),\r\n            0\r\n        ));\r\n    },\r\n    { key: \"like-a-gif-for-your-yard\", title: \"Like a GIF For Your Yard\", stars: 2 }\r\n);\r\n","import { entryForFile } from \"../../entry\";\nimport { exec } from \"child_process\";\n\ntype Register = \"a\" | \"b\";\n\ntype TuringInstruction =\n    { instruction: \"hlf\", arg: Register } |\n    { instruction: \"tpl\", arg: Register } |\n    { instruction: \"inc\", arg: Register } |\n    { instruction: \"jmp\", arg: number } |\n    { instruction: \"jie\", args: [Register, number] } |\n    { instruction: \"jio\", args: [Register, number] };\n\ninterface State {\n    a: number;\n    b: number;\n    ir: number;\n}\n\ntype Program = TuringInstruction[];\n\nconst createStartState = (): State => {\n    return {\n        a: 0,\n        b: 0,\n        ir: 0\n    };\n};\n\nconst parse = (lines: string[]): Program => {\n    return lines\n        .map((l) => l.trim())\n        .filter((l) => l.length > 0)\n        .map((l) => ({\n            instr: l.slice(0, 3),\n            args: l.slice(4).split(\", \")\n        }))\n        .map((e) => {\n            if (\n                e.instr === \"hlf\" ||\n                e.instr === \"tpl\" ||\n                e.instr === \"inc\"\n            ) {\n                return {\n                    instruction: e.instr,\n                    arg: e.args[0] as Register\n                } as TuringInstruction;\n            } else if (e.instr === \"jmp\") {\n                return {\n                    instruction: \"jmp\",\n                    arg: parseInt(e.args[0], 10)\n                } as TuringInstruction;\n            } else if (e.instr === \"jie\" || e.instr === \"jio\") {\n                return {\n                    instruction: e.instr,\n                    args: [\n                        e.args[0] as Register,\n                        parseInt(e.args[1], 10)\n                    ]\n                } as TuringInstruction;\n            } else {\n                throw new RangeError(\"Invalid instruction \" + e.instr);\n            }\n        });\n};\n\nconst executeInstruction = (instruction: TuringInstruction, state: State) => {\n    let newIr = state.ir + 1;\n    switch (instruction.instruction) {\n        case \"hlf\":\n            state[instruction.arg] = Math.floor(state[instruction.arg] / 2);\n            break;\n        case \"tpl\":\n            state[instruction.arg] *= 3;\n            break;\n        case \"inc\":\n            state[instruction.arg]++;\n            break;\n        case \"jmp\":\n            newIr = state.ir + instruction.arg;\n            break;\n        case \"jie\":\n            if (state[instruction.args[0]] % 2 === 0) {\n                newIr = state.ir + instruction.args[1];\n            }\n            break;\n        case \"jio\":\n            if (state[instruction.args[0]] === 1) {\n                newIr = state.ir + instruction.args[1];\n            }\n            break;\n    }\n    state.ir = newIr;\n};\n\nconst execute = (program: Program, state: State) => {\n    while (state.ir >= 0 && state.ir < program.length) {\n        executeInstruction(program[state.ir], state);\n    }\n};\n\nexport const turingLock = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const program = parse(lines);\n        const state = createStartState();\n        execute(program, state);\n        await outputCallback(state.b);\n    },\n    async ({ lines, outputCallback }) => {\n        const program = parse(lines);\n        const state = createStartState();\n        state.a = 1;\n        execute(program, state);\n        await outputCallback(state.b);\n    },\n    { key: \"turing-lock\", title: \"Opening the Turing Lock\", stars: 2 }\n);\n","import { entryForFile } from \"../../entry\";\nimport { Queue } from \"../../../support/data-structure\";\nimport { parse } from \"path\";\nimport { isProbablyPrime } from \"bigint-crypto-utils\";\nimport { setTimeoutAsync } from \"../../../support/async\";\n\ninterface Rule {\n    from: string;\n    to: string[];\n    flatTo: string;\n}\n\nconst serializeRule = (rule: Rule): string => {\n    return `${rule.from} => ${rule.to.join(\"\")}`;\n};\n\nconst parseRules = (lines: string[]): Rule[] => {\n    return lines.map((line) => {\n        const [from, to] = line.split(\" => \");\n        return { from, to: parseMolecule(to), flatTo: to };\n    });\n};\n\nconst parseMolecule = (line: string): string[] => {\n    const current: string[] = [];\n    const result: string[] = [];\n    for (const c of line) {\n        if (c.toUpperCase() === c) {\n            if (current.length > 0) {\n                result.push(current.join(\"\"));\n                current.length = 0;\n            }\n        }\n        current.push(c);\n    }\n    if (current.length > 0) {\n        result.push(current.join(\"\"));\n    }\n    return result;\n};\n\nconst parseLines = (lines: string[]): { rules: Rule[], molecule: string[] } => {\n    const separator = lines.findIndex((e) => e.length === 0);\n    const rules = parseRules(lines.slice(0, separator));\n    const molecule = parseMolecule(lines[separator + 1]);\n    return {\n        rules,\n        molecule\n    };\n};\n\nexport const medicineForRudolph = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const parsed = parseLines(lines);\n        const visited = new Set<string>();\n        for (const candidate of createCandidates(parsed.rules, parsed.molecule)) {\n            visited.add(candidate.join(\"\"));\n        }\n        if (visited.size < 20) {\n            await outputCallback(visited.values());\n        }\n        await outputCallback(visited.size);\n    },\n    async ({ lines, outputCallback }) => {\n        const parsed = parseLines(lines);\n\n        const appearsInHowManyRules = new Map<string, number>();\n\n        const bottomRules: Rule[] = [];\n        const noFromAtoms: Set<string> = new Set<string>();\n\n        parsed.rules.forEach((rule) => {\n            const tos = new Set<string>();\n            rule.to.forEach((r) => tos.add(r));\n            tos.forEach((t) => {\n                if (appearsInHowManyRules.has(t)) {\n                    appearsInHowManyRules.set(t, appearsInHowManyRules.get(t)! + 1);\n                } else {\n                    appearsInHowManyRules.set(t, 1);\n                }\n            });\n\n            const noFrom = rule.to.filter((to) => parsed.rules.filter((r) => r.from === to).length === 0);\n            const isBottom = noFrom.length > 0;\n            if (isBottom) {\n                noFrom.forEach((f) => noFromAtoms.add(f));\n                bottomRules.push(rule);\n            }\n        });\n        const unique = [...appearsInHowManyRules.keys()].filter((key) => appearsInHowManyRules.get(key)! === 1);\n        await outputCallback(\"Unique: \");\n        await outputCallback(unique);\n        await outputCallback(appearsInHowManyRules);\n        await outputCallback(bottomRules.map(serializeRule));\n        await outputCallback(noFromAtoms);\n\n        // here I started noticing a pattern for Rn, Y and Ar;\n        // unfortunately I wasn't smart enough to figure all out,\n        // but thanks to askaski for his analysis and this:\n        const target = parsed.molecule;\n\n        const result =\n            target.length\n            - target.filter((t) => t === \"Ar\" || t === \"Rn\").length\n            - 2 * target.filter((t) => t === \"Y\").length - 1;\n\n        await outputCallback(result);\n        await outputCallback(\"Thanks askalski :)\");\n        await outputCallback(\"See https://www.reddit.com/r/adventofcode/comments/3xflz8/day_19_solutions/cy4etju\");\n\n    },\n    { key: \"medicine-for-rudolph\", title: \"Medicine for Rudolph\", stars: 2 }\n);\n\nfunction* createCandidates(rules: Rule[], molecule: string[]): Iterable<string[]> {\n    for (const rule of rules) {\n        for (let i = 0; i < molecule.length; i++) {\n            if (molecule[i] === rule.from) {\n                const result = molecule.slice(0, i).concat(rule.to).concat(molecule.slice(i + 1));\n                yield result;\n            }\n        }\n    }\n}\n","import { entryForFile } from \"../../entry\";\nimport { isProbablyPrime } from \"bigint-crypto-utils\";\n\nconst findExponent = (n: number, divisor: number): number => {\n    let i = 0;\n    while (n % divisor === 0) {\n        i++;\n        n /= divisor;\n    }\n    return i;\n};\n\nconst primeFactors = async (n: number): Promise<Array<{ prime: number, exponent: number }>> => {\n    if (n === 0) {\n        throw new Error(\"Zero is out of range\");\n    }\n    const primeWithEsponents: Array<{ prime: number, exponent: number }> = [];\n    if (n % 2 === 0) {\n        const exponent = findExponent(n, 2);\n        primeWithEsponents.push({\n            prime: 2,\n            exponent\n        });\n        n /= (2 ** exponent);\n    }\n    if (await isProbablyPrime(n)) {\n        primeWithEsponents.push({\n            prime: n,\n            exponent: 1\n        });\n    } else if (n !== 1) {\n        const max = Math.floor(Math.sqrt(n));\n        for (let i = 3; i <= max; i += 2) {\n            if (n % i === 0 && await isProbablyPrime(i, 40)) {\n                const exponent = findExponent(n, i);\n                if (n % (i ** exponent) !== 0) {\n                    throw new Error(JSON.stringify({ i, exponent }));\n                }\n                if (n % (i ** (exponent + 1)) === 0) {\n                    throw new Error(JSON.stringify({ i, exponent, next: true }));\n                }\n                primeWithEsponents.push({\n                    prime: i,\n                    exponent\n                });\n            }\n        }\n    }\n    return primeWithEsponents;\n};\n\nconst divisorSum = async (n: number): Promise<number> => {\n    const factors = await primeFactors(n);\n    return factors\n        .reduce((acc, next) => acc * geometric(next.prime, next.exponent), 1);\n};\n\nconst geometric = (r: number, exponent: number): number => {\n    return (r ** (exponent + 1) - 1) / (r - 1);\n};\n\nexport const infiniteElvesAndInfiniteHouses = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const target = parseInt(lines[0], 10);\n        const flatData: number[] = new Array(Math.ceil(target / 10)).fill(0);\n        for (let i = 1; i < flatData.length; i++) {\n            if (i % 10000 === 0) {\n                await outputCallback(null);\n                await outputCallback(`${i * 100 / flatData.length}%`);\n            }\n            for (let j = 1; j <= flatData.length / i; j++) {\n                flatData[i * j - 1] += i * 10;\n            }\n        }\n        for (let i = 0; i < flatData.length; i++) {\n            if (flatData[i] >= target) {\n                await outputCallback(\"House \" + (i + 1));\n                return;\n            }\n        }\n    },\n    async ({ lines, outputCallback }) => {\n        const target = parseInt(lines[0], 10);\n        const flatData: number[] = new Array(Math.ceil(target)).fill(0);\n        for (let i = 1; i < flatData.length; i++) {\n            if (i % 10000 === 0) {\n                await outputCallback(null);\n                await outputCallback(`${i * 100 / flatData.length}%`);\n            }\n            for (let j = 1; j <= Math.min(flatData.length / i, 50); j++) {\n                flatData[i * j - 1] += i * 11;\n            }\n        }\n        for (let i = 0; i < flatData.length; i++) {\n            if (flatData[i] >= target) {\n                await outputCallback(\"House \" + (i + 1));\n                return;\n            }\n        }\n    },\n    { key: \"infinite-elves-and-infinite-houses\", title: \"Infinite Elves and Infinite Houses\", stars: 2 }\n);\n","import { entryForFile } from \"../../entry\";\nimport { subsetGenerator } from \"../../../support/sequences\";\n\ninterface Item {\n    name: string;\n    cost: number;\n    damage: number;\n    armor: number;\n}\n\ntype ShopKey = \"weapons\" | \"armor\" | \"rings\";\n\nconst shop: {\n    weapons: Item[];\n    armor: Item[];\n    rings: Item[];\n} = {\n    weapons: [\n        { name: \"Dagger\", cost: 8, damage: 4, armor: 0 },\n        { name: \"Shortsword\", cost: 10, damage: 5, armor: 0 },\n        { name: \"Warhammer\", cost: 25, damage: 6, armor: 0 },\n        { name: \"Longsword\", cost: 40, damage: 7, armor: 0 },\n        { name: \"Greataxe\", cost: 74, damage: 8, armor: 0 },\n    ],\n    armor: [\n        { name: \"Leather\", cost: 13, damage: 0, armor: 1 },\n        { name: \"Chainmail\", cost: 31, damage: 0, armor: 2 },\n        { name: \"Splintmail\", cost: 53, damage: 0, armor: 3 },\n        { name: \"Bandedmail\", cost: 75, damage: 0, armor: 4 },\n        { name: \"Platemail\", cost: 102, damage: 0, armor: 5 },\n        { name: \"None\", cost: 0, damage: 0, armor: 0 }\n    ],\n    rings: [\n        { name: \"Damage +1\", cost: 25, damage: 1, armor: 0 },\n        { name: \"Damage +2\", cost: 50, damage: 2, armor: 0 },\n        { name: \"Damage +3\", cost: 100, damage: 3, armor: 0 },\n        { name: \"Defense +1\", cost: 20, damage: 0, armor: 1 },\n        { name: \"Defense +2\", cost: 40, damage: 0, armor: 2 },\n        { name: \"Defense +3\", cost: 80, damage: 0, armor: 3 },\n    ]\n};\n\ninterface State {\n    hitPoints: number;\n    damage: number;\n    armor: number;\n}\n\nconst parseState = (lines: string[]): State => {\n    const [hitPoints, damage, armor] = lines.map((l) => parseInt(l.split(\": \")[1], 10));\n    return {\n        hitPoints,\n        damage,\n        armor\n    };\n};\n\nconst fight = (player: State, monster: State): boolean => {\n    const fPlayer = { ...player };\n    const fMonster = { ...monster };\n    while (true) {\n        fMonster.hitPoints -= Math.max(1, fPlayer.damage - fMonster.armor);\n        if (fMonster.hitPoints <= 0) {\n            return true;\n        }\n        fPlayer.hitPoints -= Math.max(1, fMonster.damage - fPlayer.armor);\n        if (fPlayer.hitPoints <= 0) {\n            return false;\n        }\n    }\n};\n\nexport const rpgSimulator20xx = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const bossState = parseState(lines);\n        let minExpense = Number.POSITIVE_INFINITY;\n        for (const weapon of shop.weapons) {\n            for (const armor of shop.armor) {\n                for (const chosenRings of subsetGenerator(shop.rings, 0)) {\n                    if (chosenRings.length <= 2) {\n                        const expense =\n                            weapon.cost\n                            + armor.cost\n                            + chosenRings.reduce((acc, next) => acc + next.cost, 0);\n                        if (expense < minExpense) {\n                            const hasWon = fight({\n                                hitPoints: 100,\n                                armor: armor.armor + chosenRings.reduce((acc, next) => acc + next.armor, 0),\n                                damage: weapon.damage + chosenRings.reduce((acc, next) => acc + next.damage, 0)\n                            }, bossState);\n                            if (hasWon) {\n                                minExpense = expense;\n                            }\n                        }\n                    }\n                }\n            }\n\n        }\n        await outputCallback(minExpense);\n    },\n    async ({ lines, outputCallback }) => {\n        const bossState = parseState(lines);\n        let maxExpense = Number.NEGATIVE_INFINITY;\n        for (const weapon of shop.weapons) {\n            for (const armor of shop.armor) {\n                for (const chosenRings of subsetGenerator(shop.rings, 0)) {\n                    if (chosenRings.length <= 2) {\n                        const expense =\n                            weapon.cost\n                            + armor.cost\n                            + chosenRings.reduce((acc, next) => acc + next.cost, 0);\n                        if (expense > maxExpense) {\n                            const hasWon = fight({\n                                hitPoints: 100,\n                                armor: armor.armor + chosenRings.reduce((acc, next) => acc + next.armor, 0),\n                                damage: weapon.damage + chosenRings.reduce((acc, next) => acc + next.damage, 0)\n                            }, bossState);\n                            if (!hasWon) {\n                                maxExpense = expense;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        await outputCallback(maxExpense);\n    },\n    { key: \"rpg-simulator-20xx\", title: \"RPG Simulator 20XX\", stars: 2 }\n);\n","interface QueueNode<T> { element: T; next?: QueueNode<T>; }\n\nexport class Lifo<T> {\n  private _elements: T[] = [];\n\n  public add(element: T) {\n    this._elements.push(element);\n  }\n\n  public get(): T | undefined {\n    return this._elements.pop();\n  }\n\n  public get isEmpty(): boolean {\n    return this._elements.length === 0;\n  }\n\n  public get size(): number {\n    return this._elements.length;\n  }\n}\n\nexport class LinkedList<T> implements Iterable<{element: T, remove: () => void}> {\n  // private currentNode?: DoubleLinkedNode<T>;\n  private startNode?: DoubleLinkedNode<T>;\n\n  public addNode(element: T) {\n    if (!this.startNode) {\n      this.startNode = new DoubleLinkedNode<T>(element);\n    } else {\n      this.startNode.append(element);\n    }\n  }\n\n  public get length() {\n    let l = 0;\n    let n = this.startNode || null;\n    while (n) {\n      l++;\n      n = n.next;\n    }\n    return l;\n  }\n\n  public *[Symbol.iterator](): Iterator<{element: T, remove: () => void}> {\n    let current = this.startNode;\n    const remove = () => {\n      if (!current) {\n        return;\n      }\n      if (current.prev) {\n          current.prev.removeNext();\n        } else {\n          if (current.next) {\n            current.next.removePrev();\n            this.startNode = current.next;\n          } else {\n            this.startNode = undefined;\n          }\n        }\n    };\n    while (true) {\n      if (!current) {\n        return;\n      }\n      const c = current;\n      yield {element: c.value, remove};\n      current = current.next || undefined;\n    }\n  }\n\n}\n\nexport class Queue<T> {\n  private firstNode?: QueueNode<T>;\n  private lastNode?: QueueNode<T>;\n  private _size: number = 0;\n\n  public get isEmpty(): boolean {\n    return this.firstNode === undefined;\n  }\n\n  public forEach(callback: (e: T) => undefined | boolean): void {\n    if (this.isEmpty) {\n      return;\n    }\n    let node = this.firstNode;\n    while (node) {\n      const res = callback(node.element);\n      if (res) {\n        return;\n      }\n      node = node.next;\n    }\n  }\n\n  public add(element: T) {\n    if (this.isEmpty) {\n      this.firstNode = {\n        element,\n      };\n      this.lastNode = this.firstNode;\n    } else {\n      this.lastNode!.next = {\n        element,\n      };\n      this.lastNode = this.lastNode!.next;\n    }\n    this._size++;\n  }\n\n  public prepend(element: T) {\n    if (this.isEmpty) {\n      this.add(element);\n    } else {\n      const newFirst = {\n        element,\n        next: this.firstNode!\n      };\n      this.firstNode = newFirst;\n      this._size++;\n    }\n  }\n\n  public get(): T | null {\n    if (this.isEmpty) {\n      return null;\n    } else {\n      this._size--;\n      const toReturn = this.firstNode;\n      this.firstNode = this.firstNode!.next;\n      return toReturn!.element;\n    }\n  }\n\n  public get size(): number {\n    return this._size;\n  }\n}\n\nexport class Counter {\n  private _data: {[key: string]: number} = {};\n\n  public incr(key: string) {\n    if (!this._data[key]) {\n      this._data[key] = 0;\n    }\n    this._data[key]++;\n  }\n  public get keys(): string[] {\n    return Object.keys(this._data);\n  }\n  public get(key: string): number {\n    return this._data[key] || 0;\n  }\n}\n\nexport class DefaultListDictionaryString<T> {\n  private dictionary: { [key: string]: T[] } = {};\n\n  public add(key: string, value: T) {\n    this.ensureKey(key);\n    this.dictionary[key].push(value);\n  }\n  public get(key: string): T[] {\n    this.ensureKey(key);\n    return this.dictionary[key];\n  }\n  public remove(key: string) {\n    delete this.dictionary[key];\n  }\n  private ensureKey(key: string) {\n    if (this.dictionary[key] === undefined) {\n      this.dictionary[key] = [];\n    }\n  }\n}\n\nexport class DoubleLinkedNode<T> {\n  public next: DoubleLinkedNode<T> | null = null;\n  public prev: DoubleLinkedNode<T> | null = null;\n  constructor(public value: T) {\n  }\n\n  public visitToRight(maxLength: number | null = null): T[] {\n    let e: DoubleLinkedNode<T> | null = this;\n    const res = [];\n    while (e !== null && (maxLength === null || maxLength-- > 0)) {\n      res.push(e.value);\n      e = e.next;\n    }\n    return res;\n  }\n\n  public append(item: T): DoubleLinkedNode<T> {\n    const oldNext = this.next;\n    const newNext = new DoubleLinkedNode(item);\n    newNext.prev = this;\n    this.next = newNext;\n    if (oldNext !== null) {\n      newNext.next = oldNext;\n      oldNext.prev = newNext;\n    }\n    return newNext;\n  }\n\n  public prepend(item: T): DoubleLinkedNode<T> {\n    const oldPrev = this.prev;\n    const newPrev = new DoubleLinkedNode(item);\n    newPrev.next = this;\n    this.prev = newPrev;\n    if (oldPrev !== null) {\n      oldPrev.next = newPrev;\n      newPrev.prev = oldPrev;\n    }\n    return newPrev;\n  }\n\n  public removePrev(): T | null {\n    if (this.prev === null) {\n      return null;\n    } else {\n      const value = this.prev.value;\n      this.prev = this.prev.prev;\n      if (this.prev !== null) {\n        this.prev.next = this;\n      }\n      return value;\n    }\n  }\n\n  public removeNext(): T | null {\n    if (this.next === null) {\n      return null;\n    } else {\n      const value = this.next.value;\n      this.next = this.next.next;\n      if (this.next !== null) {\n        this.next.prev = this;\n      }\n      return value;\n    }\n\n  }\n}\n\nexport class Tree<T> {\n  private subNodes: Array<Tree<T>> = [];\n  constructor(private element: T) { }\n\n  public get children(): Array<Tree<T>> {\n    return [...this.subNodes];\n  }\n\n  public get head() {\n    return this.element;\n  }\n\n  public append(e: T, to: T) {\n    if (this.element === to) {\n      this.subNodes.push(new Tree<T>(e));\n    }\n  }\n\n  public appendTree(e: Tree<T>) {\n    this.subNodes.push(e);\n  }\n}\n\nexport class CircularDoubleLinkedNode<T> {\n  // tslint:disable-next-line:variable-name\n  private _next: CircularDoubleLinkedNode<T> | null = null;\n  // tslint:disable-next-line:variable-name\n  private _prev: CircularDoubleLinkedNode<T> | null = null;\n  constructor(public value: T) {\n\n  }\n  public append(item: T): CircularDoubleLinkedNode<T> {\n    const newNext = new CircularDoubleLinkedNode<T>(item);\n    if (this._next === null) {\n      newNext._next = this;\n      newNext._prev = this;\n      this._next = newNext;\n      this._prev = newNext;\n    } else {\n      newNext._next = this._next;\n      newNext._next!._prev = newNext;\n      this._next = newNext;\n      newNext._prev = this;\n    }\n    return newNext;\n  }\n\n  public removePrevious(): T {\n    if (this._prev === null) {\n      throw Error(\"Cannot remove non existing element\");\n    } else {\n      const toRemove = this._prev;\n      this._prev = this._prev!._prev;\n      if (this._prev === this) {\n        this._prev = null;\n        this._next = null;\n      } else {\n        this._prev!._next = this;\n      }\n      toRemove!._prev = null;\n      toRemove!._next = null;\n      return toRemove!.value;\n    }\n  }\n\n  public removeNext(): T {\n    return this.next.next.removePrevious();\n  }\n\n  public getAllElements(): T[] {\n    const values: T[] = [this.value];\n    let current = this.next;\n    while (current && current !== this) {\n      values.push(current.value);\n      current = current.next;\n    }\n    return values;\n  }\n\n  public get prev(): CircularDoubleLinkedNode<T> {\n    if (this._prev === null) {\n      return this;\n    } else {\n      return this._prev;\n    }\n  }\n\n  public get next(): CircularDoubleLinkedNode<T> {\n    if (this._next === null) {\n      return this;\n    } else {\n      return this._next;\n    }\n  }\n\n  public prepend(item: T): CircularDoubleLinkedNode<T> {\n    return this.prev.append(item);\n  }\n}\n","import { entryForFile } from \"../../entry\";\nimport { Queue } from \"../../../support/data-structure\";\nimport { PriorityQueue } from \"priorityqueue/lib/cjs/PriorityQueue\";\nimport { PairingHeap } from \"priorityqueue/lib/cjs\";\n\ninterface State {\n    hitPoints: number;\n    damage: number;\n}\n\ninterface Timers {\n    shield: number;\n    poison: number;\n    recharge: number;\n}\n\ntype PlayerState = State & Timers & { mana: number, spentMana: number };\n\ntype Spell = \"missile\" | \"drain\" | \"shield\" | \"poison\" | \"recharge\";\n\ninterface GameState {\n    playerState: PlayerState;\n    bossState: State;\n}\n\nconst spellCost = (spell: Spell): number => {\n    switch (spell) {\n        case \"drain\":\n            return 73;\n        case \"missile\":\n            return 53;\n        case \"poison\":\n            return 173;\n        case \"recharge\":\n            return 229;\n        case \"shield\":\n            return 113;\n    }\n};\n\nconst paySpell = (spell: Spell, state: PlayerState): PlayerState => {\n    const cost = spellCost(spell);\n    return {\n        ...state,\n        mana: state.mana - cost,\n        spentMana: state.spentMana + cost\n    };\n};\n\nconst launchSpell = (spell: Spell, { playerState, bossState }: GameState): GameState => {\n    playerState = paySpell(spell, playerState);\n    switch (spell) {\n        case \"drain\":\n            return {\n                playerState: {\n                    ...playerState,\n                    hitPoints: playerState.hitPoints + 2\n                },\n                bossState: {\n                    ...bossState,\n                    hitPoints: bossState.hitPoints - 2\n                }\n            };\n        case \"missile\":\n            return {\n                playerState,\n                bossState: {\n                    ...bossState,\n                    hitPoints: bossState.hitPoints - 4\n                }\n            };\n        case \"poison\":\n            return {\n                playerState: {\n                    ...playerState,\n                    poison: 6\n                },\n                bossState\n            };\n        case \"recharge\":\n            return {\n                playerState: {\n                    ...playerState,\n                    recharge: 5\n                },\n                bossState\n            };\n        case \"shield\":\n            return {\n                playerState: {\n                    ...playerState,\n                    shield: 6\n                },\n                bossState\n            };\n    }\n};\n\nconst parseState = (lines: string[]): State => {\n    const [hitPoints, damage] = lines.map((l) => parseInt(l.split(\": \")[1], 10));\n    return { hitPoints, damage };\n};\n\nconst applyEffects = ({ playerState, bossState }: GameState): GameState => {\n    const newPlayerState = { ...playerState };\n    const newBossState = { ...bossState };\n    if (newPlayerState.poison > 0) {\n        newPlayerState.poison--;\n        newBossState.hitPoints -= 3;\n    }\n    if (newPlayerState.shield > 0) {\n        newPlayerState.shield--;\n    }\n    if (newPlayerState.recharge > 0) {\n        newPlayerState.mana += 101;\n        newPlayerState.recharge--;\n    }\n    return { playerState: newPlayerState, bossState: newBossState };\n};\n\nconst bossDamageTurn = ({ playerState, bossState }: GameState): GameState => {\n    const damage = Math.max(bossState.damage - (playerState.shield > 0 ? 7 : 0), 1);\n    return hurtPlayer({ playerState, bossState }, damage);\n    // return {\n    //     playerState: {\n    //         ...playerState,\n    //         hitPoints: playerState.hitPoints - damage\n    //     },\n    //     bossState\n    // };\n};\n\nconst hurtPlayer = ({ playerState, bossState }: GameState, damage: number): GameState => {\n    return {\n        playerState: {\n            ...playerState,\n            hitPoints: playerState.hitPoints - damage\n        },\n        bossState\n    };\n};\n\nconst spells: Spell[] = [\n    \"drain\",\n    \"missile\",\n    \"poison\",\n    \"recharge\",\n    \"shield\"\n];\n\nconst canLaunchSpell = (state: GameState, spell: Spell): boolean => {\n    if (spellCost(spell) > state.playerState.mana) {\n        return false;\n    }\n    switch (spell) {\n        case \"missile\":\n        case \"drain\":\n            return true;\n        case \"poison\":\n            return state.playerState.poison === 0;\n        case \"recharge\":\n            return state.playerState.recharge === 0;\n        case \"shield\":\n            return state.playerState.shield === 0;\n    }\n};\n\ntype TurnResult = {\n    hasWon: true,\n    state: GameState\n} | {\n    hasWon: false,\n    hasLost: true,\n    state: GameState\n} | {\n    hasWon: false,\n    hasLost: false,\n    state: GameState\n};\n\nconst playTurn = (spell: Spell, state: GameState, playerHpLoss: number = 0): TurnResult => {\n    const current = state;\n    const afterStart = playerHpLoss === 0 ? current : hurtPlayer(current, playerHpLoss);\n    if (afterStart.playerState.hitPoints <= 0) {\n        return { hasWon: false, hasLost: true, state: afterStart };\n    }\n    const afterEffects = applyEffects(afterStart);\n    if (afterEffects.bossState.hitPoints <= 0) {\n        return { hasWon: true, state: afterEffects };\n    }\n    if (!canLaunchSpell(afterEffects, spell)) {\n        return { hasWon: false, hasLost: true, state: afterEffects };\n    }\n    const afterSpell = launchSpell(spell, afterEffects);\n    if (afterSpell.playerState.mana < 0) {\n        return { hasWon: false, hasLost: true, state: afterSpell };\n    }\n    if (afterSpell.bossState.hitPoints <= 0) {\n        return { hasWon: true, state: afterSpell };\n    }\n    const afterSecondEffects = applyEffects(afterSpell);\n    if (afterSecondEffects.bossState.hitPoints <= 0) {\n        return { hasWon: true, state: afterSecondEffects };\n    }\n    const afterBoss = bossDamageTurn(afterSecondEffects);\n    if (afterBoss.playerState.hitPoints <= 0) {\n        return { hasWon: false, hasLost: true, state: afterBoss };\n    }\n    return { hasWon: false, hasLost: false, state: afterBoss };\n};\n\nconst bfsPruned = (startGameState: GameState, hardMode: boolean): GameState | null => {\n    const states = new Queue<GameState>();\n    states.add(startGameState);\n    let bestWinState: GameState | null = null;\n    const updateBestState = (state: GameState) => {\n        if (bestWinState === null || bestWinState.playerState.spentMana > state.playerState.spentMana) {\n            bestWinState = state;\n        }\n    };\n    while (!states.isEmpty) {\n        const current = states.get()!;\n        if (bestWinState !== null) {\n            const cast = bestWinState as GameState;\n            if (cast.playerState.spentMana < current.playerState.spentMana) {\n                continue;\n            }\n        }\n        spells.forEach((spell) => {\n            const result = playTurn(spell, current, hardMode ? 1 : 0);\n            if (result.hasWon) {\n                updateBestState(result.state);\n            } else if (result.hasLost) {\n                return;\n            } else {\n                states.add(result.state);\n            }\n            // const afterEffects = applyEffects(current);\n            // if (afterEffects.bossState.hitPoints <= 0) {\n            //     updateBestState(afterEffects);\n            // }\n            // if (!canLaunchSpell(afterEffects, spell)) {\n            //     return;\n            // }\n            // const afterSpell = launchSpell(spell, afterEffects);\n            // if (afterSpell.playerState.mana < 0) {\n            //     return;\n            // }\n            // if (afterSpell.bossState.hitPoints <= 0) {\n            //     updateBestState(afterSpell);\n            // }\n            // const afterSecondEffects = applyEffects(afterSpell);\n            // if (afterSecondEffects.bossState.hitPoints <= 0) {\n            //     updateBestState(afterSecondEffects);\n            // }\n            // const afterBoss = bossDamageTurn(afterSecondEffects);\n            // if (afterBoss.playerState.hitPoints <= 0) {\n            //     return;\n            // }\n            // if (bestBossHitpoints > afterBoss.bossState.hitPoints) {\n            //     bestBossHitpoints = afterBoss.bossState.hitPoints;\n            //     console.log(bestBossHitpoints);\n            // }\n            // states.add(afterBoss);\n        });\n\n    }\n    return bestWinState;\n};\n\nconst exploreFight = (startGameState: GameState): GameState | null => {\n    // const queue = new WizardPriorityQueue();\n    const queue = new PairingHeap<{ spell: Spell; gameState: GameState }>({\n        comparator:\n            (a, b) =>\n                spellCost(b.spell) + b.gameState.playerState.spentMana -\n                (spellCost(a.spell) + a.gameState.playerState.spentMana)\n    });\n    spells.forEach((spell) => {\n        queue.push({ spell, gameState: startGameState });\n    });\n    while (!queue.isEmpty()) {\n        const round = queue.pop();\n        const afterEffects = applyEffects(round.gameState);\n        if (afterEffects.bossState.hitPoints <= 0) {\n            return afterEffects;\n        }\n        const afterSpell = launchSpell(round.spell, afterEffects);\n        if (afterSpell.playerState.mana < 0) {\n            continue;\n        }\n        if (afterSpell.bossState.hitPoints <= 0) {\n            return afterSpell;\n        }\n        const afterSecondEffects = applyEffects(afterSpell);\n        if (afterSecondEffects.bossState.hitPoints <= 0) {\n            return afterSecondEffects;\n        }\n        const afterBoss = bossDamageTurn(afterSecondEffects);\n        if (afterBoss.playerState.hitPoints <= 0) {\n            continue;\n        }\n        const spellCandidates: Spell[] = [\n            \"missile\",\n            \"drain\"\n        ];\n        if (afterBoss.playerState.recharge === 0) {\n            spellCandidates.push(\"recharge\");\n        }\n        if (afterBoss.playerState.shield === 0) {\n            spellCandidates.push(\"shield\");\n        }\n        if (afterBoss.playerState.poison === 0) {\n            spellCandidates.push(\"poison\");\n        }\n        spellCandidates.forEach((spell) => {\n            queue.push({ spell, gameState: afterBoss });\n        });\n    }\n    return null;\n};\n\nconst initGameState = (lines: string[]): GameState => {\n    const bossState = parseState(lines);\n    const playerState: PlayerState = {\n        hitPoints: 50,\n        mana: 500,\n        damage: 0,\n        poison: 0,\n        recharge: 0,\n        shield: 0,\n        spentMana: 0\n    };\n    return { bossState, playerState };\n\n};\n\nexport const wizardSimulator20xx = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const gameState = initGameState(lines);\n        const winner = bfsPruned(gameState, false);\n        if (winner === null) {\n            await outputCallback(\"No winner state found\");\n        } else {\n            await outputCallback(winner);\n        }\n    },\n    async ({ lines, outputCallback }) => {\n        const gameState = initGameState(lines);\n        const winner = bfsPruned(gameState, true);\n        if (winner === null) {\n            await outputCallback(\"No winner state found\");\n        } else {\n            await outputCallback(winner);\n        }\n    },\n    { key: \"wizard-simulator-20xx\", title: \"Wizard Simulator 20XX\", stars: 2 }\n);\n","export class TimeCalculator {\r\n    private startTime: number | null = null;\r\n    public start(): void {\r\n        this.startTime = new Date().getTime();\r\n    }\r\n    public getDelta(): number {\r\n        if (this.startTime === null) {\r\n            throw new Error(\"Not started\");\r\n        }\r\n        return new Date().getTime() - this.startTime;\r\n    }\r\n    public getExpected(ratio: number): number {\r\n        if (ratio <= 0 || ratio > 1) {\r\n            throw new Error(\"Cannot calculate with ratio out of bounds\");\r\n        }\r\n        if (ratio === 1) {\r\n            return 0;\r\n        }\r\n        const delta = this.getDelta();\r\n        return (delta / ratio) - delta;\r\n    }\r\n\r\n    public getExpectedSerialized(ratio: number): string {\r\n        return serializeTime(this.getExpected(ratio));\r\n    }\r\n}\r\n\r\nexport const serializeTime = (ms: number): string => {\r\n    let seconds = Math.ceil(ms / 1000);\r\n    let minutes = 0;\r\n    let hours = 0;\r\n    let days = 0;\r\n    if (seconds > 0) {\r\n        minutes = Math.floor(seconds / 60);\r\n        seconds = seconds % 60;\r\n    }\r\n    if (minutes > 60) {\r\n        hours = Math.floor(minutes / 60);\r\n        minutes = minutes % 60;\r\n    }\r\n    if (hours > 24) {\r\n        days = Math.floor(hours / 24);\r\n        hours = hours % 24;\r\n    }\r\n    let result = [hours, minutes, seconds].map((e) => e.toString().padStart(2, \"0\")).join(\":\");\r\n    if (days > 0) {\r\n        result = `${days}d ${result}`;\r\n    }\r\n    return result;\r\n\r\n};\r\n","import { TimeCalculator } from \"../../../support/time\";\nimport { subsetGenerator } from \"../../../support/sequences\";\nimport { entryForFile } from \"../../entry\";\n\nconst parseLines = (lines: string[]): number[] => {\n    return lines.map((line) => parseInt(line, 10));\n};\n\nexport const itHangsInTheBalance = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const packages = parseLines(lines);\n        const totalWeight = packages.reduce((a, b) => a + b);\n\n        const target = totalWeight / 3;\n\n        let subsets = 0;\n        const expectedTotal = 2 ** packages.length;\n        const interestingSubsets: number[][] = [];\n        const timeCalculator = new TimeCalculator();\n        timeCalculator.start();\n        for (let size = 1; size < packages.length - 2; size++) {\n            for (const s of subsetGenerator(packages, 0, size)) {\n                if (s.length > 0 && s.reduce((a, b) => a + b, 0) === target) {\n                    interestingSubsets.push(s);\n                }\n                subsets++;\n                if (subsets % 10000000 === 0) {\n                    await outputCallback(\"Remaining \" + timeCalculator.getExpectedSerialized(subsets / expectedTotal));\n                }\n            }\n\n            const sorted = interestingSubsets\n                .map((e) => ({ e, i: e.reduce((a, b) => a * b, 1) }))\n                .sort((a, b) => a.i - b.i)\n                .map((e) => e.e);\n\n            for (const candidate of sorted) {\n                const rest = packages.filter((e) => candidate.indexOf(e) < 0);\n                for (const s of subsetGenerator(rest, 0)) {\n                    if (s.reduce((a, b) => a + b, 0) === target) {\n                        await outputCallback(\"Found it! \" + (candidate.reduce((a, b) => a * b, 1)));\n                        return;\n                    }\n                }\n            }\n        }\n        await outputCallback(\"Sad :(\");\n\n    },\n    async ({ lines, outputCallback }) => {\n        const packages = parseLines(lines);\n        const totalWeight = packages.reduce((a, b) => a + b);\n\n        const target = totalWeight / 4;\n\n        let subsets = 0;\n        const expectedTotal = 2 ** packages.length;\n        const interestingSubsets: number[][] = [];\n        const timeCalculator = new TimeCalculator();\n        timeCalculator.start();\n        for (let size = 1; size < packages.length - 2; size++) {\n            for (const s of subsetGenerator(packages, 0, size)) {\n                if (s.length > 0 && s.reduce((a, b) => a + b, 0) === target) {\n                    interestingSubsets.push(s);\n                }\n                subsets++;\n                if (subsets % 10000000 === 0) {\n                    await outputCallback(\"Remaining \" + timeCalculator.getExpectedSerialized(subsets / expectedTotal));\n                }\n            }\n\n            const sorted = interestingSubsets\n                .map((e) => ({ e, i: e.reduce((a, b) => a * b, 1) }))\n                .sort((a, b) => a.i - b.i)\n                .map((e) => e.e);\n\n            for (const candidate of sorted) {\n                const rest = packages.filter((e) => candidate.indexOf(e) < 0);\n                for (const s of subsetGenerator(rest, 0)) {\n                    if (s.reduce((a, b) => a + b, 0) === target) {\n                        const trunkCandidates = rest.filter((e) => s.indexOf(e) < 0);\n                        for (const t of subsetGenerator(trunkCandidates, 0)) {\n                            if (t.reduce((a, b) => a + b, 0) === target) {\n                                await outputCallback(\"Found it! \" + (candidate.reduce((a, b) => a * b, 1)));\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        await outputCallback(\"Sad :(\");\n    },\n    { key: \"it-hangs-in-the-balance\", title: \"It Hangs in the Balance\", stars: 2 }\n);\n","import * as bigintCryptoUtils from \"bigint-crypto-utils\";\r\n\r\nexport const modInverse = (n: bigint, mod: bigint): bigint => {\r\n    return bigintCryptoUtils.modInv(n, mod);\r\n    // const {a, b} = calculateExtended(n, mod, 1);\r\n    // return a > 0 ? a : a + mod;\r\n};\r\n\r\nexport const pow = (n: bigint, exp: bigint, mod: bigint): bigint => {\r\n    return bigintCryptoUtils.modPow(n, exp, mod);\r\n};\r\n\r\nexport const factorial = (n: number): number => {\r\n    let res = n;\r\n    while (n-- > 1) {\r\n        res *= n;\r\n    }\r\n    return res;\r\n};\r\n\r\nexport const logarithm = (base: number, target: number): number => {\r\n  return Math.log(base) / Math.log(target);\r\n};\r\n\r\nexport const calculateExtended = (aP: number, bP: number, m: number): {\r\n    a: number,\r\n    b: number\r\n} => {\r\n    let a = {\r\n        n: aP,\r\n        a: 1,\r\n        b: 0\r\n    };\r\n    let b = {\r\n        n: bP,\r\n        a: 0,\r\n        b: 1\r\n    };\r\n\r\n    while (!(m % b.n === 0)) {\r\n        const f = Math.floor(a.n / b.n);\r\n        const q = {\r\n            n: a.n % b.n,\r\n            a: a.a - (f * b.a),\r\n            b: a.b - (f * b.b)\r\n        };\r\n        a = b;\r\n        b = q;\r\n    }\r\n\r\n    const factor = m / b.n;\r\n    const result = {\r\n        a: b.a * factor,\r\n        b: b.b * factor\r\n    };\r\n    if (result.a * aP + result.b * bP !== m) {\r\n        throw new Error(\"Inversion did not work: \" + JSON.stringify({...result, factor}));\r\n    }\r\n    return result;\r\n};\r\n\r\ninterface ExtendedEuclidFactor {\r\n    n: number;\r\n    a: number;\r\n    b: number;\r\n}\r\n\r\n\r\nexport function gcd(a: number, b: number): number {\r\n  let t = 0;\r\n  if (a < b) {\r\n      t = b;\r\n      b = a;\r\n      a = t;\r\n  }\r\n//   a < b && (t = b, b = a, a = t); // swap them if a < b\r\n  t = a % b;\r\n  return t ? gcd(b, t) : b;\r\n}\r\n\r\nexport function lcm(a: number, b: number) {\r\n  return a / gcd(a, b) * b;\r\n}\r\n","import { pow } from \"../../../support/algebra\";\nimport { entryForFile } from \"../../entry\";\n\nconst fromRowColumn = (row: number, column: number) => {\n    const start = 1;\n    const firstOfRow = (row - 1) * row / 2 + 1;\n    const increments = column - 1;\n    const rightDelta = (increments + row) * (increments + row + 1) / 2 - (row * (row + 1) / 2);\n    return firstOfRow + rightDelta;\n};\n\nconst parseLines = (lines: string[]): { row: number, column: number } => {\n    const words = lines[0].split(\" \");\n    const rowIndex = words.indexOf(\"row\") + 1;\n    const columnIndex = words.indexOf(\"column\") + 1;\n    return {\n        row: parseInt(words[rowIndex].slice(0, -1), 10),\n        column: parseInt(words[columnIndex].slice(0, -1), 10)\n    };\n};\n\nexport const letItSnow = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const coordinates = parseLines(lines);\n        const start = 20151125;\n        const base = 252533;\n        const mod = 33554393;\n        const index = fromRowColumn(coordinates.row, coordinates.column);\n        const factor = pow(BigInt(base), BigInt(index - 1), BigInt(mod));\n        const result = (BigInt(start) * factor) % BigInt(mod);\n        await outputCallback(result);\n    },\n    async ({ lines, outputCallback }) => {\n        throw Error(\"Not implemented\");\n    },\n    { key: \"let-it-snow\", title: \"Let It Snow\", stars: 2 }\n);\n","import { notQuiteLisp } from \"./not-quite-lisp\";\nimport { iWasToldThereWouldBeNoMath } from \"./i-was-told-there-would-be-no-math\";\nimport { perfectSphericalHousesInAVacuum } from \"./perfect-spherical-houses-in-a-vacuum\";\nimport { theIdealStockingStuffer } from \"./the-ideal-stocking-stuffer\";\nimport { internElves } from \"./intern-elves\";\nimport { probablyAFireHazard } from \"./probably-a-fire-hazard\";\nimport { someAssemblyRequired } from \"./some-assembly-required\";\nimport { matchsticks } from \"./matchsticks\";\nimport { allInASingleNight } from \"./all-in-a-single-night\";\nimport { elvesLookElvesSay } from \"./elves-look-elves-say\";\nimport { corporatePolicy } from \"./corporate-policy\";\nimport { abacusFramework } from \"./abacus-framework\";\nimport { knightsOfTheDinnerTable } from \"./knights-of-the-dinner-table\";\nimport { reindeerOlympics } from \"./reindeer-olympics\";\nimport { scienceForHungryPeople } from \"./science-for-hungry-people\";\nimport { auntSue } from \"./aunt-sue\";\nimport { noSuchThingAsTooMuch } from \"./no-such-thing-as-too-much\";\nimport { likeAGifForYourYard } from \"./like-a-gif-for-your-yard\";\nimport { turingLock } from \"./turing-lock\";\nimport { medicineForRudolph } from \"./medicine-for-rudolph\";\nimport { infiniteElvesAndInfiniteHouses } from \"./infinite-elves-and-infinite-houses\";\nimport { rpgSimulator20xx } from \"./rpg-simulator-20xx\";\nimport { wizardSimulator20xx } from \"./wizard-simulator-20xx\";\nimport { itHangsInTheBalance } from \"./it-hangs-in-the-balance\";\nimport { letItSnow } from \"./let-it-snow\";\n\nexport const entries = [\n        notQuiteLisp,\n        iWasToldThereWouldBeNoMath,\n        perfectSphericalHousesInAVacuum,\n        theIdealStockingStuffer,\n        internElves,\n        probablyAFireHazard,\n        someAssemblyRequired,\n        matchsticks,\n        allInASingleNight,\n        elvesLookElvesSay,\n        corporatePolicy,\n        abacusFramework,\n        knightsOfTheDinnerTable,\n        reindeerOlympics,\n        scienceForHungryPeople,\n        auntSue,\n        noSuchThingAsTooMuch,\n        likeAGifForYourYard,\n        medicineForRudolph,\n        infiniteElvesAndInfiniteHouses,\n        rpgSimulator20xx,\n        wizardSimulator20xx,\n        turingLock,\n        itHangsInTheBalance,\n        letItSnow\n];\n","import { CCoordinate, directions, manhattanDistance, rotate } from \"../../../support/geometry\";\nimport { entryForFile } from \"../../entry\";\n\nexport const noTimeForATaxicab = entryForFile(\n    async ({ lines, outputCallback }) => {\n        let currentDirection = directions.up;\n        const input = lines[0].split(\", \").map((l) => ({\n            direction: l[0],\n            steps: parseInt(l.slice(1), 10)\n        }));\n\n        let currentCoordinates = new CCoordinate(0, 0);\n\n        input.forEach((i) => {\n            if (i.direction === \"L\") {\n                currentDirection = rotate(currentDirection, \"Counterclockwise\");\n            } else {\n                currentDirection = rotate(currentDirection, \"Clockwise\");\n            }\n            currentCoordinates = currentCoordinates.sum(currentDirection.times(i.steps));\n        });\n\n        await outputCallback(manhattanDistance(currentCoordinates, {x: 0, y: 0}));\n    },\n    async ({ lines, outputCallback }) => {\n        let currentDirection = directions.up;\n        const input = lines[0].split(\", \").map((l) => ({\n            direction: l[0],\n            steps: parseInt(l.slice(1), 10)\n        }));\n\n        let currentCoordinates = new CCoordinate(0, 0);\n\n        const visited: CCoordinate[] = [];\n\n        visited.push(currentCoordinates);\n\n        for (const i of input) {\n            if (i.direction === \"L\") {\n                currentDirection = rotate(currentDirection, \"Counterclockwise\");\n            } else {\n                currentDirection = rotate(currentDirection, \"Clockwise\");\n            }\n            for (let x = 0; x < i.steps; x++) {\n                currentCoordinates = currentCoordinates.sum(currentDirection);\n                if (visited.filter((e) => manhattanDistance(e, currentCoordinates) === 0).length > 0) {\n                    await outputCallback(\"Found it:\");\n                    await outputCallback(manhattanDistance(currentCoordinates, {x: 0, y: 0}));\n                    return;\n                }\n                visited.push(currentCoordinates);\n            }\n        }\n\n    },\n    { key: \"no-time-for-a-taxicab\", title: \"No Time for a Taxicab\", stars: 2}\n);\n","import { Bounds, CCoordinate, Coordinate, directions, isInBounds, manhattanDistance } from \"../../../support/geometry\";\nimport { entryForFile } from \"../../entry\";\n\ntype Dir = \"U\" | \"L\" | \"R\" | \"D\";\n\nconst parseLines = (lines: string[]): Dir[][] => {\n    return lines.map((line) => line.trim().split(\"\").map((e) => e as Dir));\n};\n\nconst dirMap = (d: Dir): CCoordinate => {\n    switch (d) {\n        case \"D\":\n            return directions.down;\n        case \"L\":\n            return directions.left;\n        case \"R\":\n            return directions.right;\n        case \"U\":\n            return directions.up;\n        default:\n            throw new Error(\"Unknown direction\");\n    }\n};\n\nconst coordinateToNumber = (c: Coordinate): number => {\n    return c.x + 1 + ((c.y) * 3);\n};\n\nconst coordinateToStrange = (c: Coordinate): string => {\n    const output = [\n        [\" \", \" \", \"1\"],\n        [\" \", \"2\", \"3\", \"4\"],\n        [\"5\", \"6\", \"7\", \"8\", \"9\"],\n        [\" \", \"A\", \"B\", \"C\"],\n        [\" \", \" \", \"D\"]\n    ];\n    return output[c.y][c.x];\n};\n\nexport const bathroomSecurity = entryForFile(\n    async ({ lines, outputCallback }) => {\n\n        const bounds: Bounds = {\n            topLeft: {x: 0, y: 0},\n            size: {x: 3, y: 3}\n        };\n\n        let currentPosition = {x: 1, y: 1};\n\n        const input = parseLines(lines);\n\n        const result = input.map((line) => {\n            line.forEach((instruction) => {\n                const candidate = dirMap(instruction).sum(currentPosition);\n                if (isInBounds(candidate, bounds)) {\n                    currentPosition = candidate;\n                }\n            });\n            return coordinateToNumber(currentPosition);\n        });\n\n        await outputCallback(result.join(\"\"));\n\n    },\n    async ({ lines, outputCallback }) => {\n        let currentPosition = {x: 0, y: 2};\n\n        const input = parseLines(lines);\n\n        const result = input.map((line) => {\n            line.forEach((instruction) => {\n                const candidate = dirMap(instruction).sum(currentPosition);\n                if (manhattanDistance(candidate, {x: 2, y: 2}) <= 2) {\n                    currentPosition = candidate;\n                }\n            });\n            return coordinateToStrange(currentPosition);\n        });\n\n        await outputCallback(result.join(\"\"));\n    },\n    { key: \"bathroom-security\", title: \"Bathroom Security\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\nconst parseLines = (lines: string[]): Array<[number, number, number]> => {\n    return lines.map(\n        (line) =>\n            line\n                .trim()\n                .split(\" \")\n                .filter((e) => e.length > 0)\n                .map((e) => parseInt(e, 10)) as [number, number, number]\n    );\n};\n\ntype Triple = [number, number, number];\n\nconst parseSecondLines = (lines: string[]): Array<[number, number, number]> => {\n    const input = parseLines(lines);\n    let current: number[][] = [[], [], []];\n    const result: Array<[number, number, number]> = [];\n    let started = false;\n    for (let i = 0; i < lines.length; i++) {\n        if (i % 3 === 0 && started) {\n            result.push(current[0] as Triple, current[1] as Triple, current[2] as Triple);\n            current = [[], [], []];\n        }\n        started = true;\n        for (let x = 0; x < 3; x++) {\n            current[x].push(input[i][x]);\n        }\n    }\n    result.push(current[0] as Triple, current[1] as Triple, current[2] as Triple);\n    return result;\n\n};\n\nexport const squaresWithThreeSides = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const input = parseLines(lines);\n\n        let count = 0;\n\n        for (const line of input) {\n            let isValid = true;\n            for (let i = 0; i < 3; i++) {\n                let s = 0;\n                for (let x = 0; x < 3; x++) {\n                    if (x !== i) {\n                        s += line[x];\n                    }\n                }\n                if (s <= line[i]) {\n                    isValid = false;\n                }\n            }\n            if (isValid) {\n                count++;\n            }\n        }\n\n        await outputCallback(count);\n    },\n    async ({ lines, outputCallback }) => {\n        const input = parseSecondLines(lines);\n\n        let count = 0;\n\n        for (const line of input) {\n            let isValid = true;\n            for (let i = 0; i < 3; i++) {\n                let s = 0;\n                for (let x = 0; x < 3; x++) {\n                    if (x !== i) {\n                        s += line[x];\n                    }\n                }\n                if (s <= line[i]) {\n                    isValid = false;\n                }\n            }\n            if (isValid) {\n                count++;\n            }\n        }\n\n        await outputCallback(count);\n    },\n    { key: \"squares-with-three-sides\", title: \"Squares With Three Sides\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ninterface Room {\n    encryptedName: string;\n    sectorID: number;\n    checksum: string;\n}\n\nconst parseLines = (lines: string[]): Room[] => {\n    return lines.map((line) => {\n        const dashIndex = line.lastIndexOf(\"-\");\n        const squareIndex = line.lastIndexOf(\"[\");\n        const name = line.slice(0, dashIndex);\n        const sectorID = parseInt(line.slice(dashIndex + 1, squareIndex), 10);\n        const checksum = line.slice(squareIndex + 1, -1);\n        return {\n            encryptedName: name,\n            sectorID,\n            checksum\n        };\n    });\n};\n\nconst decrypt = (room: Room): string => {\n    const mod = \"z\".charCodeAt(0) - \"a\".charCodeAt(0) + 1;\n\n    const newName = [...room.encryptedName].map((e) => {\n        if (e === \"-\") {\n            return e;\n        }\n        return String.fromCharCode(((e.charCodeAt(0) - \"a\".charCodeAt(0) + room.sectorID) % mod) + \"a\".charCodeAt(0));\n    });\n    return newName.join(\"\");\n};\n\nconst verifyChecksum = (room: Room): boolean => {\n    const frequency = new Map<string, number>();\n\n    for (const letter of room.encryptedName) {\n        if (letter !== \"-\") {\n            const value = frequency.get(letter) || 0;\n            frequency.set(letter, value + 1);\n        }\n    }\n\n    const result = [...frequency.entries()].sort((a, b) => {\n        if (b[1] === a[1]) {\n            return a[0].localeCompare(b[0]);\n        } else {\n            return b[1] - a[1];\n        }\n    });\n\n    const calculated = result.slice(0, 5).map((e) => e[0]).join(\"\") ;\n\n    return calculated === room.checksum;\n\n};\n\nexport const securityThroughObscurity = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const input = parseLines(lines);\n\n        const count = input.filter(verifyChecksum).map((e) => e.sectorID).reduce((a, b) => a + b);\n\n        await outputCallback(count);\n    },\n    async ({ lines, outputCallback }) => {\n        const input = parseLines(lines);\n\n        const res = input.map((i) => {\n            return [decrypt(i), i.sectorID] as [string, number];\n        });\n\n        const candidates = res.filter((e) => e[0].includes(\"pole\"));\n\n        await outputCallback(candidates);\n        await outputCallback(\"\");\n        await outputCallback(res);\n    },\n    { key: \"security-through-obscurity\", title: \"Security Through Obscurity\", stars: 2}\n);\n","export const randrange = (min: number, max: number): number => Math.floor(Math.random() * (max - min + 1)) + min;\n\nexport const randomCharacter = (): string => {\n    const min = \"a\".charCodeAt(0);\n    const max = \"z\".charCodeAt(0);\n    return String.fromCharCode(randrange(min, max));\n};\n","import { Md5 } from \"ts-md5\";\nimport { randomCharacter } from \"../../../support/random\";\nimport { entryForFile } from \"../../entry\";\n\nconst getCharacter = (input: string, n: number): string | null => {\n    const hash = getHashIfRelevant(input, n);\n    if (hash !== null) {\n        return hash[5].toString();\n    } else {\n        return null;\n    }\n};\n\nconst getCharacterAndPosition = (input: string, n: number): {c: string, index: number} | null => {\n    const hash = getHashIfRelevant(input, n);\n    if (hash !== null) {\n        const i = parseInt(hash[5], 10);\n        if (i.toString() === hash[5]) {\n            return {c: hash[6], index: i};\n        }\n    }\n    return null;\n};\n\n\n\nconst getHashIfRelevant = (input: string, n: number): string | null => {\n    const hash = Md5.hashAsciiStr(input + n);\n    if (hash.slice(0, 5) === \"00000\") {\n        return hash as string;\n    } else {\n        return null;\n    }\n};\n\nconst fillPasswordWithRandom = (password: Array<string|null>): string => {\n    return password.map((e) => e !== null ? e : randomCharacter()).join(\" \");\n};\n\nexport const howAboutANiceGameOfChess = entryForFile(\n    async ({ lines, outputCallback }) => {\n\n        const input = lines[0].trim();\n        const password: Array<string | null> = [null, null, null, null, null, null, null, null];\n        let i = 0;\n        let lastTime = new Date().getTime();\n        while (password.length !== password.filter((e) => e !== null).length) {\n            const c = getCharacter(input, i++);\n            if (c !== null) {\n                const index = password.indexOf(null);\n                password[index] = c;\n                await outputCallback(null);\n                await outputCallback(fillPasswordWithRandom(password));\n            } else {\n                const current = new Date().getTime();\n                if (current - lastTime > 100) {\n                    lastTime = current;\n                    await outputCallback(null);\n                    await outputCallback(fillPasswordWithRandom(password));\n                }\n            }\n        }\n        await outputCallback(\"Decoded\");\n        await outputCallback(password.join(\"\"));\n    },\n    async ({ lines, outputCallback }) => {\n        const input = lines[0].trim();\n        const password: Array<string | null> = [null, null, null, null, null, null, null, null];\n        let i = 0;\n        let lastTime = new Date().getTime();\n        while (password.length !== password.filter((e) => e !== null).length) {\n            const c = getCharacterAndPosition(input, i++);\n            if (c !== null) {\n                const index = c.index;\n                if (index >= 0 && index < password.length && password[index] === null) {\n                    password[index] = c.c;\n                    await outputCallback(null);\n                    await outputCallback(fillPasswordWithRandom(password));\n                }\n            } else {\n                const current = new Date().getTime();\n                if (current - lastTime > 100) {\n                    lastTime = current;\n                    await outputCallback(null);\n                    await outputCallback(fillPasswordWithRandom(password));\n                }\n            }\n        }\n        await outputCallback(\"Decoded\");\n        await outputCallback(password.join(\"\"));\n    },\n    { key: \"how-about-a-nice-game-of-chess\", title: \"How About a Nice Game of Chess?\", stars: 2}\n);\n","import Best, { CustomBest, minNumber } from \"../../../support/best\";\nimport { entryForFile } from \"../../entry\";\n\nexport const signalsAndNoise = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const result: string[] = [];\n        for (let i = 0; i < lines[0].length; i++) {\n            const frequency = new Map<string, number>();\n            lines.forEach((line) => {\n                frequency.set(line[i], (frequency.get(line[i]) || 0) + 1);\n            });\n            const comparator = new Best<string>();\n            for (const entry of frequency) {\n                comparator.add({key: entry[1], value: entry[0]});\n            }\n            result.push(comparator.currentBest!.value);\n        }\n        await outputCallback(result.join(\"\"));\n    },\n    async ({ lines, outputCallback }) => {\n        const result: string[] = [];\n        for (let i = 0; i < lines[0].length; i++) {\n            const frequency = new Map<string, number>();\n            lines.forEach((line) => {\n                frequency.set(line[i], (frequency.get(line[i]) || 0) + 1);\n            });\n            const comparator = new CustomBest<number, string>(minNumber);\n            for (const entry of frequency) {\n                comparator.add({key: entry[1], value: entry[0]});\n            }\n            result.push(comparator.currentBest!.value);\n        }\n        await outputCallback(result.join(\"\"));\n    },\n    { key: \"signals-and-noise\", title: \"Signals and Noise\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ninterface IP {\n    sections: string[];\n    hypernets: string[];\n}\n\nconst parseLines = (lines: string[]): IP[] => {\n    return lines.map((line) => {\n        let section: string[] = [];\n        let hypernet: string[] = [];\n        const result: IP = {\n            sections: [],\n            hypernets: []\n        };\n        let isHypernet = false;\n        for (const c of line) {\n            if (c === \"[\") {\n                isHypernet = true;\n                if (section.length > 0) {\n                    result.sections.push(section.join(\"\"));\n                    section = [];\n                }\n            } else if (c === \"]\") {\n                isHypernet = false;\n                result.hypernets.push(hypernet.join(\"\"));\n                hypernet = [];\n            } else {\n                if (isHypernet) {\n                    hypernet.push(c);\n                } else {\n                    section.push(c);\n                }\n            }\n        }\n        if (hypernet.length > 0) {\n            result.hypernets.push(hypernet.join(\"\"));\n        }\n        if (section.length > 0) {\n            result.sections.push(section.join(\"\"));\n        }\n        return result;\n    });\n};\n\nconst hasABBA = (sequence: string): boolean => {\n    for (let i = 0; i < sequence.length - 3; i++) {\n        if (sequence[i + 3] === sequence[i] && sequence[i + 1] === sequence[i + 2] && sequence[i + 1] !== sequence[i]) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst supportsTLS = (ip: IP): boolean => {\n    for (const hyper of ip.hypernets) {\n        if (hasABBA(hyper)) {\n            return false;\n        }\n    }\n    for (const section of ip.sections) {\n        if (hasABBA(section)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst supportsSSL = (ip: IP): boolean => {\n    const babs: string[] = [];\n    for (const section of ip.sections) {\n        for (let i = 0; i < section.length - 2; i++) {\n            if (section[i] !== section[i + 1] && section[i] === section[i + 2]) {\n                babs.push(`${section[i + 1]}${section[i]}${section[i + 1]}`);\n            }\n        }\n    }\n\n    for (const hyper of ip.hypernets) {\n        for (const bab of babs) {\n            if (hyper.includes(bab)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nexport const internetProtocolVersion7 = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const ips = parseLines(lines);\n        const matching = ips.filter(supportsTLS).length;\n        await outputCallback(matching);\n    },\n    async ({ lines, outputCallback }) => {\n        const ips = parseLines(lines);\n        const matching = ips.filter(supportsSSL).length;\n        await outputCallback(matching);\n    },\n    { key: \"internet-protocol-version-7\", title: \"Internet Protocol Version 7\", stars: 2}\n);\n","import { Coordinate } from \"../../../support/geometry\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { entryForFile } from \"../../entry\";\n\ntype Cell = \"#\" | \".\";\n\ntype Field = FixedSizeMatrix<Cell>;\n\nconst size = {x: 50, y: 6};\n\nconst empty = (): Field => {\n    const field = new FixedSizeMatrix<Cell>(size);\n    field.fill(\".\");\n    return field;\n};\n\nconst rect = (rectangle: Coordinate, field: Field): Field => {\n    const result = empty();\n    for (let x = 0; x < size.x; x++) {\n        for (let y = 0; y < size.y; y++) {\n            if (x < rectangle.x && y < rectangle.y) {\n                result.set({x, y}, \"#\");\n            } else {\n                result.set({x, y}, field.get({x, y}));\n            }\n        }\n    }\n    return result;\n};\n\nconst rotateRow = (row: number, by: number, field: Field): Field => {\n    const result = empty();\n    field.onEveryCell((c, e) => {\n        const x = c.y === row ? (c.x + by) % size.x : c.x;\n        result.set({x, y: c.y}, e);\n    });\n    return result;\n};\n\nconst rotateColumn = (column: number, by: number, field: Field): Field => {\n    const result = empty();\n    field.onEveryCell((c, e) => {\n        const y = c.x === column ? (c.y + by) % size.y : c.y;\n        result.set({x: c.x, y}, e);\n    });\n    return result;\n};\n\nconst execute = (line: string, field: Field): Field => {\n    const tokens = line.split(\" \");\n    if (tokens[0] === \"rect\") {\n        const [x, y] = tokens[1].split(\"x\").map((e) => parseInt(e, 10));\n        return rect({x, y}, field);\n    } else if (tokens[0] === \"rotate\") {\n        const by = parseInt(tokens[4], 10);\n        const el = parseInt(tokens[2].split(\"=\")[1], 10);\n        if (tokens[1] === \"column\") {\n            return rotateColumn(el, by, field);\n        } else {\n            return rotateRow(el, by, field);\n        }\n    }\n    throw new Error(\"Invalid operation \" + line);\n};\n\nexport const twoFactorAuthentication = entryForFile(\n    async ({ lines, outputCallback }) => {\n        let field: Field = empty();\n        for (const line of lines) {\n            field = execute(line, field);\n        }\n        let count = 0;\n        field.onEveryCell((c, e) => {\n            if (e === \"#\") {\n                count++;\n            }\n        });\n\n        await outputCallback(count);\n\n    },\n    async ({ lines, outputCallback }) => {\n        let field: Field = empty();\n        for (const line of lines) {\n            field = execute(line, field);\n        }\n        await outputCallback(field.toString((e) => e!));\n    },\n    { key: \"two-factor-authentication\", title: \"Two-Factor Authentication\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\nconst parseLines = (lines: string[]): string => {\n    return lines.map((e) => e.trim()).join(\"\");\n};\n\nconst countExpandedLength = (line: string): number => {\n    let count = 0;\n    let i = 0;\n    while (i < line.length) {\n        if (line[i] === \"(\") {\n            const markerEnd = line.indexOf(\")\", i);\n            const marker = line.slice(i + 1, markerEnd);\n            const [size, repeat] = marker.split(\"x\").map((e) => parseInt(e, 10));\n            const toRepeat = line.slice(markerEnd + 1, markerEnd + 1 + size);\n            i = markerEnd + 1 + size;\n            const nestedLength = countExpandedLength(toRepeat);\n            count += (nestedLength * repeat);\n        } else {\n            count++;\n            i++;\n        }\n    }\n    return count;\n};\n\nconst expand = (line: string): string => {\n    const result: string[] = [];\n    let i = 0;\n    while (i < line.length) {\n        if (line[i] === \"(\") {\n            const markerEnd = line.indexOf(\")\", i);\n            const marker = line.slice(i + 1, markerEnd);\n            const [size, repeat] = marker.split(\"x\").map((e) => parseInt(e, 10));\n            const toRepeat = line.slice(markerEnd + 1, markerEnd + 1 + size);\n            for (let x = 0; x < repeat; x++) {\n                result.push(toRepeat);\n            }\n            i = markerEnd + 1 + size;\n        } else {\n            result.push(line[i]);\n            i++;\n        }\n    }\n    return result.join(\"\");\n};\n\nexport const explosivesInCyberspace = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const line = parseLines(lines);\n        await outputCallback(expand(line).length);\n    },\n    async ({ lines, outputCallback }) => {\n        const line = parseLines(lines);\n        await outputCallback(countExpandedLength(line));\n    },\n    { key: \"explosives-in-cyberspace\", title: \"Explosives in Cyberspace\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ntype Instruction = {\n    type: \"value\";\n    value: number;\n    bot: number;\n} | {\n    type: \"give\";\n    low: Out;\n    high: Out;\n    bot: number;\n};\n\ninterface BotState {\n    id: number;\n    chips: number[];\n}\n\ninterface Out {\n        type: \"output\" | \"bot\";\n        value: number;\n}\n\nconst parseLines = (lines: string[]): Instruction[] => {\n    return lines.map((line) => {\n        const tokens = line.split(\" \");\n        if (line.includes(\"goes\")) {\n            // line is value\n            return {\n                type: \"value\",\n                value: parseInt(tokens[1], 10),\n                bot: parseInt(tokens[5], 10)\n            };\n        } else {\n            // line is give\n            return {\n                type: \"give\",\n                bot: parseInt(tokens[1], 10),\n                high: {\n                    value: parseInt(tokens[11], 10),\n                    type: tokens[10] as \"bot\" | \"output\"\n                },\n                low: {\n                    value: parseInt(tokens[6], 10),\n                    type: tokens[5] as \"bot\" | \"output\"\n                }\n            };\n        }\n    });\n};\n\nclass Machine {\n    private callback?: (instruction: Instruction, botState: BotState) => void;\n    private toExecute: Instruction[] = [];\n    private botState: Map<number, BotState> = new Map<number, BotState>();\n    private outputState: Map<number, number[]> = new Map<number, number[]>();\n\n    private stop: boolean = false;\n\n    public execute(instruction: Instruction): void {\n        if (this.canExecute(instruction)) {\n            this.doExecute(instruction);\n            this.executePending();\n        } else {\n            this.toExecute.push(instruction);\n        }\n    }\n\n    public getOutput(id: number): number[] {\n        return this.outputState.get(id) || [];\n    }\n\n    public stopNextPending(): void {\n        this.stop = true;\n    }\n\n    public executeBeforeEveryInstruction(callback: (instruction: Instruction, botState: BotState) => void): void {\n        this.callback = callback;\n    }\n\n    private canExecute(instruction: Instruction): boolean {\n        if (instruction.type === \"value\") {\n            return true;\n        } else {\n            const bot = this.botState.get(instruction.bot);\n            if (!bot) {\n                return false;\n            }\n            return bot.chips.length === 2;\n        }\n    }\n\n    private doExecute(instruction: Instruction): void {\n        const bot = this.getState(instruction.bot);\n        if (this.callback) {\n            this.callback(instruction, bot);\n        }\n        if (instruction.type === \"value\") {\n            bot.chips.push(instruction.value);\n        } else {\n            const high = Math.max(...bot.chips);\n            const low = Math.min(...bot.chips);\n            bot.chips = [];\n            this.giveTo(instruction.high, high);\n            this.giveTo(instruction.low, low);\n        }\n    }\n\n    private giveTo({type, value}: Out, chip: number): void {\n        if (type === \"bot\" ) {\n            const state = this.getState(value);\n            state.chips.push(chip);\n        } else {\n            this.output(value, chip);\n        }\n    }\n\n    private output(id: number, chip: number): void {\n        const bin = this.outputState.get(id) || [];\n        bin.push(chip);\n        this.outputState.set(id, bin);\n    }\n\n    private getState(bot: number): BotState {\n        return this.botState.get(bot) || this.createBot(bot);\n    }\n\n    private createBot(bot: number): BotState {\n        const state: BotState = {\n            id: bot,\n            chips: []\n        };\n        this.botState.set(bot, state);\n        return state;\n    }\n\n    private executePending(): void {\n        if (this.stop) {\n            this.stop = false;\n            return;\n        }\n        for (let i = 0; i < this.toExecute.length; i++) {\n            const instruction = this.toExecute[i];\n            if (this.canExecute(instruction)) {\n                this.doExecute(instruction);\n                this.toExecute.splice(i, 1);\n                return this.executePending();\n            }\n        }\n    }\n}\n\nexport const balanceBots = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const instructions = parseLines(lines);\n        const machine = new Machine();\n        let target: number | null = null;\n        machine.executeBeforeEveryInstruction((instruction, botState) => {\n            if (botState.chips.length === 2) {\n                const [low, high] = [Math.min(...botState.chips), Math.max(...botState.chips)];\n                if (low === 17 && high === 61) {\n                    target = botState.id;\n                }\n            }\n        });\n        for (const instruction of instructions) {\n            machine.execute(instruction);\n            if (target !== null) {\n                await outputCallback(\"Bot was: \" + target);\n                return;\n            }\n        }\n        await outputCallback(\"Not found :(\");\n    },\n    async ({ lines, outputCallback }) => {\n        const instructions = parseLines(lines);\n        const machine = new Machine();\n        for (const instruction of instructions) {\n            machine.execute(instruction);\n        }\n        let result = 1;\n        for (let i = 0; i < 3; i++) {\n            const [x] = machine.getOutput(i);\n            result *= x;\n        }\n        await outputCallback(result);\n    },\n    { key: \"balance-bots\", title: \"Balance Bots\", stars: 2}\n);\n","import { Queue } from \"../../../support/data-structure\";\nimport { subsetGenerator } from \"../../../support/sequences\";\nimport { entryForFile } from \"../../entry\";\nimport { balanceBots } from \"./balance-bots\";\n\ninterface Item {\n    element: string;\n    type: \"generator\" | \"chip\";\n}\n\nfunction match(a: Item, b: Item): boolean {\n    return a.element === b.element && a.type === b.type;\n}\n\ntype Direction = \"up\" | \"down\";\n\nclass Building {\n\n    public currentFloor: number = 0;\n    private _state: Item[][];\n\n    constructor() {\n        const floors = 4;\n        this._state = [];\n        for (let i = 0; i < floors; i++) {\n            this._state.push([]);\n        }\n    }\n\n    public setFloors(floors: Array<{floorId: number, items: Item[]}>): void {\n        for (const floor of floors) {\n            if (floor.floorId < 0 || floor.floorId >= this._state.length) {\n                throw new Error(\"Invalid floor ID: \" + floor.floorId);\n            }\n            this._state[floor.floorId] = floor.items;\n        }\n    }\n\n    public addToFloor(floorId: number, items: Item[]): void {\n        if (floorId < 0 || floorId >= this._state.length) {\n            throw new Error(\"Invalid floor id: \" + floorId);\n        }\n        this._state[floorId] = this._state[floorId].concat(items);\n    }\n\n    public move(items: Item[], direction: Direction): Building | null {\n        const [floor] = this._state.map((e, i) => ({e, i})).filter((e) => {\n            for (const item of items) {\n                if (e.e.filter((x) => match(x, item)).length === 0) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        if (!floor || floor.i !== this.currentFloor) {\n            return null;\n        }\n        const newFloorIndex = floor.i + (direction === \"up\" ? 1 : -1);\n        const newFloor = this._state[newFloorIndex];\n        if (!newFloor) {\n            return null;\n        }\n\n        const newBuilding = this.clone();\n        newBuilding._state[floor.i] = floor.e.filter((e) => items.filter((x) => match(x, e)).length === 0);\n        newBuilding._state[newFloorIndex] = newFloor.concat(items);\n        newBuilding.currentFloor = newFloorIndex;\n\n        const isValid = newBuilding.isValid();\n        if (isValid) {\n            return newBuilding;\n        }\n        return null;\n    }\n\n    public isAllOnLastFloor(): boolean {\n        for (let i = 0; i < this._state.length - 1; i++) {\n            if (this._state[i].length > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public isSubsetValid(items: Item[]) {\n        const floor = items;\n        const generators = floor.filter((e) => e.type === \"generator\");\n        if (generators.length === 0) {\n            return true;\n        }\n        const chips = floor.filter((e) => e.type === \"chip\");\n        for (const chip of chips) {\n            if (generators.filter((e) => e.element === chip.element).length === 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public isValid(): boolean {\n        for (const floor of this._state) {\n            if (!this.isSubsetValid(floor)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public currentFloorItems(): Item[] {\n        return this._state[this.currentFloor];\n    }\n\n    public clone(): Building {\n        const newBuilding = new Building();\n        newBuilding._state = this._state.map((e) => [...e]);\n        newBuilding.currentFloor = this.currentFloor;\n        return newBuilding;\n    }\n\n    public serialize(): string {\n        const res: string[] = [`${this.currentFloor}|`];\n        for (let i = 0; i < this._state.length; i++) {\n            res.push(i.toString());\n            const sorted = this._state[i].map((e) => toColumn(e)).sort();\n            sorted.forEach((e) => res.push(e));\n        }\n        return res.join(\"\");\n    }\n\n    public serializeToEquivalent(): string {\n        const elementMap = new Map<string, number>();\n\n        const res: string[] = [`${this.currentFloor}|`];\n\n        let nextMapped = 0;\n\n        for (let i = 0; i < this._state.length; i++) {\n            res.push(i.toString() + \"~\");\n            for (const item of this._state[i])  {\n                if (!elementMap.has(item.element)) {\n                    elementMap.set(item.element, nextMapped++);\n                }\n            }\n\n            const line: string[] = [];\n            for (const item of this._state[i]) {\n                line.push(`${elementMap.get(item.element)}${item.type}`);\n            }\n            res.push(line.sort().join(\",\"));\n        }\n\n        return res.join(\".\");\n\n    }\n\n    public toString(): string {\n        const out: string[] = [];\n        const columns: string[] = [\"E \"];\n        for (const floor of this._state) {\n            for (const item of floor) {\n                columns.push(toColumn(item));\n            }\n        }\n        for (let i = this._state.length - 1; i >= 0; i--) {\n            const serializedFloor: string[] = [`F${i}`];\n            for (const column of columns) {\n                if (column === \"E \") {\n                    if (i === this.currentFloor) {\n                        serializedFloor.push(\"E \");\n                    } else {\n                        serializedFloor.push(\". \");\n                    }\n                } else {\n                    if (this._state[i].filter((e) => toColumn(e) === column).length > 0) {\n                        serializedFloor.push(column);\n                    } else {\n                        serializedFloor.push(\". \");\n                    }\n                }\n            }\n            out.push(serializedFloor.join(\" \"));\n        }\n        return out.join(\"\\n\");\n    }\n}\n\n\n\nconst parseLines = (lines: string[]): Building => {\n    const floors = lines.map((line) => {\n        const cleaned = line.replace(/[,.]/g, \"\").replace(/-[^ ]*/g, \"\").trim();\n        const tokens = cleaned.split(\" \");\n        const floorOrdinal = tokens[1];\n        const floorId: number = parseOrdinal(floorOrdinal);\n        const generatorIndexes = tokens.map((e, i) => ({e, i})).filter((x) => x.e === \"generator\").map((x) => x.i - 1);\n        const microchipIndexes = tokens.map((e, i) => ({e, i})).filter((x) => x.e === \"microchip\").map((x) => x.i - 1);\n        const items: Item[] = [];\n        for (const generatorIndex of generatorIndexes) {\n            const x = {\n                element: tokens[generatorIndex],\n                type: \"generator\" as \"generator\",\n            };\n            items.push(x);\n        }\n\n        for (const microchipIndex of microchipIndexes) {\n            const x = {\n                element: tokens[microchipIndex],\n                type: \"chip\" as \"chip\",\n            };\n            items.push(x);\n        }\n\n        return {items, floorId};\n    });\n    const building = new Building();\n    building.setFloors(floors);\n    return building;\n};\n\nconst parseOrdinal = (ordinal: string): number => {\n    const valid = [\"first\", \"second\", \"third\", \"fourth\"];\n    const result = valid.indexOf(ordinal.toLowerCase());\n    if (result >= 0) {\n        return result;\n    }\n    throw new Error(\"Invalid ordinal: \" + ordinal);\n};\n\nconst toColumn = (item: Omit<Item, \"column\">): string => {\n    const element = item.element === \"promethium\" ? \"K\" : item.element[0].toUpperCase();\n    const type = item.type[0].toUpperCase();\n    return `${element}${type}`;\n};\n\nconst bringEverythingToFourth = (building: Building): number | null => {\n    const queue = new Queue<{building: Building, steps: number}>();\n    const visitedStates = new Set<string>();\n    queue.add({building, steps: 0});\n    while (!queue.isEmpty) {\n        const node = queue.get()!;\n        const serialized = node.building.serializeToEquivalent();\n        if (visitedStates.has(serialized)) {\n            continue;\n        }\n        visitedStates.add(serialized);\n        const candidateItems = node.building.currentFloorItems();\n        const candidatesToBring = subsetGenerator(candidateItems, 0, 2);\n        for (const candidate of candidatesToBring) {\n            if (candidate.length === 0) {\n                continue;\n            }\n            if (node.building.isSubsetValid(candidate)) {\n                for (const direction of [\"up\", \"down\"] as [\"up\", \"down\"]) {\n                    const moved = node.building.move(candidate, direction);\n                    const newSteps = node.steps + 1;\n                    if (moved) {\n                        if (moved.isAllOnLastFloor()) {\n                            return newSteps;\n                        } else {\n                            queue.add({building: moved, steps: newSteps});\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return null;\n};\n\nexport const radioisotopeThermoelectricGenerators = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const building = parseLines(lines);\n        await outputCallback(building.toString());\n\n        await outputCallback(bringEverythingToFourth(building));\n    },\n    async ({ lines, outputCallback }) => {\n        const building = parseLines(lines);\n        const additionalElements: string[] = [\"elerium\", \"dilithium\"];\n        const types: Array<\"chip\" | \"generator\"> = [\"chip\", \"generator\"];\n        building.addToFloor(0, additionalElements.flatMap((e) => types.map((t) => ({\n            element: e,\n            type: t\n        }))));\n\n        await outputCallback(building.toString());\n\n        await outputCallback(bringEverythingToFourth(building));\n    },\n    { key: \"radioisotope-thermoelectric-generators\", title: \"Radioisotope Thermoelectric Generators\", stars: 2}\n);\n","import { setTimeoutAsync } from \"../../../../support/async\";\n\ninterface Registers {\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n}\n\ntype RegisterKey = keyof Registers;\ninterface State {\n    registers: Registers;\n    currentInstruction: number;\n}\n\ntype Argument = RegisterKey | number;\n\ninterface DoubleArgumentInstruction {\n    type: \"cpy\" | \"jnz\";\n    args: [Argument, Argument];\n}\n\ninterface SingleArgumentInstruction {\n    type: \"inc\" | \"dec\" | \"tgl\";\n    args: Argument;\n}\n\ntype Instruction = SingleArgumentInstruction | DoubleArgumentInstruction;\n\nconst isRegister = (e: any): e is RegisterKey => {\n    return e === \"a\" || e === \"b\" || e === \"c\" || e === \"d\";\n};\n\nconst isSingleArgument = (i: Instruction): i is SingleArgumentInstruction => {\n    return (i.args as [Argument, Argument]).pop === undefined;\n};\n\nconst parseArgument = (s: string): Argument => {\n    if (isRegister(s)) {\n        return s;\n    } else {\n        return parseInt(s, 10);\n    }\n};\n\nconst argumentToValue = (a: Argument, state: State): number => {\n    if (isRegister(a)) {\n        return state.registers[a];\n    }\n    return a;\n};\n\n\n\nconst executeInstruction = (instruction: Instruction, state: State, instructions: Instruction[]): void => {\n    let shouldIncreaseCurrentInstruction = true;\n    switch (instruction.type) {\n        case \"cpy\":\n            if (!isRegister(instruction.args[1])) {\n                break;\n            }\n            const value = argumentToValue(instruction.args[0], state);\n            state.registers[instruction.args[1]] = value;\n            break;\n        case \"inc\":\n            if (!isRegister(instruction.args)) {\n                break;\n            }\n            state.registers[instruction.args]++;\n            break;\n        case \"dec\":\n            if (!isRegister(instruction.args)) {\n                break;\n            }\n            state.registers[instruction.args]--;\n            break;\n        case \"jnz\":\n            // if (!isRegister(instruction.args[0])) {\n            //     break;\n            // }\n            // if (isRegister(instruction.args[1])) {\n            //     break;\n            // }\n            const a = argumentToValue(instruction.args[0], state);\n            if (a !== 0) {\n                shouldIncreaseCurrentInstruction = false;\n                state.currentInstruction += argumentToValue(instruction.args[1], state);\n                    // isRegister(instruction.args[1]) ? state.registers[instruction.args[1]] : instruction.args[1];\n            }\n            break;\n        case \"tgl\":\n            const delta = isRegister(instruction.args) ? state.registers[instruction.args] : instruction.args;\n            const instructionToChange = instructions[state.currentInstruction + delta];\n            if (instructionToChange) {\n                if (isSingleArgument(instructionToChange)) {\n                    if (instructionToChange.type === \"inc\") {\n                        instructionToChange.type = \"dec\";\n                    } else {\n                        instructionToChange.type = \"inc\";\n                    }\n                } else {\n                    if (instructionToChange.type === \"jnz\") {\n                        instructionToChange.type = \"cpy\";\n                    } else {\n                        instructionToChange.type = \"jnz\";\n                    }\n                }\n            }\n            break;\n    }\n\n    if (shouldIncreaseCurrentInstruction) {\n        state.currentInstruction++;\n    }\n};\n\nexport const prettyPrint = (state: State, program: Instruction[]): string => {\n    const output: Array<[string, string]> = [];\n    output.push([\"I\", state.currentInstruction.toString().padStart(5)]);\n    for (const register of [\"a\", \"b\", \"c\", \"d\"] as RegisterKey[]) {\n        output.push([register, state.registers[register].toString().padStart(5)]);\n    }\n\n    const maxOutLength = output.map((e) => e[1].length).reduce((acc, next) => Math.max(acc, next));\n\n    const result: string[] = [];\n\n    const simpleLine = \"+\" + \"-\".repeat(3) + \"+\" + \"-\".repeat(maxOutLength + 2) + \"+\";\n\n    result.push(simpleLine);\n    for (const line of output) {\n        result.push(`| ${line[0]} | ${line[1]} |`);\n        result.push(simpleLine);\n    }\n\n    for (let i = 0; i < program.length; i++) {\n        result.push(\n            (i !== state.currentInstruction ? \"   \" : \"-> \")\n             + `${program[i].type} ${JSON.stringify(program[i].args)}`\n        );\n    }\n\n    return result.join(\"\\n\");\n};\n\nexport const execute = async (\n    program: Instruction[],\n    state: State,\n    executionCallback?: (program: Instruction[], state: State\n) => Promise<boolean>): Promise<void> => {\n    const programExecution = program.map((instruction) => ({...instruction}));\n    const i = 0;\n    while (true) {\n        const currentInstruction = programExecution[state.currentInstruction];\n        if (!currentInstruction) {\n            return;\n        }\n        executeInstruction(currentInstruction, state, programExecution);\n        if (executionCallback) {\n            const result = await executionCallback(programExecution, state);\n            if (!result) {\n                return;\n            }\n        }\n        // console.log(state);\n        // await setTimeoutAsync(1000);\n    }\n};\n\nexport const parseProgram = (lines: string[]): Instruction[] => {\n    return lines\n    .map((line) => line.trim())\n    .filter((line) => line)\n    .filter((line) => !line.startsWith(\"#\"))\n    .map((line) => {\n        const tokens = line.split(\" \");\n        const instruction = tokens[0];\n        if (instruction === \"cpy\" || instruction === \"jnz\") {\n            return {\n                type: instruction,\n                args: [parseArgument(tokens[1]), parseArgument(tokens[2])]\n            };\n        } else if (instruction === \"inc\" || instruction === \"dec\" || instruction === \"tgl\") {\n            return {\n                type: instruction,\n                args: tokens[1] as RegisterKey\n            };\n        } else {\n            throw new Error(\"invalid instruction \" + instruction);\n        }\n    });\n};\n\nexport const emptyState = (): State => {\n    return {\n        currentInstruction: 0,\n        registers: {\n            a: 0,\n            b: 0,\n            c: 0,\n            d: 0\n        }\n    };\n};\n","import { setTimeoutAsync } from \"../../../support/async\";\nimport { entryForFile } from \"../../entry\";\nimport { emptyState, execute, parseProgram } from \"./common/assembunny\";\n\n\nexport const leonardosMonorail = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const program = parseProgram(lines);\n        const state = emptyState();\n        await execute(program, state);\n\n        await outputCallback(state.registers.a);\n    },\n    async ({ lines, outputCallback }) => {\n        const program = parseProgram(lines);\n        const state = emptyState();\n        state.registers.c = 1;\n        await execute(program, state);\n\n        await outputCallback(state.registers.a);\n    },\n    { key: \"leonardos-monorail\", title: \"Leonardo's Monorail\", stars: 2}\n);\n","import { Coordinate, serialization } from \"./geometry\";\r\nimport { Queue } from \"./data-structure\";\r\n\r\ntype FieldGetter<TValue, TCoordinate> = (c: TCoordinate) => TValue | undefined;\r\nexport interface CellWithDistance<TValue, TCoordinate> {\r\n    cell: TValue;\r\n    coordinate: TCoordinate;\r\n    distance: number | null;\r\n}\r\n\r\ninterface DistanceGetter<TValue, TCoordinate> {\r\n    list: Array<CellWithDistance<TValue, TCoordinate>>;\r\n    map(c: TCoordinate): (number | null);\r\n}\r\n\r\ntype DistanceCalculator<TValue, TCoordinate> =\r\n    (start: CellWithDistance<TValue, TCoordinate>, end: TCoordinate) => number | null;\r\n\r\nexport function calculateDistancesGenericCoordinates<TValue, TCoordinate>(\r\n    fieldGetter: FieldGetter<TValue, TCoordinate>,\r\n    distanceCalculator: DistanceCalculator<TValue, TCoordinate>,\r\n    getSurrounding: (c: TCoordinate) => TCoordinate[],\r\n    start: TCoordinate,\r\n    serializer: (c: TCoordinate) => string,\r\n    stopAt: ((c: CellWithDistance<TValue, TCoordinate>) => boolean) | null = null\r\n): DistanceGetter<TValue, TCoordinate> {\r\n    const distanceMap: { [key: string]: CellWithDistance<TValue, TCoordinate> } = {};\r\n\r\n    const visitQueue = new Queue<CellWithDistance<TValue, TCoordinate>>();\r\n\r\n    const startCell = fieldGetter(start);\r\n    if (!startCell) {\r\n        throw new RangeError(\"Cannot find starting cell\");\r\n    }\r\n    const startNode: CellWithDistance<TValue, TCoordinate> = {\r\n        cell: startCell,\r\n        coordinate: start,\r\n        distance: 0\r\n    };\r\n\r\n    distanceMap[serializer(startNode.coordinate)] = startNode;\r\n    visitQueue.add(startNode);\r\n\r\n    let forceStop = false;\r\n    while (!visitQueue.isEmpty) {\r\n        const node = visitQueue.get()!;\r\n        const surrounding = getSurrounding(node.coordinate);\r\n        for (const s of surrounding) {\r\n            const withDistance = distanceMap[serializer(s)];\r\n            if (!withDistance) {\r\n                const cell = fieldGetter(s);\r\n                if (cell) {\r\n                    const distance = distanceCalculator(node, s);\r\n                    if (distance) {\r\n                        const sWithDistance: CellWithDistance<TValue, TCoordinate> = {\r\n                            cell,\r\n                            coordinate: s,\r\n                            distance\r\n                        };\r\n                        distanceMap[serializer(s)] = sWithDistance;\r\n                        if (stopAt && stopAt(sWithDistance))  {\r\n                            forceStop = true;\r\n                            break;\r\n                        }\r\n                        visitQueue.add(sWithDistance);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (forceStop) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return {\r\n        map: (c: TCoordinate) => {\r\n            const v = distanceMap[serializer(c)];\r\n            if (v) {\r\n                return v.distance;\r\n            } else {\r\n                return null;\r\n            }\r\n        },\r\n        list: Object.values(distanceMap)\r\n    };\r\n}\r\n\r\nexport function calculateDistances<T>(\r\n    fieldGetter: FieldGetter<T, Coordinate>,\r\n    distanceCalculator: DistanceCalculator<T, Coordinate>,\r\n    getSurrounding: (c: Coordinate) => Coordinate[],\r\n    start: Coordinate,\r\n    stopAt: ((c: CellWithDistance<T, Coordinate>) => boolean) | null = null\r\n): DistanceGetter<T, Coordinate> {\r\n    return calculateDistancesGenericCoordinates(\r\n        fieldGetter,\r\n        distanceCalculator,\r\n        getSurrounding,\r\n        start,\r\n        serialization.serialize,\r\n        stopAt\r\n    );\r\n    // const distanceMap: { [key: string]: CellWithDistance<T, Coordinate> } = {};\r\n\r\n    // const visitQueue = new Queue<CellWithDistance<T, Coordinate>>();\r\n\r\n    // const startCell = fieldGetter(start);\r\n    // if (!startCell) {\r\n    //     throw new RangeError(\"Cannot find starting cell\");\r\n    // }\r\n    // const startNode: CellWithDistance<T, Coordinate> = {\r\n    //     cell: startCell,\r\n    //     coordinate: start,\r\n    //     distance: 0\r\n    // };\r\n\r\n    // distanceMap[serialization.serialize(startNode.coordinate)] = startNode;\r\n    // visitQueue.add(startNode);\r\n\r\n    // while (!visitQueue.isEmpty) {\r\n    //     const node = visitQueue.get()!;\r\n    //     const surrounding = getSurrounding(node.coordinate);\r\n    //     surrounding.forEach((s) => {\r\n    //         const withDistance = distanceMap[serialization.serialize(s)];\r\n    //         if (!withDistance) {\r\n    //             const cell = fieldGetter(s);\r\n    //             if (cell) {\r\n    //                 const distance = distanceCalculator(node, s);\r\n    //                 if (distance) {\r\n    //                     const sWithDistance: CellWithDistance<T, Coordinate> = {\r\n    //                         cell,\r\n    //                         coordinate: s,\r\n    //                         distance\r\n    //                     };\r\n    //                     distanceMap[serialization.serialize(s)] = sWithDistance;\r\n    //                     visitQueue.add(sWithDistance);\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     });\r\n    // }\r\n\r\n    // return {\r\n    //     map: (c: Coordinate) => {\r\n    //         const v = distanceMap[serialization.serialize(c)];\r\n    //         if (v) {\r\n    //             return v.distance;\r\n    //         } else {\r\n    //             return null;\r\n    //         }\r\n    //     },\r\n    //     list: Object.values(distanceMap)\r\n    // };\r\n}\r\n","import { Coordinate, getSurrounding, manhattanDistance } from \"../../../support/geometry\";\nimport { calculateDistances } from \"../../../support/labyrinth\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { entryForFile } from \"../../entry\";\n\nconst countParity = (n: number): 0 | 1 => {\n    let parity: (0 | 1) = 0;\n    while (n !== 0) {\n        n = (n - 1) & n;\n        parity = (parity ^ 1) as (0 | 1);\n    }\n    return parity;\n};\n\ntype Tile = \"#\" | \".\";\n\nconst calculatorBuilder = (secretNumber: number): ((c: Coordinate) => Tile) => {\n    return (c: Coordinate) => {\n        const value = (c.x + c.y) ** 2 + 3 * c.x + c.y + secretNumber;\n        const result = countParity(value) === 0 ? \".\" : \"#\";\n        return result;\n    };\n};\n\nexport const aMazeOfTwistyLittleCubicles = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const calculator = calculatorBuilder(parseInt(lines[0], 10));\n        // const calculator = calculatorBuilder(10);\n        const target = {x: 31, y: 39};\n        // const target = {x: 7, y: 4};\n        const maze = calculateDistances<Tile>(\n            (c) => (c.x < 0 || c.y < 0) ? undefined : calculator(c),\n            (a, b) => (a.distance || 0) + manhattanDistance(a.coordinate, b),\n            (c) => getSurrounding(c).filter((e) => e.x >= 0 && e.y >= 0).filter((e) => calculator(e) === \".\"),\n            {x: 1, y: 1},\n            (c) => manhattanDistance(c.coordinate, target) === 0\n        );\n\n        await outputCallback(maze.map(target));\n\n    },\n    async ({ lines, outputCallback }) => {\n        const calculator = calculatorBuilder(parseInt(lines[0], 10));\n        // const calculator = calculatorBuilder(10);\n        const target = {x: 31, y: 39};\n        // const target = {x: 7, y: 4};\n        const maze = calculateDistances<Tile>(\n            (c) => (c.x < 0 || c.y < 0) ? undefined : calculator(c),\n            (a, b) => (a.distance || 0) + manhattanDistance(a.coordinate, b),\n            (c) => getSurrounding(c).filter((e) => e.x >= 0 && e.y >= 0).filter((e) => calculator(e) === \".\"),\n            {x: 1, y: 1},\n            (c) => (c.distance && c.distance > 50) || false\n        );\n\n        // let count = 0;\n        // maze.list.filter(e => e.cell === \".\" && e.distance && e.distance <= 50).forEach(() => count++)\n        await outputCallback(JSON.stringify(maze.list.filter((e) => e.distance !== null && e.distance <= 50).length));\n\n        const field = new FixedSizeMatrix<Tile | number>({x: 60, y: 60});\n        for (let x = 0; x < 60; x++) {\n            for (let y = 0; y < 60; y++) {\n                const tile = calculator({x, y});\n                if (tile === \"#\") {\n                    field.set({x, y}, tile);\n                } else {\n                    field.set({x, y}, maze.map({x, y}) || \".\");\n                }\n            }\n        }\n        await outputCallback(field.toString((e) => {\n            if (e === \"#\" || e === \".\") {\n                return ` ${e} `;\n            } else if (e) {\n                if (e < 10) {\n                    return ` ${e} `;\n                } else {\n                    return ` ${e}`;\n                }\n            } else {\n                return \"   \";\n            }\n        }));\n    },\n    { key: \"a-maze-of-twisty-little-cubicles\", title: \"A Maze of Twisty Little Cubicles\", stars: 2}\n);\n","import { Md5 } from \"ts-md5\";\nimport { entryForFile } from \"../../entry\";\n\ntype Hash = (n: number) => string;\n\nconst baseHashGenerator = (salt: string): Hash => {\n    return (n: number) => {\n        return Md5.hashAsciiStr(salt + n) as string;\n    };\n};\n\nconst stretchHashGenerator = (salt: string): Hash => {\n    return (n: number) => {\n        let current: string = Md5.hashAsciiStr(salt + n) as string;\n        for (let i = 0; i < 2016; i++) {\n            current = Md5.hashAsciiStr(current) as string;\n        }\n        return current;\n    };\n};\n\nconst incrementHashes = (hash: Hash, current: string[], howManyToAdd: number) => {\n    let nextIndex = current.length;\n    const newLength = current.length + howManyToAdd;\n    while (nextIndex < newLength) {\n        const v = hash(nextIndex);\n        current.push(v);\n        nextIndex++;\n    }\n    console.log(\"New length: \" + newLength);\n};\n\nconst findTriplet = (s: string): number | null => {\n    const tokens = s.split(\"\");\n    for (let i = 0; i < tokens.length - 2; i++) {\n        if (tokens[i] === tokens[i + 1] && tokens[i + 1] === tokens[i + 2]) {\n            return i;\n        }\n    }\n    return null;\n};\n\nconst hasQuintuplet = (s: string, c: string): boolean => {\n    const rawTarget: string[] = [];\n    for (let i = 0; i < 5; i++) {\n        rawTarget.push(c);\n    }\n    const target = rawTarget.join(\"\");\n    return s.includes(target);\n};\n\nconst isValid = (s: string, hashes: string[], hash: Hash, index: number): boolean => {\n    const triplet = findTriplet(s);\n    if (triplet === null) {\n        return false;\n    }\n    const targetIndex = index + 1000;\n    while (targetIndex >= hashes.length) {\n        incrementHashes(hash, hashes, 2000);\n    }\n    for (let i = index + 1; i <= targetIndex; i++) {\n        if (hasQuintuplet(hashes[i], s[triplet])) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const oneTimePad = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const hashCalculator = baseHashGenerator(lines[0]);\n        let howMany = 64;\n        const hashes: string[] = [];\n        const keys: Array<[string, number]> = [];\n        let currentIndex = 0;\n        while (howMany > 0) {\n            if (currentIndex >= hashes.length) {\n                incrementHashes(hashCalculator, hashes, 2000);\n            }\n            if (isValid(hashes[currentIndex], hashes, hashCalculator, currentIndex)) {\n                keys.push([hashes[currentIndex], currentIndex]);\n                howMany--;\n            }\n            currentIndex++;\n        }\n        await outputCallback(keys[keys.length - 1][1]);\n    },\n    async ({ lines, outputCallback }) => {\n        const hashCalculator = stretchHashGenerator(lines[0]);\n        let howMany = 64;\n        const hashes: string[] = [];\n        const keys: Array<[string, number]> = [];\n        let currentIndex = 0;\n        while (howMany > 0) {\n            if (currentIndex >= hashes.length) {\n                incrementHashes(hashCalculator, hashes, 2000);\n            }\n            if (isValid(hashes[currentIndex], hashes, hashCalculator, currentIndex)) {\n                keys.push([hashes[currentIndex], currentIndex]);\n                howMany--;\n            }\n            currentIndex++;\n        }\n        await outputCallback(keys[keys.length - 1][1]);\n    },\n    { key: \"one-time-pad\", title: \"One-Time Pad\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ninterface Disc {\n    size: number;\n    position: number;\n    level: number;\n}\n\ninterface Ball {\n    launchedAt: number;\n    level: number;\n    debug: string[];\n}\n\nconst parseLines = (lines: string[]): Disc[] => {\n    return lines.map((line) => {\n        const tokens = line.replace(/[.,;=#]/g, \" \").split(\" \").filter((e) => e);\n        return {\n            level: parseInt(tokens[1], 10),\n            size: parseInt(tokens[3], 10),\n            position: parseInt(tokens[tokens.length - 1], 10)\n        };\n    });\n};\n\nconst moveDisc = (disc: Disc): Disc => {\n    return {\n        ...disc,\n        position: (disc.position + 1) % disc.size\n    };\n};\n\nclass GameState {\n    public get time(): number {\n        return this._time;\n    }\n    private _time: number = 0;\n\n    private balls: Ball[] = [];\n    constructor(private discs: Disc[]) {\n        this.addNewBall();\n    }\n\n    public passTime(): Ball | null {\n        this._time++;\n        this.moveDiscs();\n        this.moveBalls();\n        const winner = this.findWinner();\n        if (winner) {\n            return winner;\n        }\n        this.removeInvalidBalls();\n        this.addNewBall();\n        this.debug();\n        return null;\n    }\n\n    public toString(): string {\n        return `${this.time}|${this.discs.map((d) => `${d.level}~${d.position}`).join(\"-\")}`;\n    }\n\n    private debug() {\n        this.balls.forEach((ball) => {\n            ball.debug.push(`${this.toString()}!${ball.level}`);\n        });\n    }\n\n    private addNewBall() {\n        this.balls.push({level: 0, launchedAt: this._time, debug: []});\n    }\n\n    private moveDiscs() {\n        this.discs = this.discs.map(moveDisc);\n    }\n\n    private moveBalls() {\n        this.balls.forEach((b) => b.level++);\n    }\n\n    private findWinner(): Ball | null {\n        const winner = this.balls.find((ball) => ball.level > this.discs.length);\n        if (winner) {\n            return winner;\n        }\n        return null;\n    }\n\n    private removeInvalidBalls() {\n        this.balls = this.balls.filter((ball) => {\n            const matchingDisc = this.discs[ball.level - 1];\n            if (!matchingDisc) {\n                throw new Error(\"What happened here?\");\n            }\n            return matchingDisc.position === 0;\n        });\n    }\n}\n\nexport const timingIsEverything = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const discs = parseLines(lines);\n        const state = new GameState(discs);\n        while (true) {\n            const winner = state.passTime();\n            if (winner) {\n                await outputCallback(\"Found winner!\");\n                await outputCallback(winner.launchedAt);\n                await outputCallback(winner.debug.join(\"\\n\"));\n                break;\n            }\n            if (state.time % 1000 === 0) {\n                await outputCallback(\"Current time: \" + state.time);\n            }\n        }\n    },\n    async ({ lines, outputCallback }) => {\n        const discs = parseLines(lines);\n        discs.push({level: discs.length + 1, position: 0, size: 11});\n        const state = new GameState(discs);\n        while (true) {\n            const winner = state.passTime();\n            if (winner) {\n                await outputCallback(\"Found winner!\");\n                await outputCallback(winner.launchedAt);\n                await outputCallback(winner.debug.join(\"\\n\"));\n                break;\n            }\n            if (state.time % 1000 === 0) {\n                await outputCallback(\"Current time: \" + state.time);\n            }\n        }\n    },\n    { key: \"timing-is-everything\", title: \"Timing is Everything\", stars: 2}\n);\n","import { groupBy } from \"../../../support/sequences\";\nimport { entryForFile } from \"../../entry\";\n\nexport const dragonStep = (data: string): string => {\n    const tokens = data.split(\"\").reverse().map((e) => e === \"0\" ? \"1\" : \"0\");\n    return [data, \"0\"].concat(tokens).join(\"\");\n};\n\nconst fillDisk = (data: string, length: number): string => {\n    while (data.length < length) {\n        data = dragonStep(data);\n    }\n    return data.length === length ? data : data.slice(0, length);\n};\n\nexport const calculateChecksum = (data: string): string => {\n    if (data.length % 2 === 1) {\n        return data;\n    }\n    const result: string[] = [];\n    for (let i = 0; i < data.length; i += 2) {\n        result.push(data[i] === data[i + 1] ? \"1\" : \"0\");\n    }\n    return calculateChecksum(result.join(\"\"));\n};\n\nexport const dragonEverything = (data: string, diskSize: number): string => {\n    data = fillDisk(data, diskSize);\n    return calculateChecksum(data);\n};\n\nexport const dragonChecksum = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const checksum = dragonEverything(lines[0], 272);\n        await outputCallback(checksum);\n    },\n    async ({ lines, outputCallback }) => {\n        const checksum = dragonEverything(lines[0], 35651584);\n        await outputCallback(checksum);\n    },\n    { key: \"dragon-checksum\", title: \"Dragon Checksum\", stars: 2}\n);\n","import { Md5 } from \"ts-md5\";\nimport { Lifo, Queue } from \"../../../support/data-structure\";\nimport { CCoordinate, Coordinate, directionList, directions, manhattanDistance, serialization } from \"../../../support/geometry\";\nimport { calculateDistancesGenericCoordinates } from \"../../../support/labyrinth\";\nimport { entryForFile } from \"../../entry\";\n\ntype Hash = (steps: string[] | string) => string;\n\ninterface CoordinateWithSteps {\n    coordinate: Coordinate;\n    steps: string;\n    hash: string;\n}\n\nconst serialize = (coordinate: CoordinateWithSteps): string => {\n    const base = serialization.serialize(coordinate.coordinate);\n    return `${coordinate.steps}~${base}`;\n};\n\nconst isString = (s: string[] | string): s is string => {\n    return (typeof s) === \"string\";\n};\n\nconst hashFactory = (secret: string): Hash => {\n    return (steps: string[] | string) => {\n        return Md5.hashAsciiStr(secret + (isString(steps) ? steps : steps.join(\"\"))) as string;\n    };\n};\n\nconst isValidCharacter = (c: string): boolean => [\"b\", \"c\", \"d\", \"e\", \"f\"].includes(c);\n\nconst isDirectionAvailable = (size: Coordinate, c: CoordinateWithSteps, direction: CCoordinate) => {\n    const candidate = direction.sum(c.coordinate);\n    if (candidate.x < 0 || candidate.y < 0 || candidate.x >= size.x || candidate.y >= size.y) {\n        return false;\n    }\n    if (direction.is(directions.up)) {\n        return isValidCharacter(c.hash[0]);\n    } else if (direction.is(directions.down)) {\n        return isValidCharacter(c.hash[1]);\n    } else if (direction.is(directions.left)) {\n        return isValidCharacter(c.hash[2]);\n    } else if (direction.is(directions.right)) {\n        return isValidCharacter(c.hash[3]);\n    } else {\n        throw new Error(\"Invalid direction\");\n    }\n};\n\nconst serializeDirection = (direction: CCoordinate): string => {\n    if (direction.is(directions.up)) {\n        return \"U\";\n    } else if (direction.is(directions.down)) {\n        return \"D\";\n    } else if (direction.is(directions.left)) {\n        return \"L\";\n    } else if (direction.is(directions.right)) {\n        return \"R\";\n    } else {\n        throw new Error(\"Invalid direction\");\n    }\n};\n\nexport const twoStepsForward = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const secret = lines[0];\n        const hash = hashFactory(secret);\n        const size = {x: 4, y: 4};\n        const target = {x: 3, y: 3};\n        const map = calculateDistancesGenericCoordinates<\"x\", CoordinateWithSteps>(\n            ((c) => \"x\"),\n            (start, end) => manhattanDistance(start.coordinate.coordinate, end.coordinate) + (start.distance || 0),\n            (c) => [\n                directions.up,\n                directions.left,\n                directions.down,\n                directions.right\n            ].filter((e) => isDirectionAvailable(size, c, e)).map((d) => ({\n                coordinate: d.sum(c.coordinate),\n                steps: c.steps + serializeDirection(d)\n            })).map((e) => ({\n                ...e,\n                hash: hash(e.steps)\n            })),\n            {coordinate: {x: 0, y: 0}, steps: \"\", hash: hash([])},\n            serialize,\n            (e) => manhattanDistance(e.coordinate.coordinate, target) === 0\n        );\n        await outputCallback(\n            map.list\n                .filter((e) => manhattanDistance(e.coordinate.coordinate, target) === 0)\n                .map((e) => e.coordinate.steps)\n            );\n    },\n    async ({ lines, outputCallback }) => {\n        const target = {x: 3, y: 3};\n        const secret = lines[0];\n        const hash = hashFactory(secret);\n        const size = {x: 4, y: 4};\n        const queue: CoordinateWithSteps[] = [];\n        queue.push({coordinate: {x: 0, y: 0}, steps: \"\", hash: hash([])});\n\n        let bestResult: number = Number.MIN_VALUE;\n\n        let iteration = 1;\n        const spreads: number[] = [];\n        while (queue.length > 0) {\n            const current = queue.pop()!;\n            const surrounding = [\n                directions.up,\n                directions.left,\n                directions.down,\n                directions.right\n            ].filter((e) => isDirectionAvailable(size, current, e)).map((d) => ({\n                coordinate: d.sum(current.coordinate),\n                steps: current.steps + serializeDirection(d),\n            })).map((e) => ({...e, hash: hash(e.steps)}));\n            spreads.push(surrounding.length);\n            if (spreads.length > 10000) {\n                await outputCallback(spreads.reduce((acc, next) => acc + next, 0) / spreads.length);\n                spreads.length = 0;\n            }\n\n            for (const s of surrounding) {\n                if (manhattanDistance(s.coordinate, target) === 0) {\n                    bestResult = Math.max(bestResult, s.steps.length);\n                } else {\n                    queue.push(s);\n                }\n            }\n            if ((++iteration) % 10000 === 0) {\n                await outputCallback(\"Iteration: \" + (iteration / 1000) + \"k\");\n                await outputCallback(`Size: ${queue.length}`);\n            }\n        }\n\n        await outputCallback(bestResult);\n    },\n    { key: \"two-steps-forward\", title: \"Two Steps Forward\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ntype Cell = \"^\" | \".\";\n\nconst getSafe = (cell: Cell[], index: number): Cell => {\n    if (index < 0 || index >= cell.length) {\n        return \".\";\n    }\n    return cell[index];\n};\n\nconst mapCell = (left: Cell, center: Cell, right: Cell): Cell => {\n    const total = [left, center, right];\n    const traps = total.filter((e) => e === \"^\").length;\n    if (traps === 2) {\n        if (right  === \".\" || left === \".\") {\n            return \"^\";\n        }\n    }\n    if (traps === 1) {\n        if (left === \"^\" || right === \"^\") {\n            return \"^\";\n        }\n    }\n    return \".\";\n};\n\nconst evolve = (line: Cell[]): Cell[] => {\n    const result: Cell[] = [];\n    for (let i = 0; i < line.length; i++) {\n        const left = getSafe(line, i - 1);\n        const center = getSafe(line, i);\n        const right = getSafe(line, i + 1);\n        result.push(mapCell(left, center, right));\n    }\n    return result;\n};\n\nconst buildMap = (startLine: Cell[], size: number): Cell[][] => {\n    const result: Cell[][] = [startLine];\n    for (let i = 1; i < size; i++) {\n        result.push(evolve(result[i - 1]));\n    }\n    return result;\n};\n\nconst prettify = (cells: Cell[][]): string => {\n    return cells.map((line) => line.join(\"\")).join(\"\\n\");\n};\n\nconst countSafe = (cells: Cell[]): number => cells.filter((c) => c === \".\").length;\n\nexport const likeARogue = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const result = buildMap(lines[0].split(\"\") as Cell[], 40);\n        await outputCallback(prettify(result));\n        await outputCallback(result.flatMap((r) => r).filter((e) => e === \".\").length);\n    },\n    async ({ lines, outputCallback }) => {\n        let lastLine = lines[0].split(\"\") as Cell[];\n        let result: number = countSafe(lastLine);\n        const size = 400000;\n        for (let i = 1; i < size; i++) {\n            lastLine = evolve(lastLine);\n            result += countSafe(lastLine);\n        }\n        await outputCallback(result);\n    },\n    { key: \"like-a-rogue\", title: \"Like a Rogue\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ninterface Elf {\n    index: number;\n    presents: number;\n}\n\nconst integerLogarithm = (x: number, base: number): {value: number, isLower: boolean} => {\n    let result: number = 0;\n    let current = 1;\n    while (current < x) {\n        current *= base;\n        result++;\n    }\n    if (current === x) {\n        return {value: result, isLower: false};\n    }\n    return {value: result - 1, isLower: true};\n};\n\nexport const anElephantNamedJoseph = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const howManyElves = parseInt(lines[0], 10);\n        let elves: Elf[] = [];\n        for (let i = 0; i < howManyElves; i++) {\n            elves.push({\n                index: i + 1,\n                presents: 1\n            });\n        }\n        while (true) {\n            for (let i = 0; i < elves.length; i++) {\n                if (elves[i].presents === 0) {\n                    continue;\n                }\n                const stealFrom = (i + 1) % elves.length;\n                elves[i].presents += elves[stealFrom].presents;\n                elves[stealFrom].presents = 0;\n            }\n            elves = elves.filter((e) => e.presents > 0);\n            if (elves.length === 1) {\n                await outputCallback(\"Found it!\");\n                await outputCallback(elves[0].index);\n                return;\n            }\n        }\n    },\n    async ({ lines, outputCallback }) => {\n        const calculator = (howManyElves: number) => {\n            const logarithm = integerLogarithm(howManyElves, 3);\n            if ([81, 27, 3].includes(howManyElves)) {\n                console.log(logarithm);\n            }\n            if (!logarithm.isLower) {\n                return howManyElves;\n            }\n            const delta = 3 ** logarithm.value;\n            if (howManyElves <= delta * 2) {\n                return howManyElves - delta;\n            } else {\n                return 2 * howManyElves - 3 * delta;\n            }\n\n        };\n        await outputCallback(\"Starting pattern calculations...\");\n        for (let howManyElves = 1; howManyElves < 100; howManyElves++) {\n            const elves: Elf[] = [];\n            for (let i = 0; i < howManyElves; i++) {\n                elves.push({\n                    index: i + 1,\n                    presents: 1\n                });\n            }\n            let nextIndex = 0;\n            const lastSteal: null | number = null;\n            while (elves.length > 1) {\n                if (elves.length % 10000 === 0) {\n                    await outputCallback(elves.length);\n                }\n                nextIndex = nextIndex % elves.length;\n                const stealFrom = (nextIndex + Math.floor(elves.length / 2)) % elves.length;\n                if (lastSteal !== null) {\n                    if (elves.length % 2 === 0) {\n                        if (stealFrom !== lastSteal + 2) {\n                            throw new Error(\":(\");\n                        }\n                    } else {\n                        if (stealFrom !== lastSteal + 1) {\n                            throw new Error(\":((\");\n                        }\n                    }\n                }\n                elves[nextIndex].presents += elves[stealFrom].presents;\n                elves.splice(stealFrom, 1);\n                if (nextIndex < stealFrom) {\n                    nextIndex++;\n                }\n            }\n            await outputCallback(`${howManyElves}:${elves[0].index}:${calculator(howManyElves)}`);\n        }\n        await outputCallback(\"Final calculation:\");\n        const elvesCount = parseInt(lines[0], 10);\n        await outputCallback(calculator(elvesCount));\n    },\n    { key: \"an-elephant-named-joseph\", title: \"An Elephant Named Joseph\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\ninterface Range {\n    start: number;\n    end: number;\n}\n\nclass Ranges {\n    private _ranges: Range[] = [];\n    public addRange(start: number, end: number): Ranges {\n        this._ranges.push({start, end});\n        this.mergeRanges();\n        return this;\n    }\n\n    public addRanges(ranges: Range[]): Ranges {\n        this._ranges = this._ranges.concat(ranges);\n        this.mergeRanges();\n        return this;\n    }\n\n    private mergeRanges() {\n        this._ranges.sort((a, b) => a.start - b.start);\n        for (let i = 0; i < this._ranges.length - 1; i++) {\n            if (this._ranges[i].end >= this._ranges[i + 1].start - 1) {\n                this._ranges[i + 1].start = Math.min(this._ranges[i].start, this._ranges[i + 1].start);\n                this._ranges[i + 1].end = Math.max(this._ranges[i].end, this._ranges[i + 1].end);\n                this._ranges[i].start = -1;\n            }\n        }\n        this._ranges = this._ranges.filter((e) => e.start >= 0);\n    }\n\n    public get ranges() {\n        return this._ranges.map((e) => ({...e}));\n    }\n\n    public get length() {\n        return this._ranges.length;\n    }\n}\n\nconst parseLines = (lines: string[]): Ranges => {\n    return new Ranges().addRanges(lines.map((line) => {\n        const [a, b] = line.split(\"-\").map((e) => parseInt(e, 10));\n        return {start: a, end: b};\n    }));\n};\n\nexport const firewallRules = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const ranges = parseLines(lines);\n\n        await outputCallback(`${ranges.length}/${lines.length}`);\n        const firstRange = ranges.ranges[0];\n        await outputCallback(\"First free ip: \");\n        if (firstRange.start !== 0) {\n            await outputCallback(0);\n        } else {\n            await outputCallback(firstRange.end + 1);\n        }\n    },\n    async ({ lines, outputCallback }) => {\n        const ranges = parseLines(lines);\n        const minValue = 0;\n        const maxValue = 2 ** 32 - 1;\n\n        let nextCandidate = minValue;\n        let result = 0;\n        for (const range of ranges.ranges) {\n            const delta = range.start - nextCandidate;\n            result += delta;\n            nextCandidate = range.end + 1;\n        }\n        result += maxValue - nextCandidate + 1;\n        await outputCallback(result);\n    },\n    { key: \"firewall-rules\", title: \"Firewall Rules\", stars: 2}\n);\n","import { permutationGenerator } from \"../../../support/sequences\";\nimport { entryForFile } from \"../../entry\";\n\ntype Rule = {\n    type: \"swap-position\";\n    a: number;\n    b: number;\n} | {\n    type: \"swap-letter\";\n    a: string;\n    b: string;\n} | {\n    type: \"rotate\";\n    direction: \"right\" | \"left\";\n    steps: number\n} | {\n    type: \"rotate-on\";\n    direction: \"right\";\n    letter: string;\n} | {\n    type: \"reverse\";\n    from: number;\n    to: number;\n} | {\n    type: \"move\";\n    from: number;\n    to: number;\n};\n\nconst parseLine = (line: string): Rule => {\n    const tokens = line.split(\" \");\n    switch (tokens[0]) {\n        case \"swap\":\n            if (tokens[1] === \"position\") {\n                return {\n                    type: \"swap-position\",\n                    a: parseInt(tokens[2], 10),\n                    b: parseInt(tokens[5], 10)\n                };\n            } else if (tokens[1] === \"letter\") {\n                return {\n                    type: \"swap-letter\",\n                    a: tokens[2],\n                    b: tokens[5]\n                };\n            } else {\n                throw new Error(\"Invalid position token: \" + tokens[1]);\n            }\n        case \"rotate\":\n            if (tokens[1] === \"based\") {\n                return {\n                    type: \"rotate-on\",\n                    direction: \"right\",\n                    letter: tokens[6]\n                };\n            } else if (tokens[1] === \"left\" || tokens[1] === \"right\") {\n                return {\n                    type: \"rotate\",\n                    direction: tokens[1],\n                    steps: parseInt(tokens[2], 10)\n                };\n            } else {\n                throw new Error(\"Invalid rotate token: \" + tokens[1]);\n            }\n        case \"reverse\":\n            return {\n                type: \"reverse\",\n                from: parseInt(tokens[2], 10),\n                to: parseInt(tokens[4], 10)\n            };\n        case \"move\":\n            return {\n                type: \"move\",\n                from: parseInt(tokens[2], 10),\n                to: parseInt(tokens[5], 10)\n            };\n        default:\n            throw new Error(\"Invalid token\");\n    }\n};\n\nconst applyRule = (input: string, rule: Rule): string => {\n    const tokenized = [...input];\n    switch (rule.type) {\n        case \"swap-position\":\n            return tokenized.map((e, i) => i === rule.a ? input[rule.b] : (i === rule.b ? input[rule.a] : e)).join(\"\");\n        case \"swap-letter\":\n            return applyRule(input, {type: \"swap-position\", a: input.indexOf(rule.a), b: input.indexOf(rule.b)});\n        case \"rotate\":\n            const rotate = (rindex: number) => {\n                const steps = (rule.direction === \"right\" ? -rule.steps : rule.steps);\n                return (rindex + steps + 100 * tokenized.length) % tokenized.length;\n            };\n            return tokenized.map((e, i) => tokenized[rotate(i)]).join(\"\");\n        case \"rotate-on\":\n            const index = input.indexOf(rule.letter);\n            const base = index + 1;\n            const rotateOf = index >= 4 ? base + 1 : base;\n            return applyRule(input, {type: \"rotate\", steps: rotateOf, direction: rule.direction});\n        case \"reverse\":\n            return tokenized.map((e, i) => {\n                if (i < rule.from || i > rule.to) {\n                    return e;\n                }\n                const reverseIndex = rule.from + (rule.to - i);\n                return tokenized[reverseIndex];\n            }).join(\"\");\n        case \"move\":\n            return tokenized.map((e, i) => {\n                if (rule.from < rule.to) {\n                    if (i < rule.from) {\n                        return e;\n                    }\n                    if (i < rule.to) {\n                        return tokenized[i + 1];\n                    }\n                    if (i === rule.to) {\n                        return tokenized[rule.from];\n                    }\n                    return e;\n                } else {\n                    if (i < rule.to) {\n                        return e;\n                    } else if (i === rule.to) {\n                        return tokenized[rule.from];\n                    } else if (i <= rule.from) {\n                        return tokenized[i - 1];\n                    } else {\n                        return e;\n                    }\n                }\n            }).join(\"\");\n    }\n};\n\nconst serializeRule = (rule: Rule): string => {\n    switch (rule.type) {\n        case \"swap-position\":\n            return `swap position ${rule.a} with position ${rule.b}`;\n        case \"swap-letter\":\n            return `swap letter ${rule.a} with letter ${rule.b}`;\n        case \"rotate\":\n            return `rotate ${rule.direction} ${rule.steps} ${rule.steps === 1 ? \"step\" : \"steps\"}`;\n        case \"rotate-on\":\n            return `rotate based on position of letter ${rule.letter}`;\n        case \"reverse\":\n            return `reverse positions ${rule.from} through ${rule.to}`;\n        case \"move\":\n            return `move position ${rule.from} to position ${rule.to}`;\n    }\n};\n\nconst serialize = (rules: Rule[]): string[] => rules.map(serializeRule);\n\nconst parseLines = (lines: string[]): Rule[] => lines.map(parseLine);\n\nconst testInput: string[] = [\n    \"swap position 4 with position 0\",\n    \"swap letter d with letter b\",\n    \"reverse positions 0 through 4\",\n    \"rotate left 1 step\",\n    \"move position 1 to position 4\",\n    \"move position 3 to position 0\",\n    \"rotate based on position of letter b\",\n    \"rotate based on position of letter d\",\n];\n\nexport const scrambledLettersAndHash = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const parsed = parseLines(lines);\n        let input = \"abcdefgh\";\n        // let input = \"abcde\";\n        for (const rule of parsed) {\n            await outputCallback(input);\n            input = applyRule(input, rule);\n        }\n        await outputCallback(input);\n    },\n    async ({ lines, outputCallback }) => {\n        const target = \"fbgdceah\";\n        const parsed = parseLines(lines);\n        for (const permutation of permutationGenerator(target.split(\"\"))) {\n            const candidate = permutation.join(\"\");\n            const result = parsed.reduce((acc, next) => applyRule(acc, next), candidate);\n            if (result === target) {\n                await outputCallback(\"Found it!\");\n                await outputCallback(candidate);\n                return;\n            }\n        }\n        await outputCallback(\"I'm very sad :(\");\n        // await outputCallback(target.split(\"\").map((e,i) => i+1).reduce((acc, next) => acc * next))\n        // throw Error(\"Not implemented\");\n    },\n    { key: \"scrambled-letters-and-hash\", title: \"Scrambled Letters and Hash\", stars: 2}\n);\n","import { BinaryHeap } from \"priorityqueue/lib/cjs/BinaryHeap\";\nimport { PriorityQueue } from \"priorityqueue/lib/cjs/PriorityQueue\";\nimport { Queue } from \"../../../support/data-structure\";\nimport { CCoordinate, Coordinate, directionList, directions, getSurrounding, manhattanDistance } from \"../../../support/geometry\";\nimport { hexManhattanDistance } from \"../../../support/hex-geometry\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { entryForFile } from \"../../entry\";\n\ninterface Node {\n    c: Coordinate;\n    used: number;\n    available: number;\n}\n\ntype Field = FixedSizeMatrix<Node>;\n\ninterface FullField {\n    field: Field;\n    target: Coordinate;\n    steps: number;\n}\n\nconst parseLines = (lines: string[]): Node[] => {\n    const parseCoordinates = (token: string): Coordinate => {\n        const startFrom = token.indexOf(\"-\") + 1;\n        const [x, y] = token.substr(startFrom).split(\"-\").map((e) => parseInt(e.substr(1), 10));\n        return {x, y};\n    };\n    const parseSize = (token: string): number => parseInt(token.slice(0, -1), 10);\n    const parseLine = (line: string): Node | null => {\n        if (!line.includes(\"dev\")) {\n            return null;\n        }\n        const tokens = line.split(\" \").filter((e) => e);\n        return {\n            c: parseCoordinates(tokens[0]),\n            used: parseSize(tokens[2]),\n            available: parseSize(tokens[3])\n        };\n    };\n    return lines.map(parseLine).filter((l) => l !== null) as Node[];\n};\n\nconst createMatrix = (nodes: Node[]): Field => {\n    const size = {x: 0, y: 0};\n    for (const node of nodes) {\n        size.x = Math.max(size.x, node.c.x);\n        size.y = Math.max(size.y, node.c.y);\n    }\n    size.x++;\n    size.y++;\n    const matrix = new FixedSizeMatrix<Node>(size);\n    for (const node of nodes) {\n        matrix.set(node.c, node);\n    }\n    return matrix;\n};\n\nconst move = (fullField: FullField, from: Coordinate, to: Coordinate): FullField => {\n    const original = fullField.field;\n    const result = original.copy();\n    const fromNode = result.get(from);\n    const toNode = result.get(to);\n    if (!fromNode || !toNode) {\n        throw new Error(\"Node didn't exist\");\n    }\n    if (!isViable(fromNode, toNode)) {\n        throw new Error(\"Could not move\");\n    }\n    result.set(from, {...fromNode, used: 0, available: fromNode.used + fromNode.available});\n    result.set(to, {...toNode, used: toNode.used + fromNode.used, available: toNode.available - fromNode.used});\n    const target = manhattanDistance(fromNode.c, fullField.target) === 0 ? toNode.c : fullField.target;\n    return {...fullField, field: result, target};\n};\n\nconst getValidMoves = (fullField: FullField): Array<{from: Coordinate; to: Coordinate}> => {\n    const result: Array<{from: Coordinate; to: Coordinate}> = [];\n    fullField.field.onEveryCellSync((c, node) => {\n        if (node) {\n            if (node.used === 0) {\n                return;\n            }\n            const neighbours = getSurrounding(c)\n                .map((coords) => fullField.field.get(coords))\n                .filter((e) => e) as Node[];\n            for (const neighbour of neighbours) {\n                if (isViable(node, neighbour)) {\n                    result.push({from: node.c, to: neighbour.c});\n                }\n            }\n        }\n    });\n    return result;\n};\n\nconst isViable = (from: Node, to: Node): boolean => {\n    return from.used > 0 && from.used <= to.available;\n};\n\nconst serializer = (fullField: FullField): string => {\n    return fullField.field.toString((cell) => {\n        if (!cell) {\n            throw new Error(\"Invalid node\");\n        }\n        const neighbours = getSurrounding(cell.c);\n        if (cell.used === 0) {\n            return \"_\";\n        }\n        const canMove = neighbours\n            .map((e) => fullField.field.get(e))\n            .filter((e) => e)\n            .reduce((acc, next) => acc || isViable(cell, next!), false);\n        const isTarget = manhattanDistance(cell.c, fullField.target) === 0;\n        if (canMove) {\n            return isTarget ? \"G\" : \".\";\n        }\n        return isTarget ? \"g\" : \"#\";\n    });\n};\n\nconst fullSerializer = async (fullField: FullField): Promise<string> => {\n    const result: string[] = [`t:${fullField.target.x}.${fullField.target.y}`];\n    await fullField.field.onEveryCell((c, n) => {\n        if (n) {\n            result.push(`${c.x}.${c.y}.${n.used}.${n.available}`);\n        }\n    });\n    return result.join(\"|\");\n};\n\nclass FieldPQ extends BinaryHeap<FullField> {\n    constructor(myPosition: Coordinate) {\n        super({comparator: (a, b) => {\n            const targetDistance = manhattanDistance(a.target, myPosition) - manhattanDistance(b.target, myPosition);\n            if (targetDistance !== 0) {\n                return targetDistance;\n            }\n            const movablesA = getValidMoves(a)\n                .map((e) => ({move: e, distance: manhattanDistance(e.from, a.target)}))\n                .sort((x, y) => x.distance - y.distance)[0];\n            const movablesB = getValidMoves(b)\n                .map((e) => ({move: e, distance: manhattanDistance(e.from, b.target)}))\n                .sort((x, y) => x.distance - y.distance)[0];\n            if (!movablesA && !movablesB) {\n                return 0;\n            }\n            if (!movablesA) {\n                return 1;\n            }\n            return movablesA.distance - movablesB.distance;\n        }\n    });\n\n    }\n}\n\nconst mapInput = (command: string | null): CCoordinate | null => {\n    if (command === null) {\n        return null;\n    }\n    switch (command.toLowerCase()) {\n        case \"j\":\n            return directions.down;\n        case \"k\":\n            return directions.up;\n        case \"h\":\n            return directions.left;\n        case \"l\":\n            return directions.right;\n    }\n    return null;\n};\n\nexport const gridComputing = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const input = parseLines(lines);\n        let count = 0;\n        for (let i = 0; i < input.length; i++) {\n            for (let j = i + 1; j < input.length; j++) {\n                if (isViable(input[i], input[j]) || isViable(input[j], input[i])) {\n                    count++;\n                }\n            }\n        }\n        await outputCallback(count);\n    },\n    async ({ lines, outputCallback, additionalInputReader }) => {\n        if (!additionalInputReader) {\n            await outputCallback(\"Could not run the program, need additional input\");\n            return;\n        }\n        const myPosition = {x: 0, y: 0};\n        const matrix = createMatrix(parseLines(lines));\n        const target: Coordinate = {x: matrix.size.x - 1, y: 0};\n        let fullField = {field: matrix, target, steps: 0};\n        let currentPosition = matrix.findOne((node) => node.available > node.used);\n        if (!currentPosition) {\n            await outputCallback(\"Invalid input\");\n            return;\n        }\n\n        const oldCommands: CCoordinate[] = [];\n        const oldStates: Array<{field: FullField; position: Coordinate}> = [];\n        while (true) {\n            await outputCallback(null);\n            await outputCallback(serializer(fullField) + \"\\n\" + fullField.steps);\n            if (manhattanDistance(fullField.target, myPosition) === 0) {\n                await outputCallback(\"You've done it!\");\n                return;\n            }\n            // await outputCallback(fullField.steps);\n            let input: CCoordinate | null = null;\n            input = oldCommands.pop() || null;\n            if (input === null) {\n                const rawInput = await additionalInputReader.read();\n                if (rawInput === null) {\n                    await outputCallback(\"Closing down\");\n                    return;\n                }\n                if (rawInput === \"b\" && oldStates.length > 0) {\n                    const old = oldStates.pop()!;\n                    fullField = old.field;\n                    currentPosition = old.position;\n                    continue;\n                } else if (rawInput && rawInput.startsWith(\"loop\")) {\n                    const times = rawInput.includes(\"-\") ? parseInt(rawInput.split(\"-\")[1], 10) : 1;\n                    for (let i = 0; i < times; i++) {\n                        oldCommands.push(directions.up);\n                        oldCommands.push(directions.left);\n                        oldCommands.push(directions.left);\n                        oldCommands.push(directions.down);\n                        oldCommands.push(directions.right);\n                    }\n                    continue;\n                } else if (rawInput === \"start\") {\n                    for (let i = 0; i < 7; i++) {\n                        oldCommands.push(directions.right);\n                    }\n                    for (let i = 0; i < 20; i++) {\n                        oldCommands.push(directions.up);\n                    }\n                    for (let i = 0; i < 6; i++) {\n                        oldCommands.push(directions.left);\n                    }\n                    oldCommands.push(directions.up);\n                }\n                input = mapInput(rawInput);\n            }\n            if (!input) {\n                await outputCallback(\"Invalid command\");\n                continue;\n            }\n            const from = input.sum(currentPosition);\n            if (!from.isInBounds(matrix.size)) {\n                await outputCallback(\"Invalid direction\");\n                continue;\n            }\n            oldStates.push({field: fullField, position: currentPosition});\n            fullField = {...move(fullField, from, currentPosition), steps: fullField.steps + 1};\n            currentPosition = from;\n        }\n    },\n    { key: \"grid-computing\", title: \"Grid Computing\", hasAdditionalInput: true, stars: 2}\n);\n","import { factorial } from \"../../../support/algebra\";\nimport { setTimeoutAsync } from \"../../../support/async\";\nimport { entryForFile } from \"../../entry\";\nimport { emptyState, execute, parseProgram, prettyPrint } from \"./common/assembunny\";\n\nexport const safeCracking = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled  }) => {\n        const program = parseProgram(lines);\n        const state = emptyState();\n        state.registers.a = 7;\n        await execute(program, state, async (executingProgram, executingState) => {\n            await outputCallback(null);\n            await outputCallback(prettyPrint(executingState, executingProgram));\n            // await setTimeoutAsync(100);\n            await pause();\n            if (isCancelled && isCancelled()) {\n                return false;\n            }\n            return true;\n        });\n        await outputCallback(state.registers.a);\n    },\n    async ({ lines, outputCallback }) => {\n        const getValue = (ln: number): number => {\n            const v = parseInt(lines[ln].split(\" \")[1], 10);\n            return v;\n        };\n        const result = factorial(12) + getValue(19) * getValue(20);\n        await outputCallback(\"I'm not sure whether the solution is universal; it does work on my input\");\n        await outputCallback(result);\n    },\n    {\n        key: \"safe-cracking\",\n        title: \"Safe Cracking\",\n        stars: 2,\n        customComponent: \"pause-and-run\"\n    }\n);\n","import { Queue } from \"../../../support/data-structure\";\nimport { Coordinate, getSurrounding, manhattanDistance } from \"../../../support/geometry\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { entryForFile } from \"../../entry\";\n\ninterface Target {\n    type: string;\n    position: Coordinate;\n}\n\nconst parseLines = (lines: string[]):\n    { field: FixedSizeMatrix<\"#\" | \".\">; startPosition: Coordinate; targets: Target[] } => {\n\n    const size = {x: lines[0].length, y: lines.length};\n    const field = new FixedSizeMatrix<\"#\" | \".\">(size);\n    let startPosition: Coordinate | undefined;\n    const targets: Target[] = [];\n    for (let x = 0; x < size.x; x++) {\n        for (let y = 0; y < size.y; y++) {\n            const cell = lines[y][x];\n            if (cell === \".\" || cell === \"#\") {\n                field.set({x, y}, cell);\n            } else if (cell === \"0\") {\n                startPosition = {x, y};\n                field.set({x, y}, \".\");\n            } else {\n                targets.push({type: cell, position: {x, y}});\n                field.set({x, y}, \".\");\n            }\n        }\n    }\n    if (!startPosition) {\n        throw new Error(\"Start position not found\");\n    }\n    return {field, startPosition, targets};\n};\n\ninterface QueueElement {currentPosition: Coordinate; reachedTargets: string[]; steps: number; }\n\nconst serializeState = (state: QueueElement) => `${state.currentPosition.x}.${state.currentPosition.y}|${state.reachedTargets.join(\".\")}`;\n\nexport const airDuctSpelunking = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const {field, startPosition, targets} = parseLines(lines);\n\n        const outputField = new FixedSizeMatrix<\"#\" | \".\" | \"+\">(field.size);\n        await field.onEveryCell((e, c) => outputField.set(e, c));\n\n        const visitedStates = new Set<string>();\n        const queue = new Queue<QueueElement>();\n        const start: QueueElement = {currentPosition: startPosition, reachedTargets: [], steps: 0};\n        queue.add(start);\n        visitedStates.add(serializeState(start));\n        let bestReached = 0;\n        while (true) {\n            const current = queue.get();\n            if (!current) {\n                // await outputCallback(\"Failed\");\n                // await outputCallback(outputField.toString(e => e || \" \"));\n                return;\n            }\n            outputField.set(current.currentPosition, \"+\");\n            for (const candidate of getSurrounding(current.currentPosition)) {\n                const nextCell = field.get(candidate);\n                if (!nextCell || nextCell === \"#\") {\n                    continue;\n                }\n                const newSteps = current.steps + 1;\n                const newReached = [...current.reachedTargets];\n                const matchingTarget = targets.find((e) => manhattanDistance(e.position, candidate) === 0);\n                if (matchingTarget && !newReached.includes(matchingTarget.type)) {\n                    newReached.push(matchingTarget.type);\n                    if (newReached.length === targets.length) {\n                        await outputCallback(\"And here we are!\");\n                        await outputCallback(newSteps);\n                        return;\n                    }\n                    newReached.sort();\n                }\n                const queueElement: QueueElement = {\n                    currentPosition: candidate,\n                    reachedTargets: newReached,\n                    steps: newSteps\n                };\n                const state = serializeState(queueElement);\n                if (visitedStates.has(state)) {\n                    continue;\n                }\n                visitedStates.add(state);\n                if (newReached.length > bestReached) {\n                    await outputCallback(\"New best: \" + newReached.length);\n                    bestReached = newReached.length;\n                }\n                queue.add(queueElement);\n            }\n        }\n\n    },\n    async ({ lines, outputCallback }) => {\n        const {field, startPosition, targets} = parseLines(lines);\n\n        const outputField = new FixedSizeMatrix<\"#\" | \".\" | \"+\">(field.size);\n        await field.onEveryCell((e, c) => outputField.set(e, c));\n\n        const visitedStates = new Set<string>();\n        const queue = new Queue<QueueElement>();\n        const start: QueueElement = {currentPosition: startPosition, reachedTargets: [], steps: 0};\n        queue.add(start);\n        visitedStates.add(serializeState(start));\n        let bestReached = 0;\n        while (true) {\n            const current = queue.get();\n            if (!current) {\n                await outputCallback(\"Failed\");\n                return;\n            }\n            outputField.set(current.currentPosition, \"+\");\n            for (const candidate of getSurrounding(current.currentPosition)) {\n                const nextCell = field.get(candidate);\n                if (!nextCell || nextCell === \"#\") {\n                    continue;\n                }\n                const newSteps = current.steps + 1;\n                const newReached = [...current.reachedTargets];\n                const matchingTarget = targets.find((e) => manhattanDistance(e.position, candidate) === 0);\n                if (matchingTarget && !newReached.includes(matchingTarget.type)) {\n                    newReached.push(matchingTarget.type);\n                    newReached.sort();\n                }\n                if (newReached.length === targets.length) {\n                    if (manhattanDistance(candidate, startPosition) === 0) {\n                        await outputCallback(\"And here we are!\");\n                        await outputCallback(newSteps);\n                        return;\n                    }\n                }\n                const queueElement: QueueElement = {\n                    currentPosition: candidate,\n                    reachedTargets: newReached,\n                    steps: newSteps\n                };\n                const state = serializeState(queueElement);\n                if (visitedStates.has(state)) {\n                    continue;\n                }\n                visitedStates.add(state);\n                if (newReached.length > bestReached) {\n                    await outputCallback(\"New best: \" + newReached.length);\n                    bestReached = newReached.length;\n                }\n                queue.add(queueElement);\n            }\n        }\n    },\n    { key: \"air-duct-spelunking\", title: \"Air Duct Spelunking\", stars: 2}\n);\n","import { entryForFile } from \"../../entry\";\n\nexport const clockSignal = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const getValue = (ln: number): number => {\n            const v = parseInt(lines[ln].split(\" \")[1], 10);\n            return v;\n        };\n        const addition = getValue(2) * getValue(1);\n        const check = async (a: number): Promise<boolean> => {\n            if (a % 2 === 1) {\n                return false;\n            }\n            a += addition;\n            let last = 1;\n            while (a > 0) {\n                const out = a % 2;\n                if (out === last) {\n                    return false;\n                }\n                last = out;\n                a = Math.floor(a / 2);\n            }\n            return true;\n        };\n        let x = 1;\n        while (x < addition || x % 2 === 1) {\n            if (x % 2 === 0) {\n                x *= 2;\n                x += 1;\n            } else {\n                x *= 2;\n            }\n        }\n        await outputCallback(\"I'm not sure if it works for every input\");\n        await outputCallback(await check(x - addition));\n        await outputCallback(x - addition);\n\n    },\n    async ({ lines, outputCallback }) => {\n        throw Error(\"Not implemented\");\n    },\n    { key: \"clock-signal\", title: \"Clock Signal\", stars: 2}\n);\n","import { noTimeForATaxicab } from \"./no-time-for-a-taxicab\";\nimport { bathroomSecurity } from \"./bathroom-security\";\nimport { squaresWithThreeSides } from \"./squares-with-three-sides\";\nimport { securityThroughObscurity } from \"./security-through-obscurity\";\nimport { howAboutANiceGameOfChess } from \"./how-about-a-nice-game-of-chess\";\nimport { signalsAndNoise } from \"./signals-and-noise\";\nimport { internetProtocolVersion7 } from \"./internet-protocol-version-7\";\nimport { twoFactorAuthentication } from \"./two-factor-authentication\";\nimport { explosivesInCyberspace } from \"./explosives-in-cyberspace\";\nimport { balanceBots } from \"./balance-bots\";\nimport { radioisotopeThermoelectricGenerators } from \"./radioisotope-thermoelectric-generators\";\nimport { leonardosMonorail } from \"./leonardos-monorail\";\nimport { aMazeOfTwistyLittleCubicles } from \"./a-maze-of-twisty-little-cubicles\";\nimport { oneTimePad } from \"./one-time-pad\";\nimport { timingIsEverything } from \"./timing-is-everything\";\nimport { dragonChecksum } from \"./dragon-checksum\";\nimport { twoStepsForward } from \"./two-steps-forward\";\nimport { likeARogue } from \"./like-a-rogue\";\nimport { anElephantNamedJoseph } from \"./an-elephant-named-joseph\";\nimport { firewallRules } from \"./firewall-rules\";\nimport { scrambledLettersAndHash } from \"./scrambled-letters-and-hash\";\nimport { gridComputing } from \"./grid-computing\";\nimport { safeCracking } from \"./safe-cracking\";\nimport { airDuctSpelunking } from \"./air-duct-spelunking\";\nimport { clockSignal } from \"./clock-signal\";\n\nexport const entries = [\n        noTimeForATaxicab,\n        bathroomSecurity,\n        squaresWithThreeSides,\n        securityThroughObscurity,\n        howAboutANiceGameOfChess,\n        signalsAndNoise,\n        internetProtocolVersion7,\n        twoFactorAuthentication,\n        explosivesInCyberspace,\n        balanceBots,\n        radioisotopeThermoelectricGenerators,\n        leonardosMonorail,\n        aMazeOfTwistyLittleCubicles,\n        oneTimePad,\n        timingIsEverything,\n        dragonChecksum,\n        twoStepsForward,\n        likeARogue,\n        anElephantNamedJoseph,\n        firewallRules,\n        scrambledLettersAndHash,\n        gridComputing,\n        safeCracking,\n        airDuctSpelunking,\n        clockSignal\n];\n","import { entryForFile } from \"../../entry\";\r\nexport const aMazeOfTwistyTrampolinesAllAlike = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const instructions = lines.map((l) => parseInt(l, 10));\r\n        let ip = 0;\r\n        let i = 0;\r\n        while (ip >= 0 && ip < instructions.length) {\r\n            i++;\r\n            const delta = instructions[ip];\r\n            instructions[ip]++;\r\n            ip += delta;\r\n        }\r\n        await outputCallback(i);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const instructions = lines.map((l) => parseInt(l, 10));\r\n        let ip = 0;\r\n        let i = 0;\r\n        while (ip >= 0 && ip < instructions.length) {\r\n            i++;\r\n            const delta = instructions[ip];\r\n            if (delta >= 3) {\r\n                instructions[ip]--;\r\n            } else {\r\n                instructions[ip]++;\r\n            }\r\n            ip += delta;\r\n        }\r\n        await outputCallback(i);\r\n    },\r\n    { key: \"a-maze-of-twisty-trampolines-all-alike\", title: \"A Maze of Twisty Trampolines, All Alike\", stars: 2, }\r\n);\r\n\r\n\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { CCoordinate, Coordinate, directions, rotate, Rotation, manhattanDistance } from \"../../../support/geometry\";\r\nimport { NotImplementedError } from \"../../../support/error\";\r\nimport { groupBy } from \"../../../support/sequences\";\r\n\r\ntype Axis = \"horizontal\" | \"vertical\";\r\n\r\nfunction axisFromDirection(direction: CCoordinate) {\r\n    if ((direction.x !== 0) === (direction.y !== 0)) {\r\n        throw new Error(\"One and only one coordinate can be non zero in a direction\");\r\n    }\r\n    if (direction.x !== 0) {\r\n        return \"horizontal\";\r\n    }\r\n    return \"vertical\";\r\n}\r\n\r\nfunction expectedFromDirection(direction: CCoordinate) {\r\n    const axis = axisFromDirection(direction);\r\n    if (axis === \"horizontal\") {\r\n        return \"-\";\r\n    }\r\n    return \"|\";\r\n}\r\n\r\ninterface State {\r\n    position: Coordinate;\r\n    direction: CCoordinate;\r\n}\r\n\r\ntype Field = FixedSizeMatrix<string>;\r\n\r\ntype LetterCallback = (letter: string, direction: CCoordinate, coordinate: Coordinate) => void;\r\n\r\nfunction isLine(s: string) {\r\n    return s === \"|\" || s === \"-\";\r\n}\r\n\r\nfunction travel(field: Field, state: State, letterCallback: LetterCallback): State | null {\r\n    const direction = state.direction;\r\n    const expected = expectedFromDirection(direction);\r\n    const currentCell = field.get(state.position);\r\n    if (currentCell === undefined) {\r\n        return null;\r\n    }\r\n    const nextCoordinate = direction.sum(state.position);\r\n    const nextCell = field.get(nextCoordinate);\r\n    if (nextCell === \" \" || nextCell === undefined) {\r\n        return null;\r\n    } else if (isLine(nextCell)) {\r\n        return { ...state, position: nextCoordinate };\r\n    } else if (nextCell === \"+\") {\r\n        const rotations: Rotation[] = [\"Clockwise\", \"Counterclockwise\"];\r\n        const candidateDirections = rotations.map((rotation) => rotate(state.direction, rotation));\r\n        const resultStates = candidateDirections\r\n            .map((d) => ({ direction: d, state: travel(field, { position: nextCoordinate, direction }, () => { }) }))\r\n            .filter((result) => result.state !== null)\r\n            ;\r\n        if (resultStates.length !== 1) {\r\n            throw new Error(\"Invalid states :( \" + JSON.stringify(resultStates));\r\n        }\r\n        return { position: nextCoordinate, direction: resultStates[0].direction };\r\n\r\n    } else {\r\n        letterCallback(nextCell, direction, nextCoordinate);\r\n        return { ...state, position: nextCoordinate };\r\n    }\r\n}\r\n\r\nexport const aSeriesOfTubes = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        lines = lines.map((line) => line.trimEnd());\r\n        const maxLineSize = lines.reduce((acc, next) => acc + next.length, 0);\r\n        lines = lines.map((line) => line.padEnd(maxLineSize, \" \"));\r\n        const matrix: Field = new FixedSizeMatrix<string>({ x: maxLineSize, y: lines.length });\r\n        const flat = lines.map((l) => l.split(\"\")).flat();\r\n        matrix.setFlatData(flat);\r\n\r\n        const startingPoint = matrix.findOneWithCoordinate((cell, coordinate) => coordinate.y === 0 && cell === \"|\");\r\n        if (!startingPoint) {\r\n            throw new Error(\"Starting point not found!\");\r\n        }\r\n        await outputCallback(startingPoint);\r\n        let state: State | null = {\r\n            position: startingPoint,\r\n            direction: directions.down\r\n        };\r\n\r\n        const foundLetters: string[] = [];\r\n\r\n        while (state !== null) {\r\n            state = travel(matrix, state, (letter, direction, coordinate) => {\r\n                foundLetters.push(letter);\r\n                matrix.set(coordinate, expectedFromDirection(direction));\r\n            });\r\n        }\r\n\r\n        await outputCallback(foundLetters.join(\"\"));\r\n\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        lines = lines.map((line) => line.trimEnd());\r\n        const maxLineSize = lines.reduce((acc, next) => acc + next.length, 0);\r\n        lines = lines.map((line) => line.padEnd(maxLineSize, \" \"));\r\n        const matrix: Field = new FixedSizeMatrix<string>({ x: maxLineSize, y: lines.length });\r\n        const flat = lines.map((l) => l.split(\"\")).flat();\r\n        matrix.setFlatData(flat);\r\n\r\n        const startingPoint = matrix.findOneWithCoordinate((cell, coordinate) => coordinate.y === 0 && cell === \"|\");\r\n        if (!startingPoint) {\r\n            throw new Error(\"Starting point not found!\");\r\n        }\r\n        await outputCallback(startingPoint);\r\n        let state: State | null = {\r\n            position: startingPoint,\r\n            direction: directions.down\r\n        };\r\n\r\n        const foundLetters: string[] = [];\r\n\r\n        let lastPosition: Coordinate | null = null;\r\n        let count = 1;\r\n        while (state !== null) {\r\n            state = travel(matrix, state, (letter, direction, coordinate) => {\r\n                foundLetters.push(letter);\r\n                matrix.set(coordinate, expectedFromDirection(direction));\r\n            });\r\n            if (state != null && (lastPosition === null || manhattanDistance(state.position, lastPosition) !== 0)) {\r\n                count++;\r\n                lastPosition = state.position;\r\n            }\r\n        }\r\n\r\n        await outputCallback(count);\r\n    },\r\n    { key: \"a-series-of-tubes\", title: \"A Series of Tubes\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\nimport { Queue } from \"../../../support/data-structure\";\n\n// type Command = \"snd\" | \"set\" | \"add\" | \"mul\" | \"mod\" | \"rcv\" | \"jgz\";\ntype Command = \"set\" | \"sub\" | \"mul\" | \"jnz\";\n\ninterface Instruction {\n    command: Command;\n    args: string[];\n}\n\nconst parseLines = (lines: string[]): Instruction[] => {\n    return lines.map((line) => line.trim().split(\" \")).map((tokens) => {\n        return {\n            command: tokens[0] as Command,\n            args: tokens.slice(1)\n        };\n    });\n};\n\n// type SoundCallback = (frequency: number) => void;\n// type RecoverCallback = (() => void) | ReceiveCallback;\n// type ReceiveCallback = { receive: () => number | void };\n\n// function isReceive(e: RecoverCallback): e is ReceiveCallback {\n//     return (<ReceiveCallback>e).receive !== undefined;\n// }\n\ntype Registers = Map<string, number>;\n\nconst registerFactory = (): Registers => {\n    const map = new Map<string, number>();\n    [...Array(\"z\".charCodeAt(0) - \"a\".charCodeAt(0) + 1).keys()]\n        .map((index) => String.fromCharCode(\"a\".charCodeAt(0) + index))\n        .forEach((e) => map.set(e, 0));\n    return map;\n};\n\nconst getConstantOrRegister = (e: string, registers: Registers): number => {\n    if (registers.has(e)) {\n        return registers.get(e)!;\n    }\n    const value = parseInt(e, 10);\n    if (value.toString() === e) {\n        return value;\n    }\n    throw new Error(\"Invalid value: \" + e);\n};\n\ninterface Callbacks {\n    mulCallback?: () => void;\n    // soundCallback: SoundCallback,\n    // recoverCallback: RecoverCallback\n}\n\nconst executeInstruction = (\n    instruction: Instruction,\n    currentIndex: number,\n    registers: Registers,\n    callbacks?: Callbacks\n)\n    : [number, Registers] => {\n    const increasedIndex = currentIndex + 1;\n    const args = instruction.args;\n    const gcr = (index: number) => getConstantOrRegister(args[index], registers);\n    switch (instruction.command) {\n        case \"sub\":\n            registers.set(args[0], gcr(0) - gcr(1));\n            break;\n        // case \"add\":\n        //     registers.set(args[0], gcr(0) + gcr(1));\n        //     break;\n        // case \"jgz\":\n        //     if (gcr(0) > 0) {\n        //         return [currentIndex + gcr(1), registers];\n        //     }\n        //     break;\n        case \"jnz\":\n            if (gcr(0) !== 0) {\n                return [currentIndex + gcr(1), registers];\n            }\n            break;\n        // case \"mod\":\n        //     registers.set(args[0], gcr(0) % gcr(1));\n        //     break;\n        case \"mul\":\n            registers.set(args[0], gcr(0) * gcr(1));\n            if (callbacks && callbacks.mulCallback) {\n                callbacks.mulCallback();\n            }\n            break;\n        // case \"rcv\":\n        //     if (isReceive(callbacks.recoverCallback)) {\n        //         const result = callbacks.recoverCallback.receive();\n        //         if (result !== undefined) {\n        //             registers.set(args[0], result);\n        //         } else {\n        //             return [currentIndex, registers];\n        //         }\n        //     } else if (gcr(0) !== 0) {\n        //         callbacks.recoverCallback();\n        //     }\n        //     break;\n        case \"set\":\n            registers.set(args[0], gcr(1));\n            break;\n        // case \"snd\":\n        //     callbacks.soundCallback(gcr(0));\n        //     break;\n        default:\n            throw new Error(\"Could not execute instruction '\" + instruction.command + \"'\");\n    }\n    return [increasedIndex, registers];\n};\n\nexport const coprocessorConflagration = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const instructions = parseLines(lines);\n        let currentIndex = 0;\n        let registers = registerFactory();\n        let mulCount = 0;\n        while (currentIndex >= 0 && currentIndex < instructions.length) {\n            const instruction = instructions[currentIndex];\n            [currentIndex, registers] = executeInstruction(\n                instruction,\n                currentIndex,\n                registers,\n                {\n                    mulCallback: () => mulCount++\n                }\n            );\n        }\n        await outputCallback(mulCount);\n    },\n    async ({ lines, outputCallback }) => {\n        // disassembled:\n        // let b = (81 * 100) + 100000;\n        // let c = b + 17000\n        // //semantic\n        // let h = 0;\n        // //let b = 108100;\n        // //let c = b + 17000;\n        // while (b !== c + 17) {\n        //     if (!isPrime(b)) {\n        //         h++;\n        //     }\n        //     b += 17;\n        // }\n\n        const isPrime = (e: number) => {\n            for (let i = 2; i * i <= e; i++) {\n                if (e % i === 0) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        let b = (81 * 100) + 100000;\n        const c = b + 17000;\n        let h = 0;\n        while (b !== c + 17) {\n            if (!isPrime(b)) {\n                h++;\n            }\n            b += 17;\n        }\n\n        await outputCallback(h);\n    },\n    { key: \"coprocessor-conflagration\", title: \"Coprocessor Conflagration\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\n\nfunction parseLines(lines: string[]): number[][] {\n    return lines\n        .map((l) => l.trim())\n        .map((line) => line.split(\"\\t\").map((token) => parseInt(token, 10)))\n    ;\n}\n\nexport const corruptionChecksum = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const sequence = parseLines(lines);\n        const checksum = sequence.map((row) => {\n            const max = row.reduce((acc, next) => Math.max(acc, next));\n            const min = row.reduce((acc, next) => Math.min(acc, next));\n            return max - min;\n        }).reduce((acc, next) => acc + next);\n        await outputCallback(checksum);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const sequence = parseLines(lines);\n        const checksum = sequence.map((row) => {\n            const internalChecksum = row.map((small) => {\n                const candidates = row.filter((big) => big > small && big % small === 0);\n                if (candidates.length === 0) {\n                    return null;\n                } else if (candidates.length !== 1) {\n                    throw new Error(\"Multiple candidates found for \" + small + \": \" + JSON.stringify(candidates));\n                }\n                return candidates[0] / small;\n            }).filter((e) => e !== null).map((e) => e!);\n            if (internalChecksum.length !== 1) {\n                throw new Error(\"Multiple candidates found for internal: \" + JSON.stringify(internalChecksum));\n            }\n            return internalChecksum[0];\n        }).reduce((acc, next) => acc + next);\n        await outputCallback(checksum);\n\n    },\n    { key: \"corruption-checksum\", title: \"Corruption Checksum\", stars: 2, }\n);\n\n","import { entryForFile } from \"../../entry\";\r\nimport { Stack } from \"linq-typescript\";\r\n\r\nconst parseLines = (lines: string[]): PipeDefinition[] => {\r\n    return lines.map((line) => {\r\n        const [sourceToken, targetToken] = line.split(\" <-> \");\r\n        const source = parseInt(sourceToken, 10);\r\n        const targets = targetToken.split(\", \").map((e) => parseInt(e, 10));\r\n        return { source, targets };\r\n    });\r\n};\r\n\r\ninterface PipeDefinition {\r\n    source: number;\r\n    targets: number[];\r\n}\r\n\r\nclass Graph {\r\n    private readonly _map = new Map<number, Set<number>>();\r\n\r\n    public addLink(source: number, target: number) {\r\n        this.ensureLink(source, target);\r\n        this.ensureLink(target, source);\r\n    }\r\n\r\n    public addDefinition(pipeDefinition: PipeDefinition) {\r\n        pipeDefinition.targets.forEach((target) => this.addLink(pipeDefinition.source, target));\r\n    }\r\n\r\n    public addDefinitions(pipeDefinitions: PipeDefinition[]) {\r\n        pipeDefinitions.forEach((definition) => this.addDefinition(definition));\r\n    }\r\n\r\n    public getNodes(): number[] {\r\n        return [...this._map.keys()];\r\n    }\r\n\r\n    public dfs(start: number, callback: (arg: number) => void) {\r\n        const stack = new Stack<number>();\r\n        const visited = new Set<number>();\r\n        stack.push(start);\r\n        while (true) {\r\n            const toVisit = stack.pop();\r\n            if (toVisit === undefined) {\r\n                break;\r\n            }\r\n            if (visited.has(toVisit)) {\r\n                continue;\r\n            }\r\n            visited.add(toVisit);\r\n            callback(toVisit);\r\n            const linked = this.getLinked(toVisit);\r\n            linked.forEach((e) => stack.push(e));\r\n        }\r\n    }\r\n\r\n    private getLinked(source: number): number[] {\r\n        const adjacency = this._map.get(source);\r\n        if (!adjacency) {\r\n            return [];\r\n        }\r\n        return [...adjacency.values()];\r\n    }\r\n\r\n    private ensureLink(source: number, target: number) {\r\n        let adjacency = this._map.get(source);\r\n        if (adjacency === undefined) {\r\n            adjacency = new Set<number>();\r\n            this._map.set(source, adjacency);\r\n        }\r\n        adjacency.add(target);\r\n    }\r\n}\r\n\r\nexport const digitalPlumber = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const definitions = parseLines(lines);\r\n        const graph = new Graph();\r\n        graph.addDefinitions(definitions);\r\n        let count = 0;\r\n        graph.dfs(0, (e) => count++);\r\n        await outputCallback(count);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const definitions = parseLines(lines);\r\n        const graph = new Graph();\r\n        graph.addDefinitions(definitions);\r\n        const visited = new Set<number>();\r\n        let count = 0;\r\n        const stack = new Stack<number>(graph.getNodes());\r\n        while (true) {\r\n            const next = stack.pop();\r\n            if (next === undefined) {\r\n                break;\r\n            }\r\n            if (visited.has(next)) {\r\n                continue;\r\n            }\r\n            count++;\r\n            graph.dfs(next, (e) => visited.add(e));\r\n        }\r\n        await outputCallback(count);\r\n    },\r\n    { key: \"digital-plumber\", title: \"Digital Plumber\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { groupBy } from \"../../../support/sequences\";\r\n\r\nconst reverseWrap = (elements: number[], state: State, length: number): number[] => {\r\n    const startPortionLength = state.currentIndex + length - elements.length;\r\n    const reversePortion = [\r\n        elements.slice(state.currentIndex),\r\n        elements.slice(0, startPortionLength)\r\n    ].flatMap((e) => e).reverse();\r\n    return [\r\n        reversePortion.slice(reversePortion.length - startPortionLength),\r\n        elements.slice(startPortionLength, state.currentIndex),\r\n        reversePortion.slice(0, reversePortion.length - startPortionLength)\r\n    ].flatMap((e) => e);\r\n};\r\nconst reverseSimple = (elements: number[], state: State, length: number): number[] => {\r\n    return [\r\n        elements.slice(0, state.currentIndex),\r\n        elements.slice(state.currentIndex, state.currentIndex + length).reverse(),\r\n        elements.slice(state.currentIndex + length)\r\n    ].flatMap((e) => e);\r\n\r\n};\r\n\r\nexport const reverse = (elements: number[], state: State, length: number): [number[], State] => {\r\n    if (state.currentIndex + length > elements.length) {\r\n        elements = reverseWrap(elements, state, length);\r\n    } else {\r\n        elements = reverseSimple(elements, state, length);\r\n    }\r\n    return [\r\n        elements,\r\n        {\r\n            currentIndex: (state.currentIndex + length + state.skipSize) % elements.length,\r\n            skipSize: (state.skipSize + 1) % elements.length\r\n        }\r\n    ];\r\n};\r\n\r\nexport const circleGenerator = (n: number = 256): [number[], State] => {\r\n    return [[...Array(n).keys()], {\r\n        currentIndex: 0,\r\n        skipSize: 0\r\n    }];\r\n};\r\n\r\ninterface State {\r\n    currentIndex: number;\r\n    skipSize: number;\r\n}\r\n\r\nexport const knotHash = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const lengths = lines[0].split(\",\").map((e) => parseInt(e, 10));\r\n        let [circle, state] = circleGenerator();\r\n        lengths.forEach((length) => {\r\n            [circle, state] = reverse(circle, state, length);\r\n        });\r\n        await outputCallback(circle[0] * circle[1]);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const input = lines[0];\r\n        const result = calculateKnotHash(input);\r\n        await outputCallback(result);\r\n    },\r\n    { key: \"knoth-hash\", title: \"Knot Hash\", stars: 2, }\r\n);\r\n\r\nexport function calculateKnotHash(input: string, baseSequence: (number[] | null) = null) {\r\n    if (baseSequence === null) {\r\n        baseSequence = [17, 31, 73, 47, 23];\r\n    }\r\n    const decodedInput = [...input].map((e) => e.charCodeAt(0));\r\n    const lengths = decodedInput.concat(baseSequence);\r\n    let [circle, state] = circleGenerator();\r\n    for (let i = 0; i < 64; i++) {\r\n        lengths.forEach((length) => {\r\n            [circle, state] = reverse(circle, state, length);\r\n        });\r\n    }\r\n    const result = groupBy(circle, 16)\r\n        .map((group) => group.reduce((acc, next) => acc ^ next))\r\n        .map((res) => res.toString(16).padStart(2, \"0\"))\r\n        .join(\"\");\r\n    return result;\r\n}\r\n","import { entryForFile } from \"../../entry\";\r\nimport { groupBy } from \"../../../support/sequences\";\r\nimport { calculateKnotHash } from \"./knot-hash\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { Coordinate, getSurrounding } from \"../../../support/geometry\";\r\nimport { NotImplementedError } from \"../../../support/error\";\r\nimport { Stack } from \"linq-typescript\";\r\n\r\ntype Binary = 0 | 1;\r\n\r\ntype Disk = Binary[][];\r\n\r\nconst hexStringToBits = (s: string): Binary[] => {\r\n    return [...s]\r\n        .map((e) => parseInt(e, 16))\r\n        .map((e) => e.toString(2).padStart(4, \"0\"))\r\n        .flatMap((e) => e.split(\"\"))\r\n        .map((e) => parseInt(e, 10) as Binary);\r\n};\r\n\r\nexport const diskDefragmentation = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const key = lines[0].trim();\r\n        const bits = generateDisk(key);\r\n        await outputCallback(bits.map((row) => row.join(\"\")).join(\"\\n\"));\r\n        const setBitsCount = bits.flatMap((e) => e).filter((e) => e === 1).length;\r\n        await outputCallback(setBitsCount);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const key = lines[0].trim();\r\n        const disk = generateDisk(key);\r\n        const diskMatrix = new FixedSizeMatrix<Binary>({x: 128, y: 128});\r\n        diskMatrix.setFlatData(disk.flat());\r\n        let regionCount = 0;\r\n        diskMatrix.onEveryCell((coordinate, value) => {\r\n            if (value === 1) {\r\n                regionCount++;\r\n                emptyRegion(diskMatrix, coordinate);\r\n            }\r\n        });\r\n        await outputCallback(regionCount);\r\n    },\r\n    { key: \"disk-defragmentation\", title: \"Disk Defragmentation\", stars: 2, }\r\n);\r\n\r\nfunction emptyRegion(matrix: FixedSizeMatrix<Binary>, coordinate: Coordinate) {\r\n    const stack = new Stack<Coordinate>();\r\n    stack.push(coordinate);\r\n    while (true) {\r\n        const nextCoordinate = stack.pop();\r\n        if (nextCoordinate === undefined) {\r\n            break;\r\n        }\r\n        matrix.set(nextCoordinate, 0);\r\n        getSurrounding(nextCoordinate).filter((e) => matrix.get(e) === 1).forEach((e) => stack.push(e));\r\n    }\r\n}\r\n\r\nfunction generateDisk(key: string): Disk {\r\n    const generatedLines = [...Array(128).keys()].map((index) => `${key}-${index}`);\r\n    const hashes = generatedLines.map((e) => calculateKnotHash(e));\r\n    const bits = hashes.map(hexStringToBits);\r\n    return bits;\r\n}\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nclass Generator {\r\n    private last: number;\r\n    constructor(\r\n        private readonly seed: number,\r\n        private readonly factor: number,\r\n        private readonly filter?: (e: number) => boolean\r\n    ) {\r\n        this.last = seed;\r\n    }\r\n\r\n    public getNext(): number {\r\n        do {\r\n            this.last = (this.last * this.factor) % 2147483647;\r\n        } while (this.filter && !this.filter(this.last));\r\n\r\n        return this.last;\r\n    }\r\n}\r\n\r\nfunction parseLines(lines: string[]): [number, number] {\r\n    const [a, b] = lines\r\n        .map((line) => line.trim())\r\n        .filter((line) => line)\r\n        .map((line) => line.split(\" \")[4])\r\n        .map((e) => parseInt(e, 10));\r\n    return [a, b];\r\n}\r\n\r\nexport const duelingGenerators = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const [seedA, seedB] = parseLines(lines);\r\n        const factorA = 16807;\r\n        const factorB = 48271;\r\n        const generators = [\r\n            new Generator(seedA, factorA),\r\n            new Generator(seedB, factorB)\r\n        ];\r\n        let count = 0;\r\n\r\n        const total = 40 * (10 ** 6);\r\n\r\n        for (let i = 0; i < total; i++) {\r\n            if (i % 100000 === 0) {\r\n                await outputCallback(`${i / total * 100}% done`);\r\n            }\r\n            const values = generators.map((generator) => generator.getNext());\r\n            const mapped = values.map((value) => [...value.toString(2)].reverse().slice(0, 16).join(\"\"));\r\n            const same = mapped.reduce((acc, next) => acc === next ? acc : \"\");\r\n            if (same !== \"\") {\r\n                count++;\r\n            }\r\n        }\r\n        await outputCallback(count);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const [seedA, seedB] = parseLines(lines);\r\n        const factorA = 16807;\r\n        const factorB = 48271;\r\n        const generators = [\r\n            new Generator(seedA, factorA, (e) => e % 4 === 0),\r\n            new Generator(seedB, factorB, (e) => e % 8 === 0)\r\n        ];\r\n        let count = 0;\r\n\r\n        const total = 5 * (10 ** 6);\r\n\r\n        for (let i = 0; i < total; i++) {\r\n            if (i % 100000 === 0) {\r\n                await outputCallback(`${i / total * 100}% done`);\r\n            }\r\n            const values = generators.map((generator) => generator.getNext());\r\n            const mapped = values.map((value) => [...value.toString(2)].reverse().slice(0, 16).join(\"\"));\r\n            const same = mapped.reduce((acc, next) => acc === next ? acc : \"\");\r\n            if (same !== \"\") {\r\n                count++;\r\n            }\r\n        }\r\n        await outputCallback(count);\r\n    },\r\n    { key: \"dueling-generators\", title: \"Dueling Generators\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { Queue } from \"../../../support/data-structure\";\r\n\r\ntype Command = \"snd\" | \"set\" | \"add\" | \"mul\" | \"mod\" | \"rcv\" | \"jgz\";\r\n\r\ninterface Instruction {\r\n    command: Command;\r\n    args: string[];\r\n}\r\n\r\nconst parseLines = (lines: string[]): Instruction[] => {\r\n    return lines.map((line) => line.trim().split(\" \")).map((tokens) => {\r\n        return {\r\n            command: tokens[0] as Command,\r\n            args: tokens.slice(1)\r\n        };\r\n    });\r\n};\r\n\r\ntype SoundCallback = (frequency: number) => void;\r\ntype RecoverCallback = (() => void) | ReceiveCallback;\r\ninterface ReceiveCallback {receive: () => number | void; }\r\n\r\nfunction isReceive(e: RecoverCallback): e is ReceiveCallback {\r\n    return (e as ReceiveCallback).receive !== undefined;\r\n}\r\n\r\ntype Registers = Map<string, number>;\r\n\r\nconst registerFactory = (): Registers => {\r\n    const map = new Map<string, number>();\r\n    [...Array(\"z\".charCodeAt(0) - \"a\".charCodeAt(0) + 1).keys()]\r\n        .map((index) => String.fromCharCode(\"a\".charCodeAt(0) + index))\r\n        .forEach((e) => map.set(e, 0));\r\n    return map;\r\n};\r\n\r\nconst getConstantOrRegister = (e: string, registers: Registers): number => {\r\n    if (registers.has(e)) {\r\n        return registers.get(e)!;\r\n    }\r\n    const value = parseInt(e, 10);\r\n    if (value.toString() === e) {\r\n        return value;\r\n    }\r\n    throw new Error(\"Invalid value: \" + e);\r\n};\r\n\r\ninterface Callbacks {\r\n    soundCallback: SoundCallback;\r\n    recoverCallback: RecoverCallback;\r\n}\r\n\r\nconst executeInstruction = (\r\n    instruction: Instruction,\r\n    currentIndex: number,\r\n    registers: Registers,\r\n    callbacks: Callbacks\r\n)\r\n    : [number, Registers] => {\r\n        const increasedIndex = currentIndex + 1;\r\n        const args = instruction.args;\r\n        const gcr = (index: number) => getConstantOrRegister(args[index], registers);\r\n        switch (instruction.command) {\r\n            case \"add\":\r\n                registers.set(args[0], gcr(0) + gcr(1));\r\n                break;\r\n            case \"jgz\":\r\n                if (gcr(0) > 0) {\r\n                    return [currentIndex + gcr(1), registers];\r\n                }\r\n                break;\r\n            case \"mod\":\r\n                registers.set(args[0], gcr(0) % gcr(1));\r\n                break;\r\n            case \"mul\":\r\n                registers.set(args[0], gcr(0) * gcr(1));\r\n                break;\r\n            case \"rcv\":\r\n                if (isReceive(callbacks.recoverCallback)) {\r\n                    const result = callbacks.recoverCallback.receive();\r\n                    if (result !== undefined) {\r\n                        registers.set(args[0], result);\r\n                    } else {\r\n                        return [currentIndex, registers];\r\n                    }\r\n                } else if (gcr(0) !== 0) {\r\n                    callbacks.recoverCallback();\r\n                }\r\n                break;\r\n            case \"set\":\r\n                registers.set(args[0], gcr(1));\r\n                break;\r\n            case \"snd\":\r\n                callbacks.soundCallback(gcr(0));\r\n                break;\r\n            default:\r\n                throw new Error(\"Could not execute instruction '\" + instruction.command + \"'\");\r\n        }\r\n        return [increasedIndex, registers];\r\n};\r\n\r\nexport const duet = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const instructions = parseLines(lines);\r\n        let currentIndex = 0;\r\n        let registers = registerFactory();\r\n        let lastSound = 0;\r\n        let hasRecovered = false;\r\n        while (currentIndex >= 0 && currentIndex < instructions.length && !hasRecovered) {\r\n            const instruction = instructions[currentIndex];\r\n            [currentIndex, registers] = executeInstruction(\r\n                instruction,\r\n                currentIndex,\r\n                registers,\r\n                {\r\n                    soundCallback: (sound) => lastSound = sound,\r\n                    recoverCallback: () => hasRecovered = true\r\n                }\r\n            );\r\n        }\r\n        await outputCallback({hasRecovered, lastSound});\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const instructions = parseLines(lines);\r\n        let aIndex = 0;\r\n        let bIndex = 0;\r\n        let aRegisters = registerFactory();\r\n        let bRegisters = registerFactory();\r\n        bRegisters.set(\"p\", 1);\r\n        const a2bPipe: Queue<number> = new Queue<number>();\r\n        const b2aPipe: Queue<number> = new Queue<number>();\r\n        let isAWaiting = false;\r\n        let isBWaiting = false;\r\n        let hasAEnded = false;\r\n        let hasBEnded = false;\r\n\r\n        let counter = 0;\r\n\r\n        while (!hasAEnded || !hasBEnded) {\r\n            if (!hasAEnded) {\r\n                [aIndex, aRegisters] = executeInstruction(\r\n                    instructions[aIndex],\r\n                    aIndex,\r\n                    aRegisters,\r\n                    {\r\n                        soundCallback: (n: number) => a2bPipe.add(n),\r\n                        recoverCallback: {receive: () => {\r\n                            isAWaiting = true;\r\n                            if (!b2aPipe.isEmpty) {\r\n                                isAWaiting = false;\r\n                                return b2aPipe.get()!;\r\n                            }\r\n                        }}\r\n                    }\r\n                );\r\n            }\r\n            if (!hasBEnded) {\r\n                [bIndex, bRegisters] = executeInstruction(\r\n                    instructions[bIndex],\r\n                    bIndex,\r\n                    bRegisters,\r\n                    {\r\n                        soundCallback: (n: number) => {\r\n                            b2aPipe.add(n);\r\n                            counter++;\r\n                        },\r\n                        recoverCallback: {receive: () => {\r\n                            isBWaiting = true;\r\n                            if (!a2bPipe.isEmpty) {\r\n                                isBWaiting = false;\r\n                                return a2bPipe.get()!;\r\n                            }\r\n                        }}\r\n                    }\r\n                );\r\n            }\r\n            if ((isAWaiting || hasAEnded) && (isBWaiting || hasBEnded)) {\r\n                hasAEnded = true;\r\n                hasBEnded = true;\r\n            }\r\n            if (aIndex < 0 || aIndex >= instructions.length) {\r\n                hasAEnded = true;\r\n            }\r\n            if (bIndex < 0 || bIndex >= instructions.length) {\r\n                hasBEnded = true;\r\n            }\r\n        }\r\n        await outputCallback(counter);\r\n    },\r\n    { key: \"duet\", title: \"Duet\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\n\ninterface BridgeComponent {\n    ports: [number, number];\n}\n\ntype Bridge = BridgeComponent[];\n\nconst parse = (lines: string[]): BridgeComponent[] => {\n    return lines.map((line) => {\n        const [a, b] = line.split(\"/\").map((e) => parseInt(e, 10));\n        return {\n            ports: [a, b]\n        };\n    });\n};\n\nconst findStrongestBridge = (nextPort: number, components: BridgeComponent[]): number => {\n    const candidates = components.filter((component) => component.ports.indexOf(nextPort) >= 0);\n    if (candidates.length === 0) {\n        return 0;\n    } else {\n        return candidates.reduce((acc: number, candidate: BridgeComponent) => {\n            const remainingComponents = components.filter((e) => e !== candidate);\n            const freePort = candidate.ports[0] === nextPort ? candidate.ports[1] : candidate.ports[0];\n            return Math.max(\n                candidate.ports[0] +\n                candidate.ports[1] +\n                findStrongestBridge(freePort, remainingComponents),\n                acc\n            );\n        }, 0);\n    }\n};\n\nconst createAllBridges = (nextPort: number, components: BridgeComponent[]): Bridge[] => {\n    const candidates = components.filter((bridge) => bridge.ports.indexOf(nextPort) >= 0);\n    if (candidates.length === 0) {\n        return [];\n    } else {\n        return candidates.flatMap((candidate) => {\n            const remainingComponents = components.filter((e) => e !== candidate);\n            const freePort = candidate.ports[0] === nextPort ? candidate.ports[1] : candidate.ports[0];\n            const recursiveBridges = createAllBridges(freePort, remainingComponents);\n            if (recursiveBridges.length === 0) {\n                return [[candidate]];\n            }\n            const result = recursiveBridges.map((tail) => [...tail, candidate]);\n            return result;\n        });\n    }\n};\n\nexport const electromagneticMoat = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const bridges = parse(lines);\n        const value = findStrongestBridge(0, bridges);\n        await outputCallback(value);\n    },\n    async ({ lines, outputCallback }) => {\n        const components = parse(lines);\n        const bridges = createAllBridges(0, components);\n        const maxLength = bridges.map((bridge) => bridge.length).reduce((acc, next) => Math.max(acc, next));\n        const interestingBridges = bridges.filter((bridge) => bridge.length === maxLength);\n        const bridgesWithCounts = interestingBridges.map((bridge) => ({\n            bridge,\n            score: bridge.reduce((acc, next) => acc + next.ports[0] + next.ports[1], 0)\n        }));\n        const bestBridge = bridgesWithCounts.reduce((acc, next) => {\n            if (acc.score < next.score) {\n                return next;\n            }\n            return acc;\n        });\n        await outputCallback(bestBridge.score);\n    },\n    { key: \"electromagnetic-moat\", title: \"Electromagnetic Moat\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { manhattanDistance, Coordinate, CCoordinate } from \"../../../support/geometry\";\r\n\r\ntype Grid = FixedSizeMatrix<string>;\r\n\r\nconst flipHorizontal = (matrix: Grid): Grid => {\r\n    const newGrid: Grid = new FixedSizeMatrix<string>(matrix.size);\r\n    matrix.onEveryCell((coordinate, cell) => {\r\n        newGrid.set({y: coordinate.y, x: matrix.size.x - coordinate.x - 1}, cell!);\r\n    });\r\n    return newGrid;\r\n};\r\n\r\nconst generateAllSymmetries = (matrix: Grid): Grid[] => {\r\n    const result = [];\r\n    result.push(matrix.copy());\r\n    for (let i = 0; i < 4; i++) {\r\n        matrix = flipHorizontal(matrix);\r\n        result.push(matrix);\r\n        matrix = transpose(matrix);\r\n        result.push(matrix);\r\n    }\r\n    return result;\r\n};\r\n\r\nconst matches = (matrix: Grid, symmetries: Grid[]): boolean => {\r\n    if (manhattanDistance(matrix.size, symmetries[0].size) !== 0) {\r\n        return false;\r\n    }\r\n    for (const symmetry of symmetries) {\r\n        if (matrix.isSameAs(symmetry)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\ninterface GridWithDelta {\r\n    grid: Grid;\r\n    delta: Coordinate;\r\n}\r\n\r\nconst extractGrid = (grid: Grid, offset: Coordinate, size: Coordinate): Grid => {\r\n    const gridResult = new FixedSizeMatrix<string>(size);\r\n    const cOffset = new CCoordinate(offset.x, offset.y);\r\n    for (let x = 0; x < size.x; x++) {\r\n        for (let y = 0; y < size.y; y++) {\r\n            gridResult.set({x, y}, grid.get(cOffset.sum({x, y}))!);\r\n        }\r\n    }\r\n    return gridResult;\r\n};\r\n\r\nconst splitWithDelta = (fullGrid: Grid): GridWithDelta[] => {\r\n    const size = fullGrid.size.x % 2 === 0 ? 2 : 3;\r\n    const result: GridWithDelta[] = [];\r\n    for (let x = 0; x < fullGrid.size.x; x += size) {\r\n        for (let y = 0; y < fullGrid.size.y; y += size) {\r\n            const subGrid = extractGrid(fullGrid, {x, y}, {x: size, y: size});\r\n            result.push({\r\n                grid: subGrid,\r\n                delta: {x: x / size, y: y / size}\r\n            });\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nconst joinDeltas = (deltas: GridWithDelta[]): Grid => {\r\n    const subSize = deltas[0].grid.size.x;\r\n    const maxX = deltas.map((d) => d.delta.x).reduce((acc, next) => Math.max(acc, next));\r\n    const size = subSize * (maxX + 1);\r\n    const resultGrid = new FixedSizeMatrix<string>({x: size, y: size});\r\n    deltas.forEach((subGrid) => {\r\n        subGrid.grid.onEveryCell((coordinate, cell) => {\r\n            const setCoordinate = {\r\n                x: coordinate.x + subGrid.delta.x * subSize,\r\n                y: coordinate.y + subGrid.delta.y * subSize,\r\n\r\n            };\r\n            if (resultGrid.get(setCoordinate) !== undefined) {\r\n                throw new Error(\"Join is overwriting data\");\r\n            }\r\n            resultGrid.set(setCoordinate, cell!);\r\n        });\r\n    });\r\n    return resultGrid;\r\n};\r\nconst transpose = (matrix: Grid): Grid => {\r\n    const result = new FixedSizeMatrix<string>(matrix.size);\r\n    matrix.onEveryCell((coordinate, cell) => {\r\n        result.set({x: coordinate.y, y: coordinate.x}, cell!);\r\n    });\r\n    return result;\r\n};\r\n\r\ninterface Rule {\r\n    matching: Grid[];\r\n    result: Grid;\r\n}\r\n\r\nconst parseRules = (lines: string[]): Rule[] => {\r\n    return lines.map((line) => line.trim()).filter((line) => line.length > 0).map((line) => {\r\n        const [left, right] = line.trim().split(\" => \");\r\n        const leftFlat = left.split(\"\").filter((e) => e !== \"/\");\r\n        const rightFlat = right.split(\"\").filter((e) => e !== \"/\");\r\n        const leftSize = Math.sqrt(leftFlat.length);\r\n        const rightSize = Math.sqrt(rightFlat.length);\r\n        const baseRuleMatch = new FixedSizeMatrix<string>({x: leftSize, y: leftSize});\r\n        baseRuleMatch.setFlatData(leftFlat);\r\n        const rightGrid = new FixedSizeMatrix<string>({x: rightSize, y: rightSize});\r\n        rightGrid.setFlatData(rightFlat);\r\n        return {\r\n            matching: generateAllSymmetries(baseRuleMatch),\r\n            result: rightGrid\r\n        };\r\n    });\r\n};\r\n\r\nconst iterate = (grid: Grid, rules: Rule[]): Grid => {\r\n    const splitGrids = splitWithDelta(grid);\r\n    const mappedGrids: GridWithDelta[] = splitGrids.map((subGrid) => {\r\n        for (const rule of rules) {\r\n            if (matches(subGrid.grid, rule.matching)) {\r\n                return {\r\n                    ...subGrid,\r\n                    grid: rule.result\r\n                };\r\n            }\r\n        }\r\n        throw new Error(\"No rule matched\");\r\n    });\r\n    return joinDeltas(mappedGrids);\r\n};\r\n\r\nexport const fractalArt = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const startGrid = new FixedSizeMatrix<string>({x: 3, y: 3});\r\n        startGrid.setFlatData(\".#...####\".split(\"\"));\r\n        const rules = parseRules(lines);\r\n        const sizes = [];\r\n        const total = 5;\r\n        let grid = startGrid;\r\n        sizes.push(grid.size.x);\r\n        for (let i = 0; i < total; i++) {\r\n            grid = iterate(grid, rules);\r\n            sizes.push(grid.size.x);\r\n        }\r\n        await outputCallback(grid.toString((e) => e || \" \"));\r\n        await outputCallback(grid.data.filter((e) => e === \"#\").length);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const startGrid = new FixedSizeMatrix<string>({x: 3, y: 3});\r\n        startGrid.setFlatData(\".#...####\".split(\"\"));\r\n        const rules = parseRules(lines);\r\n        const sizes = [];\r\n        const total = 18;\r\n        let grid = startGrid;\r\n        sizes.push(grid.size.x);\r\n        for (let i = 0; i < total; i++) {\r\n            await outputCallback(\"Iteration: \" + i);\r\n            grid = iterate(grid, rules);\r\n            sizes.push(grid.size.x);\r\n        }\r\n        await outputCallback(grid.data.filter((e) => e === \"#\").length);\r\n    },\r\n    { key: \"fractal-art\", title: \"Fractal Art\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { DefaultListDictionaryString } from \"../../../support/data-structure\";\r\ntype Operation = \"inc\" | \"dec\";\r\ntype Operator = \">\" | \"<\" | \">=\" | \"<=\" | \"==\" | \"!=\";\r\ninterface Condition {\r\n    left: string;\r\n    operator: Operator;\r\n    right: number;\r\n}\r\n\r\ninterface Action {\r\n    target: string;\r\n    operation: Operation;\r\n    amount: number;\r\n}\r\ninterface Instruction {\r\n    action: Action;\r\n    condition: Condition;\r\n}\r\nclass RegisterState {\r\n\r\n    public currentMax: number = Number.NEGATIVE_INFINITY;\r\n    private readonly state = new Map<string, number>();\r\n\r\n    public update(register: string, calc: (v: number) => number) {\r\n        const existing = this.state.get(register) || 0;\r\n        const newValue = calc(existing);\r\n        this.currentMax = Math.max(this.currentMax, newValue);\r\n        this.state.set(register, newValue);\r\n    }\r\n\r\n    public get(register: string): number {\r\n        const existing = this.state.get(register);\r\n        if (existing === undefined) {\r\n            this.state.set(register, 0);\r\n            return 0;\r\n        }\r\n        return existing;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [...this.state.values()];\r\n    }\r\n}\r\n\r\nconst checkCondition = (condition: Condition, state: RegisterState): boolean => {\r\n    const leftValue = state.get(condition.left);\r\n    switch (condition.operator) {\r\n        case \"!=\":\r\n            return leftValue !== condition.right;\r\n        case \"<\":\r\n            return leftValue < condition.right;\r\n        case \"<=\":\r\n            return leftValue <= condition.right;\r\n        case \"==\":\r\n            return leftValue === condition.right;\r\n        case \">\":\r\n            return leftValue > condition.right;\r\n        case \">=\":\r\n            return leftValue >= condition.right;\r\n    }\r\n    throw new Error(\"Invalid operator \" + condition.operator);\r\n};\r\n\r\nconst updateState = (action: Action, state: RegisterState) => {\r\n    state.update(\r\n        action.target,\r\n        (value) => action.operation === \"dec\" ?\r\n                    value - action.amount :\r\n                    value + action.amount\r\n        );\r\n};\r\n\r\nexport const heardYouLikeRegisters = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const state = new RegisterState();\r\n        const instructions = parseInstructions(lines);\r\n        executeInstructions(instructions, state);\r\n\r\n        const maxValue = state.getValues().reduce((acc, next) => Math.max(acc, next));\r\n        await outputCallback(maxValue);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const state = new RegisterState();\r\n        const instruction = parseInstructions(lines);\r\n        executeInstructions(instruction, state);\r\n        await outputCallback(state.currentMax);\r\n    },\r\n    { key: \"heard-you-like-registers\", title: \"I Heard You Like Registers\", stars: 2, }\r\n);\r\n\r\nfunction executeInstructions(instructions: Instruction[], state: RegisterState) {\r\n    instructions.forEach((instruction) => {\r\n        if (checkCondition(instruction.condition, state)) {\r\n            updateState(instruction.action, state);\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseInstructions(lines: string[]) {\r\n    return lines.map((line: string): Instruction => {\r\n        const tokens = line.split(\" \").map((e) => e.trim());\r\n        return {\r\n            action: {\r\n                target: tokens[0],\r\n                operation: tokens[1] as Operation,\r\n                amount: parseInt(tokens[2], 10),\r\n            },\r\n            condition: {\r\n                left: tokens[4],\r\n                operator: tokens[5] as Operator,\r\n                right: parseInt(tokens[6], 10)\r\n            }\r\n        };\r\n    });\r\n}\r\n\r\n","import { flatten } from \"wu\";\r\n\r\nexport interface HexCubeCoordinate {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n}\r\n\r\nexport const sumHexCoordinates = (a: HexCubeCoordinate, b: HexCubeCoordinate): HexCubeCoordinate => {\r\n    return {\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n        z: a.z + b.z\r\n    };\r\n};\r\n\r\nexport const getHexSurrounding = (a: HexCubeCoordinate): HexCubeCoordinate[] => {\r\n    return Object\r\n        .values(pointyHexDirections)\r\n        .map((d) => sumHexCoordinates(a, d));\r\n};\r\n\r\nexport const serialization = {\r\n    serialize: (c: HexCubeCoordinate) => `${c.x}|${c.y}|${c.z}`,\r\n    deserialize: (s: string): HexCubeCoordinate => {\r\n        const [x, y, z] = s.split(\"|\").map((e) => parseInt(e, 10));\r\n        return {x, y, z};\r\n    }\r\n};\r\n\r\nexport const flatHexDirections = {\r\n    northWest: {x: -1, y: 1, z: 0},\r\n    southEast: {x: 1, y: -1, z: 0},\r\n    northEast: {x: 1, y: 0, z: -1},\r\n    southWest: {x: -1, y: 0, z: 1},\r\n    north: {x: 0, y: 1, z: -1},\r\n    south: {x: 0, y: -1, z: 1},\r\n};\r\n\r\nexport const pointyHexDirections = {\r\n    west: {x: -1, y: 1, z: 0},\r\n    east: {x: 1, y: -1, z: 0},\r\n    northEast: {x: 1, y: 0, z: -1},\r\n    southWest: {x: -1, y: 0, z: 1},\r\n    northWest: {x: 0, y: 1, z: -1},\r\n    southEast: {x: 0, y: -1, z: 1},\r\n};\r\n\r\nexport const hexManhattanDistance = (a: HexCubeCoordinate, b: HexCubeCoordinate): number => {\r\n    return (Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z)) / 2;\r\n};\r\n","import { entryForFile } from \"../../entry\";\r\nimport { HexCubeCoordinate, sumHexCoordinates, hexManhattanDistance, flatHexDirections } from \"../../../support/hex-geometry\";\r\n\r\nexport type Direction = \"s\" | \"sw\" | \"nw\" | \"n\" | \"ne\" | \"se\";\r\n\r\nconst directionMapper = (d: Direction): HexCubeCoordinate => {\r\n    switch (d) {\r\n        case \"n\":\r\n            return flatHexDirections.north;\r\n        case \"ne\":\r\n            return flatHexDirections.northEast;\r\n        case \"nw\":\r\n            return flatHexDirections.northWest;\r\n        case \"s\":\r\n            return flatHexDirections.south;\r\n        case \"se\":\r\n            return flatHexDirections.southEast;\r\n        case \"sw\":\r\n            return flatHexDirections.southWest;\r\n    }\r\n};\r\n\r\nexport const applyDirections = (\r\n    start: HexCubeCoordinate,\r\n    directions: Direction[],\r\n    callback?: (currentPosition: HexCubeCoordinate) => void\r\n): HexCubeCoordinate => {\r\n    return directions.reduce((acc, next) => {\r\n        const result = sumHexCoordinates(acc, directionMapper(next));\r\n        if (callback) {\r\n            callback(result);\r\n        }\r\n        return result;\r\n    }, start);\r\n};\r\n\r\nexport const hexEd = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const directions = lines[0].split(\",\").map((e) => e as Direction).filter((e) => e !== null);\r\n\r\n\r\n        const center: HexCubeCoordinate = {\r\n            x: 0,\r\n            y: 0,\r\n            z: 0\r\n        };\r\n        const result = applyDirections(center, directions);\r\n        await outputCallback(hexManhattanDistance(center, result));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const directions = lines[0].split(\",\").map((e) => e as Direction).filter((e) => e !== null);\r\n\r\n\r\n        const center: HexCubeCoordinate = {\r\n            x: 0,\r\n            y: 0,\r\n            z: 0\r\n        };\r\n        let maxDistance = Number.NEGATIVE_INFINITY;\r\n        applyDirections(center, directions, (currentPosition) => {\r\n            maxDistance = Math.max(maxDistance, hexManhattanDistance(center, currentPosition));\r\n        });\r\n        await outputCallback(maxDistance);\r\n    },\r\n    { key: \"hex-ed\", title: \"Hex Ed\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nexport const highEntropyPasshprases = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const uniqueLines = lines.filter((line) => {\r\n            const words = line.split(\" \");\r\n            const uniqueWords = new Set(words);\r\n            return words.length === uniqueWords.size;\r\n        }).length;\r\n        await outputCallback(uniqueLines);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const uniqueLines = lines.filter((line) => {\r\n            const words = line.split(\" \").map((word) => [...word].sort().join(\"\"));\r\n            const uniqueWords = new Set(words);\r\n            return words.length === uniqueWords.size;\r\n        }).length;\r\n        await outputCallback(uniqueLines);\r\n    },\r\n    { key: \"high-entropy-passphrases\", title: \"High-Entropy Passphrases\", stars: 2, }\r\n);\r\n\r\n","import { entryForFile } from \"../../entry\";\n\nfunction parseLines(lines: string[]): number[] {\n    return lines\n        .map((l) => l.trim())\n        .filter((l) => l.length > 0)\n        .flatMap((l) => l.split(\"\"))\n        .filter((e) => e.trim().length > 0)\n        .map((n) => parseInt(n, 10));\n}\n\nfunction findMatching(sequence: number[]): number[] {\n    let lastDigit: number | null = null;\n    return sequence.filter((n) => {\n        const previous = lastDigit;\n        lastDigit = n;\n        return n === previous;\n    });\n}\n\nexport const inverseCaptcha = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const sequence = parseLines(lines);\n        const circular = [...sequence, sequence[0]];\n        const matchingSequence: number[] = findMatching(circular);\n        await outputCallback(matchingSequence.reduce((a, b) => a + b));\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const sequence = parseLines(lines);\n        const step = Math.floor(sequence.length / 2);\n        const matchingSequence: number[] = sequence\n            .filter((n, index) => sequence[(index + step) % sequence.length] === n);\n        await outputCallback(matchingSequence.reduce((a, b) => a + b));\n    },\n    { key: \"inverse-captcha\", title: \"Inverse Captcha\", stars: 2, }\n);\n\n","import { entryForFile } from \"../../entry\";\n\ntype State = number[];\n\nconst serializeState = (state: State): string => {\n    return JSON.stringify(state);\n};\n\nconst shiftIndex = <T>(array: T[], index: number, delta: number): number => {\n    return (index + delta) % array.length;\n};\n\nconst distribute = (state: State, maxIndex: number, maxValue: number): State => {\n    const newState = [...state];\n    newState[maxIndex] = 0;\n    let toDistribute = maxValue;\n    let nextIndex = shiftIndex(state, maxIndex, 1);\n    while (toDistribute > 0) {\n        newState[nextIndex]++;\n        nextIndex = shiftIndex(state, nextIndex, 1);\n        toDistribute--;\n    }\n    return newState;\n};\n\nexport const memoryReallocation = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        let state = lines[0].split(\"\\t\").map((e) => parseInt(e, 10));\n        const createdStates = new Set<string>();\n        while (true) {\n            const maxValue = state.reduce((acc, next) => Math.max(acc, next));\n            const maxIndex = state.indexOf(maxValue);\n            state = distribute(state, maxIndex, maxValue);\n            const serialization = serializeState(state);\n            if (createdStates.has(serialization)) {\n                break;\n            }\n            createdStates.add(serialization);\n        }\n        await outputCallback(createdStates.size + 1);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        let state = lines[0].split(\"\\t\").map((e) => parseInt(e, 10));\n        const createdStates = new Map<string, number>();\n        let lastSerialization: string | null = null;\n        while (true) {\n            const maxValue = state.reduce((acc, next) => Math.max(acc, next));\n            const maxIndex = state.indexOf(maxValue);\n            state = distribute(state, maxIndex, maxValue);\n            const serialization = serializeState(state);\n            if (createdStates.has(serialization)) {\n                lastSerialization = serialization;\n                break;\n            }\n            createdStates.set(serialization, createdStates.size + 1);\n        }\n        await outputCallback((createdStates.size + 1) - createdStates.get(lastSerialization)!);\n    },\n    { key: \"memory-reallocation\", title: \"Memory Reallocation\", stars: 2, }\n);\n\n","import { entryForFile } from \"../../entry\";\r\n\r\ntype Direction = -1 | 1;\r\n\r\nclass Scanner {\r\n    constructor(\r\n        public readonly depth: number,\r\n        public readonly range: number,\r\n        public position: number = 0,\r\n        public direction: Direction = 1\r\n        ) {\r\n    }\r\n\r\n    public tick() {\r\n        const position = this.position + this.direction;\r\n        if (position < 0 || position >= this.range) {\r\n            this.direction *= -1;\r\n            this.tick();\r\n        } else {\r\n            this.position = position;\r\n        }\r\n    }\r\n\r\n    public clone(): Scanner {\r\n        return new Scanner(this.depth, this.range, this.position, this.direction);\r\n    }\r\n}\r\n\r\ntype Field = Array<Scanner | null>;\r\n\r\nconst cloneField = (field: Field): Field => {\r\n    return field.map((e) => e ? e.clone() : e);\r\n};\r\n\r\nconst parseLines = (lines: string[]): Field => {\r\n    const sparseField = lines.map((line) => {\r\n        const [depth, range] = line.split(\": \").map((e) => parseInt(e, 10));\r\n        return new Scanner(depth, range);\r\n    });\r\n    const maxDepth = sparseField.map((e) => e.depth).reduce((acc, next) => Math.max(acc, next));\r\n    return [...Array(maxDepth + 1).keys()].map((index) => {\r\n        const scanner = sparseField.filter((e) => e.depth === index)[0];\r\n        if (scanner) {\r\n            return scanner;\r\n        }\r\n        return null;\r\n    });\r\n};\r\n\r\nconst tickField = (field: Field) => {\r\n    field.filter((e) => e != null).forEach((e) => e!.tick());\r\n};\r\n\r\nexport const packetScanners = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const field = parseLines(lines);\r\n        let currentPosition = -1;\r\n        const collisions: Scanner[] = [];\r\n        while (currentPosition < field.length) {\r\n            currentPosition++;\r\n            const currentScanner = field[currentPosition];\r\n            if (currentScanner && currentScanner.position === 0) {\r\n                collisions.push(currentScanner);\r\n            }\r\n            tickField(field);\r\n        }\r\n        const score = collisions.reduce((acc, next) => acc + (next.depth * next.range), 0);\r\n        await outputCallback(score);\r\n    },\r\n    async ({ lines, outputCallback, pause }) => {\r\n        let delay = 0;\r\n        const baseField = parseLines(lines);\r\n        while (true) {\r\n            if (delay % 1000 === 0) {\r\n                await pause();\r\n            }\r\n            const field = cloneField(baseField);\r\n            let currentPosition = -1;\r\n            let hasCollided = false;\r\n            while (currentPosition < field.length) {\r\n                currentPosition++;\r\n                const currentScanner = field[currentPosition];\r\n                if (currentScanner && currentScanner.position === 0) {\r\n                    hasCollided = true;\r\n                    break;\r\n                }\r\n                tickField(field);\r\n            }\r\n            if (!hasCollided) {\r\n                await outputCallback(delay);\r\n                break;\r\n            }\r\n            tickField(baseField);\r\n            hasCollided = false;\r\n            delay++;\r\n        }\r\n    },\r\n    { key: \"packet-scanners\", title: \"Packet Scanners\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { manhattanDistance, Coordinate3d } from \"../../../support/geometry\";\r\nimport { NotImplementedError } from \"../../../support/error\";\r\n\r\ninterface Particle {\r\n    position: Coordinate3d;\r\n    speed: Coordinate3d;\r\n    acceleration: Coordinate3d;\r\n}\r\n\r\nconst parseTuple = (s: string): Coordinate3d => {\r\n    const split = s.slice(3, -1).split(\",\").map((e) => parseInt(e, 10));\r\n    if (split.length !== 3) {\r\n        throw new Error(\"Invalid string\");\r\n    }\r\n    return {\r\n        x: split[0],\r\n        y: split[1],\r\n        z: split[2]\r\n    };\r\n};\r\n\r\nconst parseParticles = (lines: string[]): Particle[] => {\r\n    return lines.map((line) => {\r\n        const [rawPos, rawSpeed, rawAcc] = line.split(\", \");\r\n        return {\r\n            position: parseTuple(rawPos),\r\n            speed: parseTuple(rawSpeed),\r\n            acceleration: parseTuple(rawAcc)\r\n        };\r\n    });\r\n};\r\n\r\nconst updateParticle = (particle: Particle): Particle => {\r\n    const newSpeed: Coordinate3d = {\r\n        x: particle.speed.x + particle.acceleration.x,\r\n        y: particle.speed.y + particle.acceleration.y,\r\n        z: particle.speed.z + particle.acceleration.z,\r\n    };\r\n\r\n    const newPosition: Coordinate3d = {\r\n        x: particle.position.x + newSpeed.x,\r\n        y: particle.position.y + newSpeed.y,\r\n        z: particle.position.z + newSpeed.z,\r\n    };\r\n    return {\r\n        ...particle,\r\n        position: newPosition,\r\n        speed: newSpeed\r\n    };\r\n};\r\n\r\nconst serializeCoordinate = (c: Coordinate3d): string => {\r\n    return [c.x, c.y, c.z].join(\",\");\r\n};\r\n\r\nconst createCollided = (particles: Particle[]): Array<Particle & {collision: boolean}> => {\r\n    const existing = new Set<string>();\r\n    const collisions = new Set<string>();\r\n    particles.forEach((p) => {\r\n        const serialized = serializeCoordinate(p.position);\r\n        if (existing.has(serialized)) {\r\n            collisions.add(serialized);\r\n        }\r\n        existing.add(serialized);\r\n    });\r\n    return particles.map((particle) => ({\r\n        ...particle,\r\n        collision: collisions.has(serializeCoordinate(particle.position))\r\n    }));\r\n};\r\n\r\nexport const particleSwarm = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const accelerations = lines\r\n            .map((line) => line.split(\", \")[2].split(\"=<\")[1].slice(0, -1))\r\n            .map((rawAcc) => rawAcc.split(\",\").map((e) => parseInt(e, 10)))\r\n            .map((vs) => ({\r\n                x: vs[0],\r\n                y: vs[1],\r\n                z: vs[2]\r\n            }));\r\n        const lowestAcceleration = accelerations\r\n            .map((e, index) => ({e, index}))\r\n            .filter((e) => manhattanDistance(e.e, {x: 0, y: 0, z: 0}) === 0);\r\n\r\n        await outputCallback(accelerations);\r\n        await outputCallback(lowestAcceleration);\r\n\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        let particles = parseParticles(lines);\r\n\r\n        let lastCollision = 0;\r\n        let currentStep = 0;\r\n\r\n        await outputCallback(particles.length);\r\n        while (currentStep - lastCollision < 1000) {\r\n            particles = particles.map(updateParticle);\r\n            const oldLength = particles.length;\r\n            particles = createCollided(particles).filter((p) => !p.collision);\r\n            if (particles.length !== oldLength) {\r\n                lastCollision = currentStep;\r\n            }\r\n            currentStep++;\r\n        }\r\n        await outputCallback(particles.length);\r\n\r\n    },\r\n    { key: \"particle-swarm\", title: \"Particle Swarm\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\n\r\nexport const permutationPromenade = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const programs = programListGenerator(16);\r\n        const instructions = lines[0].split(\",\").map((i) => i.trim());\r\n        const reordered = dance(instructions, programs);\r\n        await outputCallback(reordered.join(\"\"));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        let programs = programListGenerator(16);\r\n        const instructions = lines[0].split(\",\").map((i) => i.trim());\r\n        const total = 1000000000;\r\n        const dances: string[] = [];\r\n        for (let i = 0; i < total; i++) {\r\n            if (i % 100 === 0) {\r\n                const currentRatio = i / total;\r\n                await outputCallback(`Done ${currentRatio * 100}%`);\r\n            }\r\n            programs = dance(instructions, programs);\r\n            const serialized = programs.join(\"\");\r\n            if (dances.indexOf(serialized) >= 0) {\r\n                await outputCallback(\"Found at cycle \" + i);\r\n                await outputCallback(\"Dances length: \" + dances.length);\r\n                break;\r\n            }\r\n            dances.push(serialized);\r\n        }\r\n        const requiredIndex = (total - 1) % dances.length;\r\n        await outputCallback(dances[requiredIndex]);\r\n    },\r\n    { key: \"permutation-promenade\", title: \"Permutation Promenade\", stars: 2, }\r\n);\r\nfunction msToTime(s: number) {\r\n\r\n  // Pad to 2 or 3 digits, default is 2\r\n  function pad(n: number, z?: number) {\r\n    z = z || 2;\r\n    return (\"00\" + n).slice(-z);\r\n  }\r\n\r\n  const ms = s % 1000;\r\n  s = (s - ms) / 1000;\r\n  const secs = s % 60;\r\n  s = (s - secs) / 60;\r\n  const mins = s % 60;\r\n  const hrs = (s - mins) / 60;\r\n\r\n  return pad(hrs) + \":\" + pad(mins) + \":\" + pad(secs) + \".\" + pad(ms, 3);\r\n}\r\n\r\nexport function dance(instructions: string[], programs: string[]) {\r\n    programs = [...programs];\r\n    let currentPosition = 0;\r\n    instructions.forEach((instruction) => {\r\n        const identifier = instruction[0];\r\n        switch (identifier) {\r\n            case \"s\":\r\n                const delta = parseInt(instruction.slice(1), 10);\r\n                currentPosition -= delta;\r\n                while (currentPosition < 0) {\r\n                    currentPosition += programs.length;\r\n                }\r\n                break;\r\n            case \"x\":\r\n                {\r\n                    const [a, b] = instruction.slice(1).split(\"/\").map((e) => parseInt(e, 10));\r\n                    const aIndex = (currentPosition + a) % programs.length;\r\n                    const bIndex = (currentPosition + b) % programs.length;\r\n                    swap(programs, aIndex, bIndex);\r\n                }\r\n                break;\r\n            case \"p\":\r\n                {\r\n                    const [a, b] = instruction.slice(1).split(\"/\");\r\n                    const aIndex = programs.indexOf(a);\r\n                    const bIndex = programs.indexOf(b);\r\n                    swap(programs, aIndex, bIndex);\r\n                }\r\n                break;\r\n        }\r\n    });\r\n    const reordered = programs.slice(currentPosition).concat(programs.slice(0, currentPosition));\r\n    return reordered;\r\n}\r\n\r\nexport function programListGenerator(n: number): string[] {\r\n    return [...Array(n).keys()].map((index) => String.fromCharCode(\"a\".charCodeAt(0) + index));\r\n}\r\n\r\nfunction swap(programs: string[], aIndex: number, bIndex: number) {\r\n    const temp = programs[aIndex];\r\n    programs[aIndex] = programs[bIndex];\r\n    programs[bIndex] = temp;\r\n}\r\n","import { entryForFile } from \"../../entry\";\nimport { Tree, Queue } from \"../../../support/data-structure\";\n\nconst parseLines = (lines: string[]): Map<string, DiscDefinition> => {\n    const definitions = lines.map((line: string): DiscDefinition => {\n        const split = line.split(\" -> \");\n        const [head, weightToParse] = split[0].split(\" \");\n        const weight = parseInt(weightToParse.slice(1, weightToParse.length - 1), 10);\n\n        const children = split.length === 1 ? [] : split[1].split(\", \");\n\n        return {\n            head: {\n                name: head,\n                weight\n            },\n            children\n        };\n    });\n    const map = new Map<string, DiscDefinition>();\n    definitions.forEach((definition) => map.set(definition.head.name, definition));\n    return map;\n};\n\nconst buildTree = (\n    startTree: string,\n    definitions: Map<string, DiscDefinition>,\n): Tree<WeightedProgram> => {\n    const definition = definitions.get(startTree)!;\n    const tree = new Tree<WeightedProgram>(definition.head);\n    const subTrees = definition.children.map((child) => buildTree(child, definitions));\n    subTrees.forEach((subTree) => tree.appendTree(subTree));\n    return tree;\n};\n\ninterface UnbalancedResult {\n    isUnbalanced: true;\n    requiredWeight: number;\n}\n\ninterface BalancedResult {\n    isUnbalanced: false;\n    totalWeight: number;\n    headWeight: number;\n}\n\n\ntype CheckResult = UnbalancedResult | BalancedResult;\n\nconst isUnbalanced = (e: CheckResult): e is UnbalancedResult => {\n    return e.isUnbalanced;\n};\n\nconst findUnbalancedIndex = (weights: number[]): number | null => {\n    const min = weights.reduce((acc, next) => Math.min(acc, next));\n    const max = weights.reduce((acc, next) => Math.max(acc, next));\n    if (min === max) {\n        return null;\n    }\n    const isMinUnbalanced = weights.filter((w) => w === min).length === 1;\n    const target = isMinUnbalanced ? min : max;\n    return weights.indexOf(target);\n};\nconst checkWeight = (tree: Tree<WeightedProgram>): CheckResult => {\n    if (tree.children.length === 0) {\n        return {\n            isUnbalanced: false,\n            totalWeight: tree.head.weight,\n            headWeight: tree.head.weight\n        };\n    }\n    const childrenResults = tree.children.map((child) => checkWeight(child));\n    const unbalancedResults = childrenResults.filter((e) => isUnbalanced(e));\n    if (unbalancedResults.length > 0) {\n        return unbalancedResults[0];\n    }\n    const balancedResults: BalancedResult[] = childrenResults.map((e) => e as BalancedResult);\n    const childrenWeights = balancedResults.map((e) => e.totalWeight);\n    const unbalancedIndex = findUnbalancedIndex(childrenWeights);\n    if (unbalancedIndex === null) {\n        return {\n            isUnbalanced: false,\n            totalWeight: childrenWeights.reduce((acc, next) => acc + next) + tree.head.weight,\n            headWeight: tree.head.weight\n        };\n    }\n    const otherIndex = (unbalancedIndex + 1) % balancedResults.length;\n    const delta = balancedResults[unbalancedIndex].totalWeight - balancedResults[otherIndex].totalWeight;\n    const result: UnbalancedResult = {\n        isUnbalanced: true,\n        requiredWeight: balancedResults[unbalancedIndex].headWeight - delta\n    };\n    return result;\n};\n\ninterface WeightedProgram {\n    weight: number;\n    name: string;\n}\n\ninterface DiscDefinition {\n    head: WeightedProgram;\n    children: string[];\n}\nexport const recursiveCircus = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const bottomValue = findBottom(lines);\n\n        await outputCallback(bottomValue);\n\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const definitions = parseLines(lines);\n        const bottom = findBottom(lines);\n        const tree = buildTree(bottom, definitions);\n        const checkResult = checkWeight(tree);\n        await outputCallback(checkResult);\n    },\n    { key: \"recursive-circus\", title: \"Recursive Circus\", stars: 2, }\n);\n\nfunction findBottom(lines: string[]) {\n    const withRightSide = lines.filter((l) => l.indexOf(\">\") >= 0);\n    const onlyRightHand = withRightSide.map((line) => line.split(\">\")[1].trim());\n    const rightHandValues = new Set<string>(onlyRightHand\n        .flatMap((right) => right.split(\",\")\n            .map((e) => e.trim())));\n    const leftValues = lines.map((line) => line.split(\" \")[0].trim());\n    const bottomValue = leftValues.filter((value) => !rightHandValues.has(value))[0];\n    return bottomValue;\n}\n\n","import { entryForFile } from \"../../entry\";\r\n\r\nexport const spinlock = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const steps = parseInt(lines[0], 10);\r\n        const buffer: number[] = [0];\r\n        let currentPosition = 0;\r\n        for (let i = 1; i <= 2017; i++) {\r\n            currentPosition = (currentPosition + steps) % buffer.length + 1;\r\n            buffer.splice(currentPosition, 0, i);\r\n        }\r\n\r\n        await outputCallback(buffer[(currentPosition + 1) % buffer.length]);\r\n\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const steps = parseInt(lines[0], 10);\r\n        // const buffer: number[] = [0];\r\n        let lastAdd = 0;\r\n        let currentPosition = 0;\r\n        const total = 50 * 10 ** 6;\r\n        for (let i = 1; i <= total; i++) {\r\n            currentPosition = (currentPosition + steps) % i + 1;\r\n            if (currentPosition === 1) {\r\n                lastAdd = i;\r\n            }\r\n            // buffer.splice(currentPosition, 0, i);\r\n            // await outputCallback(buffer[1]);\r\n        }\r\n\r\n        // const zeroIndex = buffer.indexOf(0);\r\n\r\n        // await outputCallback(buffer[(zeroIndex + 1) % buffer.length]);\r\n        await outputCallback(lastAdd);\r\n    },\r\n    { key: \"spinlock\", title: \"Spinlock\", stars: 2, }\r\n);\r\n","import { Coordinate } from \"./geometry\";\r\n\r\nexport class UlamCalculator {\r\n    public getCoordinatesFromValue(vArg: number): Coordinate {\r\n        if (vArg === 1) {\r\n            return {x: 0, y: 0};\r\n        }\r\n        const size = this.findSquareSize(vArg);\r\n        const sideDistance = Math.floor(size / 2);\r\n        const min = (size - 1) ** 2;\r\n        const max = size ** 2;\r\n        const isDown = vArg > max - size;\r\n        const sideCalculators = [\r\n            {\r\n                delta: -size,\r\n                x: (v: number, middle: number) => v - middle,\r\n                y: (v: number, middle: number) => -sideDistance\r\n            },\r\n            {\r\n                delta: -2 * (size - 1) - 1,\r\n                x: (v: number, middle: number) => -sideDistance,\r\n                y: (v: number, middle: number) => middle - v\r\n            },\r\n            {\r\n                delta: -3 * (size - 1) - 1,\r\n                x: (v: number, middle: number) => middle - v,\r\n                y: (v: number, middle: number) => sideDistance\r\n            },\r\n            {\r\n                delta: -4 * (size - 1) - 1,\r\n                x: (v: number, middle: number) => sideDistance,\r\n                y: (v: number, middle: number) => v - middle\r\n            }\r\n        ];\r\n\r\n        for (const calc of sideCalculators) {\r\n            const currentMax = max + calc.delta + size;\r\n            if (vArg > max + calc.delta) {\r\n                const middlePoint = this.findSideMiddlePoint(size, currentMax);\r\n                return {\r\n                    x: calc.x(vArg, middlePoint),\r\n                    y: calc.y(vArg, middlePoint)\r\n                };\r\n            }\r\n        }\r\n        throw new Error(`Cannot calculate for ${vArg} :(`);\r\n    }\r\n\r\n    public findSideMiddlePoint(size: number, max: number) {\r\n        const min = max - size + 1;\r\n        return (max + min) / 2;\r\n    }\r\n\r\n    public findSquareSize(v: number): number {\r\n        const root = Math.sqrt(v);\r\n        const ceil = Math.ceil(root);\r\n        return ceil % 2 === 0 ? ceil + 1 : ceil;\r\n    }\r\n}\r\n","import { FixedSizeMatrix } from \"./matrix\";\nimport { Coordinate, getBoundaries, CCoordinate } from \"./geometry\";\n\nexport class UnknownSizeField<T> {\n\n    private readonly cells: { [key: string]: T | undefined } = {};\n\n    public set(coordinate: Coordinate, element: T): void {\n        this.cells[this.serializeCoordinate(coordinate)] = element;\n    }\n\n    public get(coordinate: Coordinate): T | null {\n        const element = this.cells[this.serializeCoordinate(coordinate)];\n        if (element === undefined) {\n            return null;\n        }\n        return element;\n    }\n    public toMatrix(): FixedSizeMatrix<T> {\n        const bounds = getBoundaries(Object.keys(this.cells).map(this.deserializeCoordinate));\n        const matrix = new FixedSizeMatrix<T>(bounds.size);\n        matrix.setDelta(CCoordinate.fromCoordinate(bounds.topLeft));\n        Object.keys(this.cells).forEach((serialized) => {\n            const coordinate = this.deserializeCoordinate(serialized);\n            const cell = this.cells[serialized];\n            if (cell !== undefined) {\n                matrix.set(coordinate, cell);\n            }\n        });\n        return matrix;\n    }\n\n    private serializeCoordinate(c: Coordinate): string {\n        return JSON.stringify({ x: c.x, y: c.y });\n    }\n\n    private deserializeCoordinate(serialized: string): Coordinate {\n        return JSON.parse(serialized) as Coordinate;\n    }\n}\n","import { entryForFile } from \"../../entry\";\r\nimport { UlamCalculator } from \"../../../support/ulam\";\r\nimport { manhattanDistance, directions, getSurrounding, getFullSurrounding } from \"../../../support/geometry\";\r\nimport { UnknownSizeField } from \"../../../support/field\";\r\n\r\nfunction parseLines(lines: string[]): number[][] {\r\n    return lines\r\n        .map((l) => l.trim())\r\n        .map((line) => line.split(\"\\t\").map((token) => parseInt(token, 10)))\r\n        ;\r\n}\r\n\r\nexport const spiralMemory = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const squareValue = parseInt(lines[0], 10);\r\n        const calculator = new UlamCalculator();\r\n        const coordinates = calculator.getCoordinatesFromValue(squareValue);\r\n        const distance = manhattanDistance({ x: 0, y: 0 }, coordinates);\r\n        await outputCallback(distance);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const target = parseInt(lines[0], 10);\r\n        const field = new UnknownSizeField<number>();\r\n\r\n        let next = 1;\r\n        let toDo = next;\r\n        let nextIteration = 2;\r\n        const directionOrder = [\r\n            directions.right,\r\n            directions.up,\r\n            directions.left,\r\n            directions.down\r\n        ];\r\n        let currentDirection = 0;\r\n\r\n        field.set({ x: 0, y: 0 }, 1);\r\n        let currentPosition = { x: 0, y: 0 };\r\n        const i = 0;\r\n        while (true) {\r\n            currentPosition = directionOrder[currentDirection].sum(currentPosition);\r\n            const value = getFullSurrounding(currentPosition)\r\n                .map((c) => field.get(c))\r\n                .filter((e) => e !== null)\r\n                .reduce((acc: number, n) => acc + n!, 0);\r\n            if (value > target) {\r\n                await outputCallback(value);\r\n                return;\r\n            }\r\n            field.set(currentPosition, value);\r\n            toDo--;\r\n            if (toDo === 0) {\r\n                nextIteration--;\r\n                currentDirection = (currentDirection + 1) % directionOrder.length;\r\n                if (nextIteration > 0) {\r\n                    toDo = next;\r\n                } else {\r\n                    nextIteration = 2;\r\n                    next++;\r\n                    toDo = next;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    { key: \"spiral-memory\", title: \"Spiral Memory\", stars: 2, }\r\n);\r\n\r\n","import { entryForFile } from \"../../entry\";\nimport { UnknownSizeField } from \"../../../support/field\";\nimport { NotImplementedError } from \"../../../support/error\";\nimport { Coordinate, CCoordinate, directions, rotate } from \"../../../support/geometry\";\nimport { aMazeOfTwistyTrampolinesAllAlike } from \"./a-maze-of-twisty-trampolines-all-alike\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\n\ntype Field = UnknownSizeField<string>;\n\nconst parse = (lines: string[]): Field => {\n    const sizeY = lines.length;\n    lines = lines.map((line) => line.trim());\n    const lineLengths = lines.map((line) => line.length);\n    if (\n        lineLengths.reduce((acc, next) => Math.max(acc, next))\n        !== lineLengths.reduce((acc, next) => Math.min(acc, next))) {\n        throw new Error(\"Invalid input, line lengths are not all the same\");\n    }\n    const sizeX = lineLengths[0];\n    const flatData = lines.flatMap((line) => line.split(\"\"));\n    const matrix = new FixedSizeMatrix<string>({ x: sizeX, y: sizeY });\n    matrix.setFlatData(flatData);\n    const field = new UnknownSizeField<string>();\n    matrix.onEveryCell((coordinate, cell) => field.set(coordinate, cell!));\n    return field;\n};\n\ninterface VirusCarrier {\n    position: Coordinate;\n    direction: CCoordinate;\n}\n\nexport const sporificaVirus = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const field = parse(lines);\n        const startSize = field.toMatrix().size;\n        const midX = Math.floor(startSize.x / 2);\n        const midY = Math.floor(startSize.y / 2);\n        const virus: VirusCarrier = {\n            position: { x: midX, y: midY },\n            direction: directions.up\n        };\n\n        const total = 10 ** 4;\n\n        let infectionCount = 0;\n\n        for (let i = 0; i < total; i++) {\n            const cell = field.get(virus.position);\n            if (cell === \"#\") {\n                field.set(virus.position, \".\");\n                virus.direction = rotate(virus.direction, \"Clockwise\");\n            } else {\n                field.set(virus.position, \"#\");\n                virus.direction = rotate(virus.direction, \"Counterclockwise\");\n                infectionCount++;\n            }\n            virus.position = virus.direction.sum(virus.position);\n            // await outputCallback(field.toMatrix().toString((e) => e || \" \") + \"\\n\");\n        }\n\n        await outputCallback(infectionCount);\n    },\n    async ({ lines, outputCallback }) => {\n        const field = parse(lines);\n        const startSize = field.toMatrix().size;\n        const midX = Math.floor(startSize.x / 2);\n        const midY = Math.floor(startSize.y / 2);\n        const virus: VirusCarrier = {\n            position: { x: midX, y: midY },\n            direction: directions.up\n        };\n\n        const total = 10 ** 7;\n\n        let infectionCount = 0;\n\n        for (let i = 0; i < total; i++) {\n            const cell = field.get(virus.position);\n            if (cell === \"#\") {\n                field.set(virus.position, \"F\");\n                virus.direction = rotate(virus.direction, \"Clockwise\");\n            } else if (cell === \".\" || !cell) {\n                field.set(virus.position, \"W\");\n                virus.direction = rotate(virus.direction, \"Counterclockwise\");\n            } else if (cell === \"W\") {\n                field.set(virus.position, \"#\");\n                infectionCount++;\n            } else if (cell === \"F\") {\n                field.set(virus.position, \".\");\n                virus.direction = rotate(rotate(virus.direction, \"Counterclockwise\"), \"Counterclockwise\");\n            }\n            virus.position = virus.direction.sum(virus.position);\n            // await outputCallback(field.toMatrix().toString((e) => e || \" \") + \"\\n\");\n        }\n\n        await outputCallback(infectionCount);\n    },\n    { key: \"sporifica-virus\", title: \"Sporifica Virus\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { Stack } from \"linq-typescript\";\r\n\r\ntype Group = Element[];\r\ntype Garbage = string;\r\ntype Element = Group | Garbage;\r\n\r\nconst outI = 0;\r\nconst parseGarbage = (line: string, start: number): [Garbage, number] => {\r\n    let isEscaped = false;\r\n    const current: string[] = [];\r\n    let currentIndex = start;\r\n    while (true) {\r\n        if (currentIndex >= line.length) {\r\n            throw new Error(\"I got out of the bounds while garbaging o.o\");\r\n        }\r\n        if (isEscaped) {\r\n            isEscaped = false;\r\n            currentIndex++;\r\n        } else if (line[currentIndex] === \"!\") {\r\n            isEscaped = true;\r\n            currentIndex++;\r\n        } else if (line[currentIndex] === \">\") {\r\n            return [current.join(\"\"), currentIndex + 1];\r\n        } else {\r\n            current.push(line[currentIndex++]);\r\n        }\r\n    }\r\n};\r\n\r\nexport const parseGroup = (line: string, start: number = 1): [Group, number] => {\r\n    const current: Group = [];\r\n    let currentIndex = start;\r\n    while (true) {\r\n        if (currentIndex >= line.length) {\r\n            console.log(current);\r\n            throw new Error(\"I got out of the bounds while grouping o.o\");\r\n        }\r\n        if (line[currentIndex] === \"{\") {\r\n            const [group, suggestedIndex] = parseGroup(line, currentIndex + 1);\r\n            current.push(group);\r\n            currentIndex = suggestedIndex;\r\n        } else if (line[currentIndex] === \"}\") {\r\n            return [current, currentIndex + 1];\r\n        } else if (line[currentIndex] === \"<\") {\r\n            const [garbage, suggestedIndex] = parseGarbage(line, currentIndex + 1);\r\n            current.push(garbage);\r\n            currentIndex = suggestedIndex;\r\n        } else if (line[currentIndex] === \",\") {\r\n            currentIndex++;\r\n        } else {\r\n            throw new Error(\"Invalid token while parsing group: \" + line[currentIndex]);\r\n        }\r\n    }\r\n};\r\n\r\nconst isGarbage = (element: Element): element is Garbage => {\r\n    return (typeof element) === \"string\";\r\n};\r\n\r\nconst score = (element: Element, baseScore: number = 0): number => {\r\n    if (isGarbage(element)) {\r\n        return 0;\r\n    }\r\n    const localScore = baseScore + 1;\r\n    const additionalScore = element.reduce((acc, next) => score(next, localScore) + acc, 0);\r\n    return localScore + additionalScore;\r\n};\r\n\r\nexport const countGarbage = (element: Element): number => {\r\n    if (isGarbage(element)) {\r\n        return element.length;\r\n    }\r\n    return element.reduce((acc, next) => countGarbage(next) + acc, 0);\r\n};\r\nexport const streamProcessing = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const line = lines[0];\r\n        const result = parseGroup(line)[0];\r\n        await outputCallback(score(result));\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const line = lines[0];\r\n        const result = parseGroup(line)[0];\r\n        await outputCallback(countGarbage(result));\r\n    },\r\n    { key: \"stream-processing\", title: \"Stream Processing\", stars: 2, }\r\n);\r\n\r\n","import { entryForFile } from \"../../entry\";\nimport { NotImplementedError } from \"../../../support/error\";\nimport { groupBy } from \"../../../support/sequences\";\nimport { parseGroup } from \"./stream-processing\";\n\ntype Cell = 0 | 1;\n\ntype Direction = -1 | 1;\n\ninterface Input {\n    machine: TuringMachine;\n    steps: number;\n}\n\ninterface TuringRule {\n    write: Cell;\n    direction: Direction;\n    nextState: string;\n}\n\ninterface TuringState {\n    state: string;\n    0: TuringRule;\n    1: TuringRule;\n}\n\ninterface TuringData {\n    mainTape: Cell[];\n    negativeTape: Cell[];\n}\n\ninterface TuringInstance {\n    data: TuringData;\n    position: number;\n    nextState: string;\n}\n\ninterface TuringMachine {\n    instance: TuringInstance;\n    states: TuringState[];\n}\n\nconst getTape = (turingData: TuringData, position: number): Cell[] => {\n    const tape = position >= 0 ? turingData.mainTape : turingData.negativeTape;\n    return tape;\n};\n\nconst getCell = (turingData: TuringData, position: number): Cell => {\n    const tape = getTape(turingData, position);\n    return tape[Math.abs(position)] || 0;\n};\n\nconst setCell = (turingData: TuringData, position: number, cell: Cell): TuringData => {\n    const tape = getTape(turingData, position);\n    tape[Math.abs(position)] = cell;\n    return turingData;\n};\n\nconst calculateStep = (machine: TuringMachine) => {\n    const nextState = machine.instance.nextState;\n    const matchingState = machine.states.filter((states) => states.state === nextState)[0];\n    const currentCell = getCell(machine.instance.data, machine.instance.position);\n    const matchingRule = matchingState[currentCell];\n    setCell(machine.instance.data, machine.instance.position, matchingRule.write);\n    machine.instance.position += matchingRule.direction;\n    machine.instance.nextState = matchingRule.nextState;\n};\n\nconst getLastWord = (s: string, delta: number = 0): string => {\n    const tokens = s.trim().split(\" \");\n    const lastToken = tokens[tokens.length - delta - 1];\n    return (lastToken.endsWith(\".\") || lastToken.endsWith(\":\")) ?\n        lastToken.slice(0, -1) :\n        lastToken;\n};\n\nconst getLastNumber = (s: string): number => {\n    return parseInt(getLastWord(s), 10);\n};\n\nconst getLastCell = (s: string): Cell => {\n    const number = getLastNumber(s);\n    if (number !== 0 && number !== 1) {\n        throw new Error(\"Invalid cell: \" + number);\n    }\n    return number;\n};\n\nconst parseRule = (group: string[]): TuringRule => {\n    if (group.length !== 3) {\n        throw new Error(\"Invalid group\");\n    }\n    return {\n        write: getLastCell(group[0]),\n        direction: getLastWord(group[1]) === \"right\" ? 1 : -1,\n        nextState: getLastWord(group[2])\n    };\n};\n\nconst parseInput = (lines: string[]): Input => {\n    const startState = getLastWord(lines[0]);\n    const steps = parseInt(getLastWord(lines[1], 1), 10);\n    lines = lines.slice(2);\n    const states: TuringState[] = groupBy(lines, 10).map((group) => {\n        group = group.slice(1);\n        const state = getLastWord(group[0]);\n        const rs = [0, 1].map((i) => {\n            const key = getLastCell(group[i * 4 + 1]);\n            const rules = parseRule(group.slice(i * 4 + 2, i * 4 + 5));\n            return {\n                [0]: rules\n            };\n        });\n        return {\n            state,\n            0: parseRule(group.slice(2, 5)),\n            1: parseRule(group.slice(6, 9))\n        };\n    });\n    return {\n        steps,\n        machine: {\n            states,\n            instance: {\n                data: {\n                    mainTape: [],\n                    negativeTape: []\n                },\n                nextState: startState,\n                position: 0\n            }\n        }\n    };\n};\n\nconst calculateChecksum = (machine: TuringMachine): number => {\n    return machine.instance.data.mainTape.reduce((acc: number, next) => acc + next, 0) +\n    machine.instance.data.negativeTape.reduce((acc: number, next) => acc + next, 0);\n\n};\n\nexport const haltingProblem = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const input = parseInput(lines);\n        const machine = input.machine;\n        for (let i = 0; i < input.steps; i++) {\n            calculateStep(machine);\n        }\n        const checksum = calculateChecksum(machine);\n        await outputCallback(checksum);\n    },\n    async ({ lines, outputCallback }) => {\n        throw Error(\"Not implemented\");\n    },\n    { key: \"the-halting-problem\", title: \"The Halting Problem\", stars: 2, }\n);\n","import { aMazeOfTwistyTrampolinesAllAlike } from \"./a-maze-of-twisty-trampolines-all-alike\";\nimport { aSeriesOfTubes } from \"./a-series-of-tubes\";\nimport { coprocessorConflagration } from \"./coprocessor-conflagration\";\nimport { corruptionChecksum } from \"./corruption-checksum\";\nimport { digitalPlumber } from \"./digital-plumber\";\nimport { diskDefragmentation } from \"./disk-defragmentation\";\nimport { duelingGenerators } from \"./dueling-generators\";\nimport { duet } from \"./duet\";\nimport { electromagneticMoat } from \"./electromagnetic-moat\";\nimport { fractalArt } from \"./fractal-art\";\nimport { heardYouLikeRegisters } from \"./heard-you-like-registers\";\nimport { hexEd } from \"./hex-ed\";\nimport { highEntropyPasshprases } from \"./high-entropy-passhprases\";\nimport { inverseCaptcha } from \"./inverse-captcha\";\nimport { knotHash } from \"./knot-hash\";\nimport { memoryReallocation } from \"./memory-reallocation\";\nimport { packetScanners } from \"./packet-scanners\";\nimport { particleSwarm } from \"./particle-swarm\";\nimport { permutationPromenade } from \"./permutation-promenade\";\nimport { recursiveCircus } from \"./recursive-circus\";\nimport { spinlock } from \"./spinlock\";\nimport { spiralMemory } from \"./spiral-memory\";\nimport { sporificaVirus } from \"./sporifica-virus\";\nimport { streamProcessing } from \"./stream-processing\";\nimport { haltingProblem } from \"./the-halting-problem\";\n\nexport const entries =\n        [\n        inverseCaptcha,\n        corruptionChecksum,\n        spiralMemory,\n        highEntropyPasshprases,\n        aMazeOfTwistyTrampolinesAllAlike,\n        memoryReallocation,\n        recursiveCircus,\n        heardYouLikeRegisters,\n        streamProcessing,\n        knotHash,\n        hexEd,\n        digitalPlumber,\n        packetScanners,\n        diskDefragmentation,\n        duelingGenerators,\n        permutationPromenade,\n        spinlock,\n        duet,\n        aSeriesOfTubes,\n        particleSwarm,\n        fractalArt,\n        sporificaVirus,\n        coprocessorConflagration,\n        electromagneticMoat,\n        haltingProblem,\n    ]\n;\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        let currentFrequency = 0;\n        lines.forEach((line) => {\n            const trimmed = line.trim();\n            let value = parseInt(trimmed.slice(1), 10);\n            if (trimmed.startsWith(\"-\")) {\n                value *= -1;\n            }\n            currentFrequency += value;\n        });\n        await outputCallback(\"Result: \" + currentFrequency);\n    },\n    async ({lines, outputCallback}) => {\n        const values: number[] = [];\n        const firstRoundOfFrequencies: number[] = [];\n        let currentFrequency: number = 0;\n        lines.forEach((line) => {\n            const trimmed = line.trim();\n            let value = parseInt(trimmed.slice(1), 10);\n            if (trimmed.startsWith(\"-\")) {\n                value *= -1;\n            }\n            values.push(value);\n            currentFrequency += value;\n            firstRoundOfFrequencies.push(currentFrequency);\n        });\n        const foundFrequencies = new Set<number>();\n        let current = 0;\n        foundFrequencies.add(0);\n        let found = false;\n        while (!found) {\n            found = values.some((v) => {\n                current += v;\n                if (foundFrequencies.has(current)) {\n                    // tslint:disable-next-line:no-floating-promises\n                    outputCallback(\"Found: \" + current);\n                    return true;\n                } else {\n                    foundFrequencies.add(current);\n                    return false;\n                }\n            });\n        }\n    },\n    { key: \"frequency\", title: \"Chronal Calibration\", stars: 2, }\n);\n","import { Entry, oldEntryForFile, entryForFile } from \"../../entry\";\n\nexport const entry: Entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        interface WordCounter { [key: string]: number; }\n        function createWordCounter(word: string) {\n            const currentCount: WordCounter = {};\n            word.split(\"\").forEach((letter) => {\n                if (letter in currentCount) {\n                    currentCount[letter]++;\n                } else {\n                    currentCount[letter] = 1;\n                }\n            });\n            return currentCount;\n        }\n        function hasNLetters(counter: WordCounter, n: number): boolean {\n            for (const key in counter) {\n                if (counter[key] === n) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        interface WordStatus {\n            hasTwoLetters: boolean;\n            hasThreeLetters: boolean;\n        }\n\n        const checksumCounter: WordStatus[] = lines.map((line) => {\n            const counter = createWordCounter(line);\n            return {\n                hasTwoLetters: hasNLetters(counter, 2),\n                hasThreeLetters: hasNLetters(counter, 3),\n            };\n        });\n\n        const amountOfTwoLetters = checksumCounter.filter((c) => c.hasTwoLetters).length;\n        const amountOfThreeLetters = checksumCounter.filter((c) => c.hasThreeLetters).length;\n\n        await outputCallback(\"Checksum: \" + amountOfTwoLetters * amountOfThreeLetters);\n    },\n    async ({lines, outputCallback}) => {\n        const stringLength = lines[0].length;\n        for (let i = 0; i < stringLength; i++) {\n            const spliced = lines.map((l) => l.slice(0, i) + l.slice(i + 1, l.length));\n            const duplicates = new Set<string>();\n            const hasFoundDuplicate = spliced.some((l) => {\n                if (duplicates.has(l)) {\n                    // tslint:disable-next-line:no-floating-promises\n                    outputCallback(l);\n                    return true;\n                } else {\n                    duplicates.add(l);\n                    return false;\n                }\n            });\n            if (hasFoundDuplicate) {\n                return;\n            }\n        }\n        await outputCallback(\"Something wen wrong\");\n    },\n    { key: \"inventory\", title: \"Inventory Management System\", stars: 2, }\n);\n","import { Entry, oldEntryForFile, entryForFile } from \"../../entry\";\nimport { Coordinate } from \"../../../support/geometry\";\n\ninterface Rectangle {\n    id: number;\n    position: Coordinate;\n    size: Coordinate;\n}\n\ntype Map = boolean[][];\n\nlet isFirstTime = true;\nconst parseRectangle = (line: string, output: (l: string) => void): Rectangle => {\n    const trimmed = line.trim();\n    const noSpaces = trimmed.replace(/ /g, \"\");\n    const normalizedDelimiters = noSpaces.replace(\"#\", \"\").replace(\"@\", \" \").replace(\":\", \" \");\n    if (isFirstTime) {\n        isFirstTime = false;\n        output(noSpaces);\n        output(normalizedDelimiters);\n    }\n    const split = normalizedDelimiters.split(\" \");\n    const id = parseInt(split[0], 10);\n    const fromCoupleToCoordinate = (s: string, d: string): Coordinate => {\n        const argSplit = s.split(d);\n        return {\n            x: parseInt(argSplit[0], 10),\n            y: parseInt(argSplit[1], 10),\n        };\n    };\n    const position = fromCoupleToCoordinate(split[1], \",\");\n    const size = fromCoupleToCoordinate(split[2], \"x\");\n\n    return {\n        id,\n        position,\n        size,\n    };\n};\nexport const entry: Entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        const map = mapCreator(lines.map((e) => parseRectangle(e, outputCallback)), outputCallback);\n\n        const total = map.reduce<number>((acc, current) => acc + current.filter((e) => e).length, 0);\n        await outputCallback(\"\" + total);\n    },\n    async ({lines, outputCallback}) => {\n        const rectangles = lines.map((e) => parseRectangle(e, outputCallback));\n        const map = mapCreator(rectangles, outputCallback);\n\n        const candidate = rectangles.find((r) => {\n            let isCandidate = true;\n            executeOnMap(r, (argMap: Map, coordinate: Coordinate) => {\n                if (argMap[coordinate.x][coordinate.y]) {\n                    isCandidate = false;\n                }\n            }, map);\n            return isCandidate;\n        });\n        await outputCallback(candidate ? \"\" + candidate.id : \"null\");\n    },\n    { key: \"no-matter-how-you-slice-it\", title: \"No Matter How You Slice It\", stars: 2, }\n);\n\nfunction mapCreator(rectangles: Rectangle[], output: (s: string) => void) {\n    const size = 1000;\n    const map: Map = new Array<boolean[]>(size);\n    for (let i = 0; i < size; i++) {\n        map[i] = new Array<boolean>(size);\n    }\n    const first = rectangles[0];\n    output(`First Rectangle: ${first.size.x}x${first.size.y}`);\n    const callback = (argMap: Map, coordinate: Coordinate) => {\n        if (argMap[coordinate.x][coordinate.y] === undefined) {\n            argMap[coordinate.x][coordinate.y] = false;\n        } else {\n            argMap[coordinate.x][coordinate.y] = true;\n        }\n    };\n    rectangles.forEach((r) => executeOnMap(r, callback, map));\n    return map;\n\n}\n\nfunction executeOnMap(r: Rectangle, callback: (map: boolean[][], coordinate: Coordinate) => void, map: boolean[][]) {\n    for (let i = 0; i < r.size.x; i++) {\n        for (let j = 0; j < r.size.y; j++) {\n            const coordinate: Coordinate = {\n                x: i + r.position.x,\n                y: j + r.position.y,\n            };\n            callback(map, coordinate);\n        }\n    }\n}\n\n","/* tslint:disable-next-line */\nexport const log = (o: any) => console.log(o);\n/* tslint:disable-next-line */\nexport const warn = (o: any) => console.warn(o);\n/* tslint:disable-next-line */\nexport const error = (o: any) => console.error(o);\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport Best from \"../../../support/best\";\nimport { warn } from \"../../../support/log\";\n\nclass GuardSleep {\n    public id: number;\n    public from: number | null = null;\n    public to: number | null = null;\n    constructor(guardID: number) {\n        this.id = guardID;\n    }\n\n    public get howMuch(): number {\n        if (this.from === null || this.to === null) {\n            throw Error(\"From or to were null\");\n        }\n        return this.to - this.from;\n    }\n\n    public isSleepingInMinute(minute: number) {\n        if (this.from === null || this.to === null) {\n            throw Error(\"From or to were null\");\n        }\n        return this.from <= minute && this.to > minute;\n    }\n\n\n}\nclass LogDate {\n    public minutes: number;\n    private dateText: string;\n    constructor(line: string) {\n        const dateLastIndex = line.indexOf(\"]\");\n        const dateText = line.slice(1, dateLastIndex);\n        this.dateText = dateText;\n        this.minutes = parseInt(this.dateText.split(\":\")[1], 10);\n    }\n    public compare(other: LogDate): number {\n        return this.dateText.localeCompare(other.dateText);\n    }\n\n    public toString(): string {\n        return this.dateText;\n    }\n}\nclass LogEntry {\n    public guardID: number | null = null;\n    public wakes: boolean = false;\n    public fallsAsleep: boolean = false;\n    public dateToken: LogDate;\n\n    constructor(line: string) {\n        this.dateToken = new LogDate(line);\n        if (line.includes(\"wakes\")) {\n            this.wakes = true;\n        } else if (line.includes(\"asleep\")) {\n            this.fallsAsleep = true;\n        } else {\n            const idStartIndex = line.indexOf(\"#\") + 1;\n            const idEndIndex = line.slice(idStartIndex).indexOf(\" \");\n            const sliced = line.slice(idStartIndex, idStartIndex + idEndIndex + 1);\n            this.guardID = parseInt(sliced, 10);\n        }\n    }\n\n    public toString(): string {\n        let post: string;\n        if (this.wakes) {\n            post = \"+\";\n        } else if (this.fallsAsleep) {\n            post = \"-\";\n        } else {\n            post = \"\" + this.guardID;\n        }\n        return `${this.dateToken} - ${post}`;\n    }\n\n    public compare(other: LogEntry) {\n        return this.dateToken.compare(other.dateToken);\n    }\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        const guardSleeps: {\n            [key: number]: GuardSleep[];\n        } = parseSleeps(lines);\n\n        let currentMax: [number, GuardSleep[]] | null = null;\n        for (const guardIDKey of Object.keys(guardSleeps)) {\n            const nestedGuardID = parseInt(guardIDKey, 10);\n            const sleeps = guardSleeps[nestedGuardID];\n            const totalSleep = sleeps.map((s) => s.howMuch).reduce((acc, curr) => acc + curr);\n            if (!currentMax || totalSleep > currentMax[0]) {\n                currentMax = [totalSleep, sleeps];\n            }\n        }\n\n        let bestMinute: [number, number] | null = null;\n\n        if (!currentMax) {\n            throw Error(\"No current max found\");\n        }\n        for (let i = 0; i < 60; i++) {\n            const sleeps = currentMax[1];\n            const howManyIntervals = sleeps.filter((interval) => interval.isSleepingInMinute(i)).length;\n            if (!bestMinute || howManyIntervals > bestMinute[0]) {\n                bestMinute = [howManyIntervals, i];\n            }\n        }\n        const mostSleepingMinute = bestMinute![1];\n        const guardID = currentMax[1][0].id;\n        await outputCallback(\"\" + mostSleepingMinute * guardID);\n\n    },\n    async ({lines, outputCallback}) => {\n        const guardSleeps = parseSleeps(lines);\n        const totalMaxSleep = new Best<number>();\n        for (const guardIDKey of Object.keys(guardSleeps)) {\n            const guardID = parseInt(guardIDKey, 10);\n            const maxSleep = new Best<number>();\n            const sleeps = guardSleeps[guardID];\n            for (let i = 0; i < 60; i++) {\n                const howMany = sleeps.filter((interval) => interval.isSleepingInMinute(i)).length;\n                maxSleep.add({ key: howMany, value: i });\n            }\n            totalMaxSleep.add({\n                key: maxSleep.currentBest!.key,\n                value: guardID * maxSleep.currentBest!.value,\n            });\n        }\n        await outputCallback(\"\" + totalMaxSleep.currentBest!.value);\n\n    },\n    { key: \"repose-record\", title: \"Repose Record\", stars: 2, }\n);\n\nfunction parseSleeps(lines: string[]) {\n    const entries = lines.map((l) => new LogEntry(l)).sort((a, b) => a.compare(b));\n    let isAsleep = false;\n    // sanity check\n    entries.forEach((e) => {\n        if (e.wakes) {\n            if (!isAsleep) {\n                warn(\"Was not sleeping!\");\n            }\n            isAsleep = false;\n        } else if (e.fallsAsleep) {\n            if (isAsleep) {\n                warn(\"Was already sleeping\");\n            }\n            isAsleep = true;\n        }\n    });\n    const guardSleeps: {\n        [key: number]: GuardSleep[];\n    } = {};\n    let currentGuardSleep: GuardSleep;\n    entries.forEach((e) => {\n        if (e.guardID) {\n            currentGuardSleep = new GuardSleep(e.guardID);\n        } else if (e.fallsAsleep) {\n            currentGuardSleep.from = e.dateToken.minutes;\n        } else if (e.wakes) {\n            currentGuardSleep.to = e.dateToken.minutes;\n            if (!(currentGuardSleep.id in guardSleeps)) {\n                guardSleeps[currentGuardSleep.id] = [];\n            }\n            guardSleeps[currentGuardSleep.id].push(currentGuardSleep);\n            currentGuardSleep = new GuardSleep(currentGuardSleep.id);\n        }\n    });\n    return guardSleeps;\n}\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport Best from \"../../../support/best\";\n// import { log } from \"../../support/log\";\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        if (lines.length > 1) {\n            throw Error(\"Only one line expected\");\n        }\n        let polymerText = lines[0];\n\n        await outputCallback(\"Start length: \" + polymerText.length);\n        polymerText = explodePolymer(polymerText);\n        await outputCallback(polymerText.length);\n\n    },\n    async ({lines, outputCallback}) => {\n        if (lines.length > 1) {\n            throw Error(\"Only one line expected\");\n        }\n        let polymerText = lines[0];\n\n        const max = new Best<string>();\n        const unitList = new Set<string>(polymerText.toLowerCase().split(\"\"));\n        polymerText = explodePolymer(polymerText);\n        unitList.forEach((unit) => {\n            const cleanPolymer = polymerText.replace(new RegExp(`[${unit}${unit.toUpperCase()}]`, \"g\"), \"\");\n            const exploded = explodePolymer(cleanPolymer);\n            max.add({ key: polymerText.length - exploded.length, value: exploded });\n        });\n        await outputCallback(max.currentBest!.value.length);\n    },\n    { key: \"alchemical-reduction\", title: \"Alchemical Reduction\", stars: 2, }\n);\n\nfunction explodePolymer(polymerText: string) {\n    let i = 0;\n    while (i < polymerText.length - 1) {\n        if (polymerText[i] !== polymerText[i + 1]\n            && polymerText[i].toLowerCase() === polymerText[i + 1].toLowerCase()\n        ) {\n            polymerText = polymerText.slice(0, i) + polymerText.slice(i + 2);\n            i = 0;\n        } else {\n            i++;\n        }\n    }\n    return polymerText;\n}\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport { Coordinate, sumCoordinate } from \"../../../support/geometry\";\nimport Best, { SimpleBest, CustomBest, maxNumber } from \"../../../support/best\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { Queue } from \"../../../support/data-structure\";\n// import { log } from \"@/support/log\";\n\ninterface Territory {\n  coordinate: Coordinate;\n  id: number | null;\n  distance: number;\n}\n\nexport const entry = entryForFile(\n  async ({lines, outputCallback}) => {\n    let points: Coordinate[] = parsePoints(lines);\n\n    const { minX, minY, size } = getBoundaries(points);\n\n    points = points.map((p) => {\n      return {\n        x: p.x - minX.currentBest!,\n        y: p.y - minY.currentBest!,\n      };\n    });\n\n    const grid = new FixedSizeMatrix<Territory>(size);\n\n    const queue = new Queue<Territory>();\n    const territoryPoints = points.map((p, index) => {\n      return {\n        coordinate: p,\n        distance: 0,\n        id: index + 1,\n      };\n    });\n    territoryPoints.forEach((p) => {\n      grid.set(p.coordinate, p);\n      queue.add(p);\n    });\n\n    const offsets = (() => {\n      const numberOffsets = [1, 0, -1];\n      return numberOffsets.map((i) => numberOffsets.map((j) => i === j || (i !== 0 && j !== 0) ? null : {\n        x: i,\n        y: j,\n      }).filter((l) => l)).reduce((acc, curr) => acc.concat(curr));\n    })();\n    if (offsets.length !== 4) {\n      throw Error(\"What happened to the offsets?\");\n    }\n\n    while (!queue.isEmpty) {\n      const nextElement = queue.get();\n      if (nextElement) {\n        offsets.forEach((offset) => {\n          const newCoordinate = sumCoordinate(nextElement.coordinate, offset!);\n          if (newCoordinate.x >= 0 && newCoordinate.y >= 0\n            && newCoordinate.x < size.x && newCoordinate.y < size.y) {\n\n            const newDistance = nextElement.distance + 1;\n            const gridStatus = grid.get(newCoordinate);\n            if (!gridStatus) {\n              const newElement = {\n                coordinate: newCoordinate,\n                distance: newDistance,\n                id: nextElement.id,\n              };\n              grid.set(newCoordinate, newElement);\n              queue.add(newElement);\n            } else if (gridStatus.distance === newDistance && gridStatus.id !== nextElement.id) {\n              const newElement: Territory = {\n                id: null,\n                coordinate: newCoordinate,\n                distance: newDistance,\n              };\n              grid.set(newCoordinate, newElement);\n              queue.add(newElement);\n            }\n          }\n        });\n      }\n    }\n\n\n    // imgCreator(0, grid);\n    const currentCount: { [key: number]: number } = {};\n    for (let i = 0; i < size.x; i++) {\n      for (let j = 0; j < size.y; j++) {\n        const status = grid.get({\n          x: i,\n          y: j,\n        });\n        if (status === undefined) {\n          await outputCallback(\"\" + i + \" \" + j);\n        } else if (!status.id) {\n          continue;\n        } else if (status.coordinate.x === 0 || status.coordinate.y === 0\n          || status.coordinate.x === size.x - 1 || status.coordinate.y === size.y - 1) {\n          currentCount[status.id] = 0;\n        } else {\n          if (!(status.id in currentCount)) {\n            currentCount[status.id] = 1;\n          } else if (currentCount[status.id] !== 0) {\n            currentCount[status.id]++;\n          }\n        }\n      }\n    }\n\n    const bestArea = new SimpleBest<number>(maxNumber);\n    for (const key of Object.keys(currentCount)) {\n      bestArea.add(currentCount[parseInt(key, 10)]);\n    }\n    await outputCallback(bestArea.currentBest);\n\n\n\n  },\n  async ({lines, outputCallback}) => {\n    function manhattan(a: Coordinate, b: Coordinate) {\n      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    }\n    const points = parsePoints(lines);\n    const { minX, minY, size } = getBoundaries(points);\n    const maxDistance = 10000;\n    let count = 0;\n    for (let i = 0; i < size.x; i++) {\n      for (let j = 0; j < size.y; j++) {\n        const distanceSum = points.map((p) => manhattan(p, {\n          x: i + minX.currentBest!,\n          y: j + minY.currentBest!,\n        })).reduce((acc, curr) => acc + curr);\n        if (distanceSum < maxDistance) {\n          count++;\n        }\n      }\n    }\n    await outputCallback(count);\n  },\n  { key: \"chronal-coordinates\", title: \"Chronal Coordinates\", stars: 2, }\n);\n\nfunction getBoundaries(points: Coordinate[]) {\n  const minComparator = (a: number, b: number) => b - a;\n  const maxComparator = (a: number, b: number) => a - b;\n  const minX = new SimpleBest<number>(minComparator);\n  const maxX = new SimpleBest<number>(maxComparator);\n  const minY = new SimpleBest<number>(minComparator);\n  const maxY = new SimpleBest<number>(maxComparator);\n  points.forEach((p) => {\n    minX.add(p.x);\n    maxX.add(p.x);\n    minY.add(p.y);\n    maxY.add(p.y);\n  });\n  const size = {\n    x: (maxX.currentBest! - minX.currentBest! + 1),\n    y: (maxY.currentBest! - minY.currentBest! + 1),\n  };\n  return { minX, minY, size };\n}\n\nfunction parsePoints(lines: string[]): Coordinate[] {\n  return lines.map((l) => l.replace(/ /g, \"\").split(\",\")).map((couple) => {\n    return {\n      x: parseInt(couple[0], 10),\n      y: parseInt(couple[1], 10),\n    };\n  });\n}\n","import { DefaultListDictionaryString } from \"../../../support/data-structure\";\n// import { log } from \"@/support/log\";\nimport { oldEntryForFile, entryForFile } from \"../../entry\";\n\nclass Graph {\n    private nodes: { [key: string]: Node } = {};\n    constructor(lines: string[]) {\n        lines.forEach((line) => {\n            const split = line.split(\" \");\n            const dependency = split[1];\n            const nodeName = split[7];\n            this.ensureNode(dependency);\n            this.ensureNode(nodeName);\n\n            this.nodes[nodeName].dependentFrom(this.nodes[dependency]);\n        });\n    }\n\n    public isDone(): boolean {\n        for (const key of Object.keys(this.nodes)) {\n            const node = this.nodes[key];\n            if (node.wip || !node.isDone) {\n                return false;\n            }\n        }\n        return true;\n\n    }\n\n    public getNextNode(): Node | null {\n        const candidates = [];\n        for (const key of Object.keys(this.nodes)) {\n            const node = this.nodes[key];\n            if (!node.isDone && !node.wip && !node.hasDependencies()) {\n                candidates.push(node);\n            }\n        }\n        if (candidates.length === 0) {\n            return null;\n        }\n        const result = candidates.sort((a, b) => a.name.localeCompare(b.name))[0];\n        result.wip = true;\n        return result;\n    }\n    private ensureNode(name: string) {\n        if (!(name in this.nodes)) {\n            this.nodes[name] = new Node(name);\n        }\n    }\n}\nclass Node {\n    public dependencies: Node[] = [];\n    public isDone: boolean = false;\n    public wip: boolean = false;\n    constructor(public name: string) {\n\n    }\n\n    public dependentFrom(other: Node) {\n        this.dependencies.push(other);\n    }\n\n    public duration(): number {\n        return this.name.toLowerCase().charCodeAt(0) - \"a\".charCodeAt(0) + 61;\n    }\n\n    public remove(): void {\n        this.isDone = true;\n    }\n\n    public hasDependencies(): boolean {\n        return this.dependencies.some((d) => !d.isDone);\n    }\n}\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        const graph = new Graph(lines);\n        const nodes = [];\n        while (true) {\n            const node = graph.getNextNode();\n            if (node === null) {\n                break;\n            } else {\n                node.isDone = true;\n                nodes.push(node.name);\n            }\n        }\n        await outputCallback(nodes.join(\"\"));\n    },\n    async ({lines, outputCallback}) => {\n        const graph = new Graph(lines);\n        const howManyWorkers = 5;\n        const workers = new Array<Node | null>(howManyWorkers);\n        for (let i = 0; i < howManyWorkers; i++) {\n            workers[i] = null;\n        }\n        const callbacks = new DefaultListDictionaryString<() => Promise<void>>();\n        let done = false;\n        let currentSecond = 0;\n        while (!done) {\n            const call = callbacks.get(\"\" + currentSecond);\n            for (const c of call) {\n                await c();\n            }\n            callbacks.remove(\"\" + currentSecond);\n            if (graph.isDone()) {\n                done = true;\n            } else {\n                for (let i = 0; i < howManyWorkers; i++) {\n                    if (workers[i] === null) {\n                        const nextNode = graph.getNextNode();\n                        if (nextNode !== null) {\n                            workers[i] = nextNode;\n                            const workerIndex = i;\n                            const targetTime = (currentSecond + nextNode.duration());\n                            await outputCallback(\"Adding to target \" + targetTime + \" node \" + nextNode.name);\n                            callbacks.add(\"\" + targetTime, async () => {\n                                await outputCallback(\"Node \" + nextNode.name + \" done\");\n                                nextNode.isDone = true;\n                                nextNode.wip = false;\n                                workers[workerIndex] = null;\n                            });\n                        }\n                    }\n                }\n                currentSecond++;\n            }\n        }\n        await outputCallback(currentSecond);\n    },\n    { key: \"the-sum-of-its-parts\", title: \"The Sum of Its Parts\", stars: 2, }\n);\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\n// import { log } from \"@/support/log\";\n\nclass Node {\n    public nodes: Node[] = [];\n    public metadata: number[] = [];\n\n    public value(): number {\n        if (this.nodes.length === 0) {\n            let sum = 0;\n            this.metadata.forEach((m) => sum += m);\n            return sum;\n        } else {\n            const nodes = this.nodes;\n            return this.metadata.map((m) => {\n                const index = m - 1;\n                if (index >= 0 && nodes[index] !== undefined) {\n                    const subValue = nodes[index].value();\n                    return subValue;\n                } else {\n                    return 0;\n                }\n            }).reduce((acc, curr) => acc + curr, 0);\n        }\n    }\n}\n\nfunction getTree(tokens: string[], startIndex: number, outputCallback: (s: any) => void): [Node, number] {\n    let numberOfChildren = parseInt(tokens[startIndex], 10);\n    const numberOfMetadata = parseInt(tokens[startIndex + 1], 10);\n    startIndex += 2;\n    if (numberOfChildren === 0) {\n        const metadata = tokens.slice(startIndex, startIndex + numberOfMetadata);\n        const parsedMetadata = metadata.map((m) => parseInt(m, 10));\n        if (parsedMetadata.some(isNaN)) {\n            outputCallback(parsedMetadata);\n        }\n        const node = new Node();\n        node.metadata = parsedMetadata;\n        node.nodes = [];\n        return [node, startIndex + numberOfMetadata];\n    } else {\n        const node = new Node();\n        while (numberOfChildren > 0) {\n            const [child, newStart] = getTree(tokens, startIndex, outputCallback);\n            node.nodes.push(child);\n            startIndex = newStart;\n            numberOfChildren--;\n        }\n        const metadata = tokens.slice(startIndex, startIndex + numberOfMetadata).map((e) => parseInt(e, 10));\n        if (metadata.some(isNaN)) {\n            outputCallback(tokens.slice(startIndex, startIndex + numberOfMetadata));\n        }\n        node.metadata = metadata;\n        return [node, startIndex + numberOfMetadata];\n    }\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        const line = lines[0];\n        const tokens = line.split(\" \");\n\n        const calcMetadataSum = (argTree: Node): number => {\n            let sum = 0;\n            argTree.nodes.forEach((node) => {\n                sum += calcMetadataSum(node);\n            });\n            argTree.metadata.forEach((m) => {\n                sum += m;\n            });\n            return sum;\n        };\n\n        async function printMetadata(argTree: Node) {\n            await outputCallback(argTree.metadata);\n            for (const n of argTree.nodes) {\n                await printMetadata(n);\n            }\n        }\n\n        const [tree, endIndex] = getTree(tokens, 0, outputCallback);\n        await printMetadata(tree);\n        await outputCallback(\"\" + endIndex + \" \" + tokens.length);\n        await outputCallback(calcMetadataSum(tree));\n    },\n    async ({lines, outputCallback}) => {\n        const line = lines[0];\n        const tokens = line.split(\" \");\n        const [tree, endIndex] = getTree(tokens, 0, outputCallback);\n        await outputCallback(tree.value());\n    },\n    { key: \"memory-maneuver\", title: \"Memory Maneuver\", stars: 2, }\n);\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport { CircularDoubleLinkedNode } from \"../../../support/data-structure\";\nimport { SimpleBest, maxNumber } from \"../../../support/best\";\n// import { log } from \"@/support/log\";\n\nclass Game {\n    private marbleNodes: CircularDoubleLinkedNode<number> | null = null;\n    private nextMarble: number = 0;\n    private scores: number[];\n    private lastPlayer: number = 0;\n\n    constructor(private numberOfPlayers: number, private lastMarble: number) {\n        this.scores = new Array<number>(numberOfPlayers);\n        for (let i = 0; i < numberOfPlayers; i++) {\n            this.scores[i] = 0;\n        }\n    }\n\n    public addMarble(playerID: number | null = null): boolean {\n        if (playerID === null) {\n            playerID = this.lastPlayer;\n        }\n        const marble = this.nextMarble++;\n        if (marble === 0 || marble % 23 !== 0) {\n            if (marble === 0) {\n                this.marbleNodes = new CircularDoubleLinkedNode<number>(marble);\n            } else {\n                this.marbleNodes = this.marbleNodes!.next.append(marble);\n            }\n        } else {\n            let currentScore = marble;\n            let currentHead = this.marbleNodes!;\n            for (let i = 0; i < 6; i++) {\n                currentHead = currentHead.prev;\n            }\n            currentScore += currentHead.removePrevious();\n            this.marbleNodes = currentHead;\n            this.scores[playerID] += currentScore;\n        }\n        this.lastPlayer = playerID;\n        return marble !== this.lastMarble;\n    }\n\n    public switchPlayer() {\n        this.lastPlayer = (this.lastPlayer + 1) % this.numberOfPlayers;\n    }\n\n    public highestScores(): number {\n        const max = new SimpleBest<number>(maxNumber);\n        this.scores.forEach((s) => max.add(s));\n        return max.currentBest!;\n    }\n\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        const tokens = lines[0].split(\" \");\n        const players = parseInt(tokens[0], 10);\n        const lastMarble = parseInt(tokens[6], 10);\n        const game = new Game(players, lastMarble);\n        while (game.addMarble()) {\n            game.switchPlayer();\n        }\n        await outputCallback(game.highestScores());\n    },\n    async ({lines, outputCallback}) => {\n        const tokens = lines[0].split(\" \");\n        const players = parseInt(tokens[0], 10);\n        const lastMarble = parseInt(tokens[6], 10) * 100;\n        const game = new Game(players, lastMarble);\n        while (game.addMarble()) {\n            game.switchPlayer();\n        }\n        await outputCallback(game.highestScores());\n    },\n    { key: \"marble-mania\", title: \"Marble Mania\", stars: 2, }\n);\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport { Coordinate, sumCoordinate, getBoundaries, Bounds } from \"../../../support/geometry\";\n// import { log } from \"@/support/log\";\n\nclass MovablePoint {\n\n    public static FromLine(line: string): MovablePoint {\n        line = line.replace(/ /g, \"\");\n        const firstPart = line.slice(line.indexOf(\"<\") + 1, line.indexOf(\">\"));\n        let secondPart = line.slice(line.indexOf(\">\") + 1);\n        secondPart = secondPart.slice(secondPart.indexOf(\"<\") + 1, secondPart.indexOf(\">\"));\n        const coordinateTokens = firstPart.split(\",\");\n        const speedTokens = secondPart.split(\",\");\n        return new MovablePoint(\n            {\n                x: parseInt(coordinateTokens[0], 10),\n                y: parseInt(coordinateTokens[1], 10),\n            },\n            {\n                x: parseInt(speedTokens[0], 10),\n                y: parseInt(speedTokens[1], 10),\n            },\n        );\n\n    }\n    constructor(\n        public coordinates: Coordinate,\n        public speed: Coordinate,\n    ) {\n\n    }\n\n    public move(): MovablePoint {\n        return new MovablePoint(\n            sumCoordinate(this.coordinates, this.speed),\n            this.speed,\n        );\n    }\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        let points = lines.map((line) => MovablePoint.FromLine(line));\n        let lastBoundaries: Bounds | null = null;\n        let lastPoints: typeof points | null = null;\n        let done = false;\n        function getArea(size: Coordinate) {\n            return size.x * size.y;\n        }\n        while (!done) {\n            const newPoints = points.map((p) => p.move());\n            const boundaries = getBoundaries(newPoints.map((p) => p.coordinates));\n            if (lastBoundaries === null) {\n                lastBoundaries = boundaries;\n                lastPoints = newPoints;\n            } else {\n                if (getArea(lastBoundaries.size) < getArea(boundaries.size)) {\n                    done = true;\n                } else {\n                    lastBoundaries = boundaries;\n                    lastPoints = newPoints;\n                }\n            }\n            points = newPoints;\n        }\n        const mappedPoints = lastPoints!.map((p) => p.coordinates)\n            .map((c) => ({\n                x: c.x - lastBoundaries!.topLeft.x,\n                y: c.y - lastBoundaries!.topLeft.y\n            }))\n            .sort((a, b) => (a.y - b.y) * 100000 + a.x - b.x);\n        const dataMatrix: string[][] = [];\n        for (let y = 0; y < lastBoundaries!.size.y; y++) {\n            const l = [];\n            for (let x = 0; x < lastBoundaries!.size.x; x++) {\n                l.push(\" \");\n            }\n            dataMatrix.push(l);\n        }\n        mappedPoints.forEach((p) => {\n            dataMatrix[p.y][p.x] = \"#\";\n        });\n        for (const l of dataMatrix) {\n            await outputCallback(l.join(\"\"));\n        }\n    },\n    async ({lines, outputCallback}) => {\n        let points = lines.map((line) => MovablePoint.FromLine(line));\n        let lastBoundaries: Bounds | null = null;\n        let lastPoints: typeof points | null = null;\n        let done = false;\n        function getArea(size: Coordinate) {\n            return size.x * size.y;\n        }\n        let iterationCounter = 0;\n        while (!done) {\n            iterationCounter++;\n            const newPoints = points.map((p) => p.move());\n            const boundaries = getBoundaries(newPoints.map((p) => p.coordinates));\n            if (lastBoundaries === null) {\n                lastBoundaries = boundaries;\n                lastPoints = newPoints;\n            } else {\n                if (getArea(lastBoundaries.size) < getArea(boundaries.size)) {\n                    done = true;\n                } else {\n                    lastBoundaries = boundaries;\n                    lastPoints = newPoints;\n                }\n            }\n            points = newPoints;\n        }\n        await outputCallback(iterationCounter - 1);\n    },\n    { key: \"stars-align\", title: \"The Stars Align\", stars: 2, }\n);\n","import { CustomBest, maxNumber } from \"../../../support/best\";\nimport { Coordinate } from \"../../../support/geometry\";\nimport { oldEntryForFile, entryForFile } from \"../../entry\";\nimport { BigInteger } from \"big-integer\";\nimport bigInt from \"big-integer\";\nimport { forEachAsync } from \"../../../support/async\";\n\nclass FuelGrid {\n\n    private sumTable: BigInteger[][] | null = null;\n    constructor(private seed: number, private outputCallback: (s: any) => void) {\n    }\n\n    public getRackID(c: Coordinate) {\n        return c.x + 10;\n    }\n\n    public populate(size: number) {\n        const table: BigInteger[][] = [];\n        const originalTable: BigInteger[][] = [];\n        let countPositive = 0;\n        let countNegative = 0;\n        for (let y = 0; y < size; y++) {\n            const line: BigInteger[] = [];\n            const originalLine: BigInteger[] = [];\n            for (let x = 0; x < size; x++) {\n                const currentValue = bigInt(this.getFuelStatus({ x, y }));\n                originalLine.push(currentValue);\n                if (currentValue.lesser(0)) {\n                    countNegative++;\n                } else if (currentValue.greater(0)) {\n                    countPositive++;\n                }\n                if (currentValue.abs().greater(5)) {\n                    throw Error(\"WTF?\");\n                }\n                let currentSum = currentValue;\n                if (x > 0) {\n                    currentSum = currentSum.add(line[x - 1]);\n                    if (y > 0) {\n                        currentSum = currentSum.subtract(table[y - 1][x - 1]);\n                    }\n                }\n                if (y > 0) {\n                    currentSum = currentSum.add(table[y - 1][x]);\n                }\n                line.push(currentSum);\n            }\n            table.push(line);\n            originalTable.push(originalLine);\n        }\n        this.sumTable = table;\n        // this.printTable(originalTable);\n        // this.outputCallback(\"\");\n        // this.printTable(table);\n    }\n\n    public getAreaSum(topLeft: Coordinate, size: Coordinate) {\n        if (this.sumTable === null) {\n            throw Error(\"Table not populated!\");\n        }\n\n        size = {\n            x: size.x - 1,\n            y: size.y - 1\n        };\n\n        let area = this.sumTable[topLeft.y + size.y][topLeft.x + size.x];\n        if (topLeft.y - 1 >= 0) {\n            area = area.subtract(this.sumTable[topLeft.y - 1][topLeft.x + size.x]);\n            if (topLeft.x - 1 >= 0) {\n                area = area.add(this.sumTable[topLeft.y - 1][topLeft.x - 1]);\n            }\n        }\n        if (topLeft.x - 1 >= 0) {\n            area = area.subtract(this.sumTable[topLeft.y + size.y][topLeft.x - 1]);\n        }\n\n        return area;\n\n        // return this.sumTable[topLeft.y + size.y][topLeft.x + size.x]\n        //     .subtract(this.sumTable[topLeft.y + size.y][topLeft.x])\n        //     .subtract(this.sumTable[topLeft.y][topLeft.x + size.x])\n        //     .add(this.sumTable[topLeft.y][topLeft.x]);\n    }\n\n\n    public getFuelStatus(c: Coordinate, throwIfMissing: boolean = false) {\n        const id = this.getRackID(c);\n        let powerLevel = id * c.y;\n        powerLevel += this.seed;\n        powerLevel *= id;\n        if (powerLevel < 100) {\n            powerLevel = 0;\n        } else {\n            powerLevel = Math.floor(powerLevel / 100) % 10;\n        }\n        powerLevel -= 5;\n        return powerLevel;\n    }\n\n    private printTable(table: BigInteger[][]) {\n        const output = table.map((line) => {\n            return line.map((c) => (\"\" + c).padStart(8, \" \")).join(\" \");\n        }).join(\"\\n\");\n        this.outputCallback(output);\n    }\n\n    // public getFuelSumForTopLeft(c: Coordinate, cellSize: number) {\n    //     let sum = 0;\n    //     for (let dx = 0; dx < cellSize; dx++) {\n    //         for (let dy = 0; dy < cellSize; dy++) {\n    //             sum += this.getFuelStatus({\n    //                 x: c.x + dx,\n    //                 y: c.y + dy\n    //             });\n    //         }\n    //     }\n    //     return sum;\n    // }\n}\n\nasync function main(lines: string[], outputCallback: ((s: any) => void), cellSizes: number[]) {\n    const serial = parseInt(lines[0], 10);\n    const grid = new FuelGrid(serial, outputCallback);\n    const size = 300;\n    grid.populate(size);\n    const bestPoint = new CustomBest<BigInteger, Coordinate & { iteration: number }>(\n        (a, b) => a.subtract(b).toJSNumber()\n    );\n    await forEachAsync(cellSizes, async (cellSize) => {\n        await outputCallback(\"Iteration \" + cellSize);\n        for (let x = 0; x < size - (cellSize - 1); x++) {\n            for (let y = 0; y < size - (cellSize - 1); y++) {\n                bestPoint.add({\n                    value: { x, y, iteration: cellSize },\n                    key: grid.getAreaSum({ x, y }, { x: cellSize, y: cellSize })\n                });\n            }\n        }\n    });\n    await outputCallback(\n        `Coordinate: ${JSON.stringify(bestPoint.currentBest!.value)} with ${bestPoint.currentBest!.key}`\n    );\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        await main(lines, outputCallback, [3]);\n    },\n    async ({lines, outputCallback}) => {\n        const cellSizes: number[] = [];\n        for (let i = 1; i < 301; i++) {\n            cellSizes.push(i);\n        }\n        await main(lines, outputCallback, cellSizes);\n    },\n    { key: \"chronal-charge\", title: \"Chronal Charge\", stars: 2, }\n);\n","import { oldEntryForFile, entryForFile } from \"../../entry\";\nimport { DoubleLinkedNode } from \"../../../support/data-structure\";\nimport { howManySameAtEnd } from \"../../../support/sequences\";\n\nenum PlantStatus {\n    full = \"#\",\n    empty = \".\"\n}\n\nfunction toPlantStatus(s: string) {\n    if (s === \"#\") {\n        return PlantStatus.full;\n    } else {\n        return PlantStatus.empty;\n    }\n}\n\ninterface Pattern {\n    pattern: PlantStatus[];\n    result: PlantStatus;\n}\n\nclass Greenhouse {\n    private start: DoubleLinkedNode<PlantStatus> | null = null;\n    private end: DoubleLinkedNode<PlantStatus> | null = null;\n\n    constructor(initialStatus: PlantStatus[], private patterns: Pattern[], private startIndex: number = 0) {\n        // this.startIndex = 0;\n        initialStatus.forEach((s) => {\n            if (this.start === null) {\n                this.start = new DoubleLinkedNode<PlantStatus>(s);\n                this.end = this.start;\n            } else {\n                this.end = this.end!.append(s);\n            }\n        });\n        this.fixEmptyPots();\n    }\n\n    public get status() {\n        return {\n            status: this.start!.visitToRight(),\n            startIndex: this.startIndex\n        };\n    }\n\n    public get sum() {\n        const status = this.status;\n        const filled = status\n            .status\n            .map((e, index) => ({\n                index: index + status.startIndex,\n                value: e\n            }))\n            .filter((e) => e.value === PlantStatus.full)\n            .map((e) => e.index);\n        const sum = filled.reduce((acc, next) => acc + next);\n        return sum;\n    }\n\n    public passGeneration(): Greenhouse {\n        const newStatus: PlantStatus[] = [PlantStatus.empty, PlantStatus.empty];\n        let e = this.start!.next!.next!;\n        while (e.next!.next !== null) {\n            const nextFive = e.prev!.prev!.visitToRight(5);\n            if (nextFive.length !== 5) {\n                break;\n            }\n            const found = this.patterns.some((p) => {\n                let foundDifferent: boolean = false;\n                for (let i = 0; i < nextFive.length; i++) {\n                    if (p.pattern[i] !== nextFive[i]) {\n                        foundDifferent = true;\n                        break;\n                    }\n                }\n                if (foundDifferent) {\n                    return false;\n                } else {\n                    newStatus.push(p.result);\n                    return true;\n                }\n            });\n            if (!found) {\n                newStatus.push(PlantStatus.empty);\n            }\n            e = e.next!;\n        }\n        const newGreenhouse = new Greenhouse(newStatus, this.patterns, this.startIndex);\n        newGreenhouse.fixEmptyPots();\n        return newGreenhouse;\n        // this.fixEmptyPots();\n    }\n\n    public toString(): string {\n        if (this.start === null) {\n            return \"empty\";\n        } else {\n            return `${this.start.visitToRight().join(\"\")} ${this.startIndex}`;\n        }\n    }\n\n    public fixEmptyPots() {\n        const emptyBufferSize = 4;\n        let consecutiveEmptyPots = 0;\n        let e = this.start;\n        while (e !== null && e.value === PlantStatus.empty) {\n            consecutiveEmptyPots++;\n            e = e.next;\n        }\n        while (consecutiveEmptyPots < emptyBufferSize) {\n            this.start = this.start!.prepend(PlantStatus.empty);\n            this.startIndex--;\n            consecutiveEmptyPots++;\n        }\n        while (consecutiveEmptyPots > emptyBufferSize) {\n            this.start!.removeNext();\n            this.startIndex++;\n            consecutiveEmptyPots--;\n        }\n\n        consecutiveEmptyPots = 0;\n        e = this.end;\n        while (e !== null && e.value === PlantStatus.empty) {\n            consecutiveEmptyPots++;\n            e = e.prev;\n        }\n        while (consecutiveEmptyPots < emptyBufferSize) {\n            this.end = this.end!.append(PlantStatus.empty);\n            consecutiveEmptyPots++;\n        }\n        while (consecutiveEmptyPots > emptyBufferSize) {\n            this.end!.removePrev();\n            consecutiveEmptyPots--;\n        }\n    }\n}\n\nexport const entry = entryForFile(\n    async ({lines, outputCallback}) => {\n        let greenhouse = parseLines(lines);\n        for (let i = 0; i < 20; i++) {\n            greenhouse = greenhouse.passGeneration();\n        }\n        const sum = greenhouse.sum;\n        await outputCallback(sum);\n    },\n    async ({lines, outputCallback}) => {\n        let greenhouse = parseLines(lines);\n        let lastSum: number | null = null;\n        const diffs: number[] = [];\n        const generations = 50000000000;\n        for (let i = 1; i < 1000; i++) {\n            greenhouse = greenhouse.passGeneration();\n            const sum = greenhouse.sum;\n            if (lastSum) {\n                diffs.push(sum - lastSum);\n            }\n            lastSum = sum;\n            if (diffs.length > 20 && howManySameAtEnd(diffs) >= 20) {\n                const step = diffs[diffs.length - 1];\n                const todo = generations - i;\n                await outputCallback(sum + todo * step);\n                return;\n            }\n        }\n        await outputCallback(\"No pattern found\");\n        await outputCallback(JSON.stringify(diffs));\n    },\n    { key: \"subterranean\", title: \"Subterranean Substainability\", stars: 2, }\n);\nfunction parseLines(lines: string[]): Greenhouse {\n    const initialState = lines[0]\n        .slice(lines[0].indexOf(\":\") + 2)\n        .trim()\n        .split(\"\")\n        .map((e) => e === \"#\" ? PlantStatus.full : PlantStatus.empty);\n    const patterns: Pattern[] = lines\n        .slice(2)\n        .map((l) => l.trim())\n        .filter((l) => l.indexOf(\">\") > 0)\n        .map((l) => l.replace(/ /g, \"\").replace(/>/g, \"\").split(\"=\"))\n        .map((couple) => ({\n            result: toPlantStatus(couple[1]),\n            pattern: couple[0].split(\"\").map((p) => toPlantStatus(p))\n        }));\n    const greenhouse = new Greenhouse(initialState, patterns);\n    return greenhouse;\n}\n\n","import { Drawable, entryForFile, ScreenPrinter } from \"../../entry\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport {\n    CCoordinate,\n    Coordinate,\n    Rotation,\n    rotate,\n    directions,\n    manhattanDistance,\n    scalarCoordinates,\n    sumCoordinate,\n    serialization\n} from \"../../../support/geometry\";\n\ntype InputCell = \" \" | CartDirections | \"|\" | \"-\" | \"/\" | \"\\\\\" | \"+\";\ntype CartDirections = \"^\" | \">\" | \"v\" | \"<\";\n\nfunction parseLines(lines: string[]): Field {\n    const inputMatrix = new FixedSizeMatrix<InputCell>({ x: lines[0].length, y: lines.length });\n    inputMatrix.setFlatData(lines\n        .filter((l) => l.trim().length > 0)\n        .map((l) => l.split(\"\").map((c) => c as InputCell)).flat()\n    );\n    return new Field(inputMatrix);\n\n}\n\nfunction isInputCart(input: InputCell): input is CartDirections {\n    return [\"^\", \">\", \"v\", \"<\"].indexOf(input) >= 0;\n}\n\nfunction inputToDirection(input: CartDirections): CCoordinate {\n    switch (input) {\n        case \"<\":\n            return directions.left;\n        case \">\":\n            return directions.right;\n        case \"^\":\n            return directions.up;\n        case \"v\":\n            return directions.down;\n    }\n}\n\nclass Cart {\n    private intersectionsPassed: number = 0;\n\n    private crashed = false;\n\n    private readonly intersectionRotations: Rotation[] = [\n        \"Counterclockwise\", \"None\", \"Clockwise\"\n    ];\n\n    constructor(public position: Coordinate, public direction: CCoordinate) {\n\n    }\n\n    public toString() {\n        if (this.direction.y > 0) {\n            return \"v\";\n        } else if (this.direction.y < 0) {\n            return \"^\";\n        } else if (this.direction.x > 0) {\n            return \">\";\n        } else {\n            return \"<\";\n        }\n    }\n\n    public handleInput(inputGetter: (c: Coordinate) => InputCell): void {\n        if (this.crashed) {\n            return;\n        }\n        this.position = this.direction.sum(this.position);\n        const input = inputGetter(this.position);\n        switch (input) {\n            case \"-\":\n            case \"|\":\n                break;\n            case \"/\":\n            case \"\\\\\":\n                this.handleTurn(input);\n                break;\n            case \"+\":\n                this.handleIntersection();\n                break;\n\n        }\n    }\n\n    public crash() {\n        this.crashed = true;\n    }\n\n    public isCrashed() {\n        return this.crashed;\n    }\n\n    private handleIntersection() {\n        const rotation = this.intersectionRotations[(this.intersectionsPassed++) % this.intersectionRotations.length];\n        this.rotate(rotation);\n    }\n    private rotate(rotation: Rotation) {\n        this.direction = rotate(this.direction, rotation);\n    }\n\n    private handleTurn(turn: \"\\\\\" | \"/\") {\n        const rotation = this.getRotation(turn);\n        this.rotate(rotation);\n    }\n\n    private getRotation(turn: string) {\n        if (turn === \"/\") {\n            if (this.direction.x === 0) {\n                return \"Clockwise\";\n            } else {\n                return \"Counterclockwise\";\n            }\n        } else {\n            if (this.direction.y === 0) {\n                return \"Clockwise\";\n            } else {\n                return \"Counterclockwise\";\n            }\n        }\n    }\n}\n\ninterface Crash {\n    carts: Cart[];\n    position: Coordinate;\n}\n\nclass Field {\n\n    public get crashes() {\n        return [...this.crashList];\n    }\n    public get ticks() {\n        return this.internalTicks;\n    }\n    private readonly carts: Cart[] = [];\n    private internalTicks = 0;\n\n    private readonly crashList: Crash[] = [];\n    constructor(private matrix: FixedSizeMatrix<InputCell>) {\n        matrix.onEveryCell((coordinate, cell) => {\n            if (cell && isInputCart(cell)) {\n                const cartDirection = inputToDirection(cell);\n                this.carts.push(new Cart(coordinate, cartDirection));\n                this.hideCart(coordinate);\n            }\n        });\n    }\n\n    public get remainingCarts() {\n        return this.carts.filter((c) => !c.isCrashed());\n    }\n\n    public hasCrashes() {\n        return this.crashList.length > 0;\n    }\n\n    public tick() {\n        this.moveCarts();\n        this.incrementTicks();\n    }\n\n    public toString(skipCarts: boolean = false) {\n        return this.matrix.toString((e, coordinate) => {\n            if (!e) {\n                return \" \";\n            }\n            if (!coordinate || skipCarts) {\n                return e;\n            }\n            const matchingCarts = this.carts.filter((cart) => manhattanDistance(cart.position, coordinate) === 0);\n            if (matchingCarts.length === 0) {\n                return e;\n            } else if (matchingCarts.length === 1) {\n                return matchingCarts[0].toString();\n            } else {\n                return \"X\";\n            }\n        });\n    }\n\n    public toDrawable(size: Coordinate, skipCarts: boolean = false): Drawable[] {\n        const squareSize = Math.floor(Math.min(size.x / this.matrix.size.x, size.y / this.matrix.size.y));\n        const padding = 3;\n\n        const result: Drawable[] = [];\n        this.matrix.onEveryCellSync((c, e) => {\n            if (!e) {\n                return;\n            }\n            const baseCoordinates = scalarCoordinates(c, squareSize);\n            const matchingCarts = this.carts.filter((cart) => manhattanDistance(cart.position, c) === 0);\n            if (matchingCarts.length === 1) {\n                e = matchingCarts[0].toString();\n            } else if (matchingCarts.length > 1) {\n                result.push({\n                    id: serialization.serialize(c),\n                    c,\n                    color: \"red\",\n                    type: \"rectangle\",\n                    size: {x: squareSize, y: squareSize},\n                });\n                return;\n            }\n            switch (e) {\n                case \" \":\n                    return;\n                case \"+\":\n                    result.push({\n                        type: \"rectangle\",\n                        c: sumCoordinate(baseCoordinates, {x: 0, y: padding}),\n                        color: \"white\",\n                        size: {x: squareSize, y: squareSize - padding * 2},\n                        id: serialization.serialize(c) + \"-\"\n                    });\n                    result.push({\n                        type: \"rectangle\",\n                        c: sumCoordinate(baseCoordinates, {x: padding, y: 0}),\n                        color: \"white\",\n                        size: {x: squareSize - padding * 2, y: squareSize},\n                        id: serialization.serialize(c) + \"|\"\n                    });\n                    break;\n                case \"|\":\n                    result.push({\n                        type: \"rectangle\",\n                        c: sumCoordinate(baseCoordinates, {x: padding, y: 0}),\n                        color: \"white\",\n                        size: {x: squareSize - padding * 2, y: squareSize},\n                        id: serialization.serialize(c) + \"|\"\n                    });\n                    break;\n                case \"-\":\n                    result.push({\n                        type: \"rectangle\",\n                        c: sumCoordinate(baseCoordinates, {x: 0, y: padding}),\n                        color: \"white\",\n                        size: {x: squareSize, y: squareSize - padding * 2},\n                        id: serialization.serialize(c) + \"-\"\n                    });\n                    break;\n                case \"/\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"white\",\n                        points: [\n                            { x: baseCoordinates.x, y: baseCoordinates.y + squareSize - padding},\n                            { x: baseCoordinates.x + squareSize - padding, y: baseCoordinates.y},\n                            { x: baseCoordinates.x + squareSize, y: baseCoordinates.y + padding},\n                            { x: baseCoordinates.x + padding, y: baseCoordinates.y + squareSize}\n                        ]\n                    });\n                    break;\n                case \"\\\\\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"white\",\n                        points: [\n                            { x: baseCoordinates.x, y: baseCoordinates.y + padding},\n                            { x: baseCoordinates.x +  padding, y: baseCoordinates.y},\n                            { x: baseCoordinates.x + squareSize, y: baseCoordinates.y + squareSize - padding},\n                            { x: baseCoordinates.x + squareSize - padding, y: baseCoordinates.y + squareSize}\n                        ]\n                    });\n                    break;\n                case \">\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"pink\",\n                        points: [\n                            baseCoordinates,\n                            {x: baseCoordinates.x + squareSize, y: baseCoordinates.y + squareSize / 2},\n                            {x: baseCoordinates.x, y: baseCoordinates.y + squareSize}\n                        ]\n                    });\n                    break;\n                case \"<\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"pink\",\n                        points: [\n                            {x: baseCoordinates.x + squareSize, y: baseCoordinates.y},\n                            {x: baseCoordinates.x, y: baseCoordinates.y + squareSize / 2},\n                            {x: baseCoordinates.x + squareSize, y: baseCoordinates.y + squareSize}\n                        ]\n                    });\n                    break;\n                case \"^\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"pink\",\n                        points: [\n                            {x: baseCoordinates.x + squareSize / 2, y: baseCoordinates.y},\n                            {x: baseCoordinates.x, y: baseCoordinates.y + squareSize},\n                            {x: baseCoordinates.x + squareSize, y: baseCoordinates.y + squareSize},\n                        ]\n                    });\n                    break;\n                case \"v\":\n                    result.push({\n                        type: \"points\",\n                        id: serialization.serialize(c),\n                        color: \"pink\",\n                        points: [\n                            {x: baseCoordinates.x + squareSize / 2, y: baseCoordinates.y + squareSize},\n                            {x: baseCoordinates.x, y: baseCoordinates.y},\n                            {x: baseCoordinates.x + squareSize, y: baseCoordinates.y},\n                        ]\n                    });\n                    break;\n            }\n        });\n        return result;\n    }\n\n    private isVertical(cell: InputCell | undefined) {\n        if (!cell) {\n            return false;\n        } else {\n            return cell === \"|\" || cell === \"\\\\\" || cell === \"/\" || cell === \"+\" || isInputCart(cell);\n        }\n    }\n\n    private isHorizontal(cell: InputCell | undefined) {\n        if (!cell) {\n            return false;\n        } else {\n            return cell === \"-\" || cell === \"\\\\\" || cell === \"/\" || cell === \"+\" || isInputCart(cell);\n        }\n    }\n    private hideCart(coordinate: Coordinate) {\n        const up = this.matrix.get(directions.up.sum(coordinate));\n        const down = this.matrix.get(directions.down.sum(coordinate));\n        const left = this.matrix.get(directions.left.sum(coordinate));\n        const right = this.matrix.get(directions.right.sum(coordinate));\n        if (this.isVertical(up) && this.isVertical(down)) {\n            if (this.isHorizontal(left) && this.isHorizontal(right)) {\n                this.matrix.set(coordinate, \"+\");\n            } else {\n                this.matrix.set(coordinate, \"|\");\n            }\n        } else if (this.isHorizontal(left) && this.isHorizontal(right)) {\n            this.matrix.set(coordinate, \"-\");\n        } else {\n            throw new Error(\"Don't know what to put here :( \" + JSON.stringify(coordinate));\n        }\n    }\n    private incrementTicks() {\n        this.internalTicks++;\n    }\n\n    private getOrderedCarts(): Cart[] {\n        return this.carts.filter((e) => !e.isCrashed()).sort((a, b) => {\n            if (a.position.y === b.position.y) {\n                return a.position.x - b.position.x;\n            } else {\n                return a.position.y - b.position.y;\n            }\n        });\n    }\n    private moveCarts() {\n        const cartList = this.getOrderedCarts();\n        for (const cart of cartList) {\n            cart.handleInput((coordinate) => this.matrix.get(coordinate)!);\n            this.checkCollision(cart.position, cartList);\n        }\n    }\n    private checkCollision(position: Coordinate, candidates: Cart[]) {\n        const colliding = candidates.filter((c) => manhattanDistance(c.position, position) === 0);\n        if (colliding.length === 0) {\n            throw new Error(\"There should at least be one cart here\");\n        } else if (colliding.length > 1) {\n            colliding.forEach((cart) => cart.crash());\n            this.crashList.push({\n                carts: colliding,\n                position\n            });\n        }\n    }\n}\n\nexport const mineCartMadness = entryForFile(\n    async ({ lines, outputCallback, isCancelled, pause, screen }) => {\n        const field = parseLines(lines);\n        let printer: ScreenPrinter | null = null;\n        if (screen) {\n            printer = await screen.requireScreen({x: 1600, y: 1600});\n            await outputCallback(\"Running...\");\n        }\n        if (printer) {\n            printer.replace(field.toDrawable({x: 1600, y: 1600}, false));\n        } else {\n            await outputCallback(field.toString(true), true);\n        }\n        await pause();\n        while (!isCancelled || !isCancelled()) {\n            if (printer) {\n                printer.replace(field.toDrawable({x: 1600, y: 1600}));\n            } else {\n                await outputCallback([\n                    \" \",\n                    field.toString(false)\n                ], true);\n            }\n            field.tick();\n            if (field.hasCrashes()) {\n                break;\n            }\n            await pause();\n        }\n        if (printer) {\n            printer.replace(field.toDrawable({x: 1600, y: 1600}));\n            await outputCallback(\"Crash: \" + JSON.stringify(field.crashes[0].position));\n        } else {\n            await outputCallback([\n                \"Crash: \" + JSON.stringify(field.crashes[0].position),\n                field.toString(false)\n            ], true);\n        }\n    },\n    async ({ lines, outputCallback, isCancelled, pause }) => {\n        const field = parseLines(lines);\n        await outputCallback(field.toString(true), true);\n        await pause();\n        while (!isCancelled || !isCancelled()) {\n            await outputCallback([\n                \"Remaining carts: \" + field.remainingCarts.length,\n                field.toString(false)\n            ], true);\n            field.tick();\n            if (field.remainingCarts.length === 1) {\n                break;\n            }\n            await pause();\n        }\n        await outputCallback([\n            \"Last cart: \" + JSON.stringify(field.remainingCarts[0].position),\n            field.toString(false)\n        ], true);\n    },\n    {\n        key: \"mine-cart-madness\",\n        title: \"Mine Cart Madness\",\n        stars: 2,\n        customComponent: \"pause-and-run\"\n    }\n);\n","import { entryForFile } from \"../../entry\";\n\nfunction moveElf(position: number, recipes: number[]) {\n    return (position + 1 + recipes[position]) % recipes.length;\n}\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const interestingRecipes = 10;\n        const numberOfSteps = parseInt(lines[0], 10);\n        const recipes = [3, 7];\n        let currentFirst = 0;\n        let currentSecond = 1;\n        while (recipes.length < numberOfSteps + interestingRecipes) {\n            const result = recipes[currentFirst] + recipes[currentSecond];\n            if (result < 10) {\n                recipes.push(result);\n            } else {\n                const first = Math.floor(result / 10);\n                const second = result % 10;\n                recipes.push(first);\n                recipes.push(second);\n            }\n            currentFirst = moveElf(currentFirst, recipes);\n            currentSecond = moveElf(currentSecond, recipes);\n        }\n\n        const output = [];\n        for (let i = 0; i < interestingRecipes; i++) {\n            output.push(recipes[numberOfSteps + i]);\n        }\n\n        await outputCallback(output.join(\"\"));\n    },\n    async ({ lines, outputCallback, pause }) => {\n        const targetPattern = lines[0].split(\"\").map((e) => parseInt(e, 10));\n        let memory: number[] = [];\n        function checkIfSame(target: number[], nestedMemory: number[]) {\n            if (target.length !== nestedMemory.length) {\n                return false;\n            }\n            for (let i = 0; i < target.length; i++) {\n                if (target[i] !== nestedMemory[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function addMemory(nestedMemory: number[], target: number[], newElement: number): number[] {\n            if (nestedMemory.length < target.length) {\n                return nestedMemory.concat([newElement]);\n            } else {\n                return addMemory(nestedMemory.slice(1), target, newElement);\n            }\n        }\n\n        const recipes = [3, 7];\n        let currentFirst = 0;\n        let currentSecond = 1;\n\n        let iteration = 0;\n\n        while (true) {\n            if (++iteration % 10000 === 0) {\n                await outputCallback(\"Iteration \" + iteration + \" done\", true);\n            }\n            const result = recipes[currentFirst] + recipes[currentSecond];\n            if (result < 10) {\n                recipes.push(result);\n                memory = addMemory(memory, targetPattern, result);\n                if (checkIfSame(targetPattern, memory)) {\n                    await outputCallback(recipes.length - targetPattern.length);\n                    return;\n                }\n            } else {\n                const first = Math.floor(result / 10);\n                const second = result % 10;\n                recipes.push(first);\n                memory = addMemory(memory, targetPattern, first);\n                if (checkIfSame(targetPattern, memory)) {\n                    await outputCallback(recipes.length - targetPattern.length);\n                    return;\n                }\n                recipes.push(second);\n                memory = addMemory(memory, targetPattern, second);\n                if (checkIfSame(targetPattern, memory)) {\n                    await outputCallback(recipes.length - targetPattern.length);\n                    return;\n                }\n            }\n            currentFirst = moveElf(currentFirst, recipes);\n            currentSecond = moveElf(currentSecond, recipes);\n        }\n    },\n    { key: \"chocolate-charts\", title: \"Chocolate Charts\", stars: 2, }\n);\n","import { entryForFile, OutputCallback } from \"../../entry\";\nimport { Coordinate, sumCoordinate, Bounds, isInBounds, ascendingCompare } from \"../../../support/geometry\";\nimport { ascending } from \"../../../support/best\";\nimport { Queue } from \"../../../support/data-structure\";\nimport { __values } from \"tslib\";\n\nclass EditableField {\n    public cells: EditableFieldType[][];\n    constructor(baseField: Field, units: Units) {\n        this.cells = baseField.cells.map((line, y) => line.split(\"\").map((cell, x) => {\n            return cell as FieldType;\n        }));\n\n        units.units.forEach((unit) => {\n            if (unit.isAlive) {\n                this.cells[unit.coordinates.y][unit.coordinates.x] = unit;\n            }\n        });\n    }\n\n    public get(c: Coordinate): EditableFieldType {\n        return this.cells[c.y][c.x];\n    }\n\n    public set(c: Coordinate, v: EditableFieldType) {\n        this.cells[c.y][c.x] = v;\n    }\n\n    public toString(): string {\n        return this.cells.map((line) => line.map((cell) => {\n            if (isFieldType(cell)) {\n                return cell;\n            } else if (isUnit(cell)) {\n                return cell.unitType;\n            } else {\n                return \"\" + cell;\n            }\n        }).join(\"\")).join(\"\\n\");\n    }\n}\n\ntype EditableFieldType = Unit | FieldType | number;\n\nfunction isUnit(e: EditableFieldType): e is Unit {\n    return (e as Unit).coordinates !== undefined;\n}\n\nconst adjacentOffsets: Coordinate[] = [\n    { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }\n];\n\nfunction adjacentCoordinates(c: Coordinate, bounds: Bounds): Coordinate[] {\n    return adjacentOffsets.map((offset) => sumCoordinate(c, offset)).filter((result) => isInBounds(result, bounds));\n}\n\nfunction isFieldType(e: EditableFieldType): e is FieldType {\n    return !isUnit(e) && (e as FieldType).substr !== undefined;\n}\n\nfunction isNumber(e: EditableFieldType): e is number {\n    return !isUnit(e) && !isFieldType(e);\n}\n\nclass Field {\n    public cells: string[];\n    public size: { width: number; height: number; };\n\n    constructor(inputLines: string[]) {\n        this.size = {\n            width: inputLines[0].length,\n            height: inputLines.length\n        };\n        this.cells = inputLines.map((line) => line.replace(/[GE]/g, \".\"));\n    }\n\n    public toString() {\n        return this.cells.join(\"\\n\");\n    }\n}\n\ntype FieldType = \"#\" | \".\";\ntype UnitType = \"G\" | \"E\";\n\ntype WorldType = FieldType | UnitType;\n\nfunction defaultPower(t: UnitType): number {\n    return 3;\n}\n\nclass Units {\n\n    public static fromLines(lines: string[], powerGenerator?: typeof defaultPower): Units {\n        return new Units(\n            lines.flatMap(\n                (line, y) => line.split(\"\").map(\n                    (cell, x) => cell === \"G\" || cell === \"E\" ? { type: cell as UnitType, coordinate: { x, y } } : null\n                ).filter((u) => u !== null)\n            ).map((u) => new Unit(\n                u!.coordinate,\n                u!.type,\n                powerGenerator ? powerGenerator(u!.type) : defaultPower(u!.type)\n            ))\n        );\n    }\n    constructor(public units: Unit[]) {\n    }\n\n\n    public sort(): Units {\n        return new Units(this.units.filter((u) => u.isAlive).sort((a, b) => a.compare(b)));\n    }\n}\n\nclass Unit {\n    // public attackPower = 3;\n    public hitpoints = 200;\n    constructor(public coordinates: Coordinate, public unitType: UnitType, public attackPower: number = 3) {\n    }\n\n    public get isAlive(): boolean { return this.hitpoints > 0; }\n\n    public suffersAttack(value: number) {\n        this.hitpoints -= value;\n    }\n\n    public compare(other: Unit) {\n        if (other.coordinates.y === this.coordinates.y) {\n            return ascending(this.coordinates.x, other.coordinates.x);\n        } else {\n            return ascending(this.coordinates.y, other.coordinates.y);\n        }\n    }\n}\n\nasync function calculateScore(\n    field: Field,\n    units: Units,\n    outputCallback: OutputCallback,\n    pause: () => Promise<void>\n): Promise<[number, number, number]> {\n    const bounds = {\n        topLeft: { x: 0, y: 0 },\n        size: { x: field.size.width, y: field.size.height }\n    };\n    function attackInRange(unit: Unit, editableField: EditableField): boolean {\n        const rangePositions = adjacentCoordinates(unit.coordinates, bounds);\n        const enemiesInRange = rangePositions\n            .map((c) => editableField.get(c))\n            .filter((c) => isUnit(c) && c.unitType !== unit.unitType)\n            .map((c) => c as Unit);\n        if (enemiesInRange.length > 0) {\n            const enemyToAttack = enemiesInRange.sort((a, b) => {\n                if (a.hitpoints === b.hitpoints) {\n                    return ascendingCompare(a.coordinates, b.coordinates);\n                } else {\n                    return ascending(a.hitpoints, b.hitpoints);\n                }\n            })[0];\n            enemyToAttack.suffersAttack(unit.attackPower);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    let i = -1;\n    while (true) {\n        i++;\n        for (const unit of units.units) {\n            await pause();\n            if (!unit.isAlive) {\n                continue;\n            }\n            const editableField = new EditableField(field, units);\n            editableField.set(unit.coordinates, 0);\n            if (attackInRange(unit, editableField)) {\n                continue;\n            } else {\n                const positionsToVisit = new Queue<Coordinate>();\n                positionsToVisit.add(unit.coordinates);\n                let foundAt: number | null = null;\n                const interestingPositions: Coordinate[] = [];\n                while (!positionsToVisit.isEmpty) {\n                    const currentPosition = positionsToVisit.get()!;\n                    const currentValue = editableField.get(currentPosition);\n                    if (!isNumber(currentValue)) {\n                        throw Error(\"At current position there wasn't a value\");\n                    }\n                    if (foundAt && currentValue > foundAt) {\n                        break;\n                    }\n                    const inRangeCoordinates = adjacentCoordinates(currentPosition, bounds);\n                    inRangeCoordinates.forEach((c) => {\n                        const cell = editableField.get(c);\n                        if (cell === \".\") {\n                            editableField.set(c, currentValue + 1);\n                            positionsToVisit.add(c);\n                        } else if (isUnit(cell) && cell.unitType !== unit.unitType) {\n                            foundAt = currentValue;\n                            interestingPositions.push(currentPosition);\n                        } else {\n                            return;\n                        }\n                    });\n                }\n                if (interestingPositions.length <= 0) {\n                    continue;\n                }\n                const targetPosition = interestingPositions.sort((a, b) => ascendingCompare(a, b))[0];\n                const interestingFirstSteps: Coordinate[] = [];\n                if ((editableField.get(targetPosition) as number) === 1) {\n                    interestingFirstSteps.push(targetPosition);\n                } else {\n                    const stepQueue = new Queue<Coordinate>();\n                    stepQueue.add(targetPosition);\n                    while (!stepQueue.isEmpty) {\n                        const nextStep = stepQueue.get()!;\n                        const nextStepValue = editableField.get(nextStep);\n                        if (!isNumber(nextStepValue)) {\n                            throw Error(\"Expected number!\");\n                        }\n                        if (nextStepValue === 1) {\n                            interestingFirstSteps.push(nextStep);\n                        } else if (nextStepValue > 0) {\n                            const inRange = adjacentCoordinates(nextStep, bounds);\n                            inRange.forEach((c) => {\n                                const v = editableField.get(c);\n                                if (isNumber(v) && v === nextStepValue - 1) {\n                                    stepQueue.add(c);\n                                }\n                            });\n                        }\n                    }\n                }\n                const moveTo = interestingFirstSteps.sort((a, b) => ascendingCompare(a, b))[0];\n                unit.coordinates = moveTo;\n                attackInRange(unit, new EditableField(field, units));\n            }\n        }\n        units = units.sort();\n        const newEditable = new EditableField(field, units);\n        const outputLines = newEditable.toString().split(\"\\n\");\n        units.units.forEach(\n            (u) => outputLines[u.coordinates.y] = outputLines[u.coordinates.y].concat(\n                \" \",\n                `${u.unitType}-${u.hitpoints}`\n            )\n        );\n        await outputCallback(outputLines.join(\"\\n\"));\n        if (\n            units.units.filter((u) => u.unitType === \"E\").length === 0\n            || units.units.filter((u) => u.unitType === \"G\").length === 0) {\n            const gameScore = i * units.units.map((u) => u.hitpoints).reduce((acc, value) => acc + value, 0);\n            return [i, gameScore, units.units.filter((u) => u.unitType === \"E\").length];\n            // await outputCallback(`Combat done at round ${i} with value ${gameScore}!`);\n            // break;\n        }\n    }\n}\n\nfunction wrapOutputToClean(outputCallback: OutputCallback, cleanEveryNOutput: number): OutputCallback {\n    let currentCount = 0;\n    return async (line: any, shouldClear?: boolean): Promise<void> => {\n        currentCount++;\n        let forceShouldClear = false;\n        if (currentCount >= cleanEveryNOutput || shouldClear) {\n            forceShouldClear = true;\n        }\n        await outputCallback(line, forceShouldClear);\n    };\n}\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback, pause }) => {\n        const field = new Field(lines);\n        const units = Units.fromLines(lines).sort();\n\n        const [round, gameScore] = await calculateScore(\n            field,\n            units,\n            wrapOutputToClean(outputCallback, 1),\n            pause\n        );\n\n        await outputCallback(`Combat done at round ${round} with value ${gameScore}!`);\n\n    },\n    async ({ lines, outputCallback, pause }) => {\n        const field = new Field(lines);\n\n        let attackPower = 11;\n        while (true) {\n            await outputCallback(\"Trying with \" + attackPower);\n            const units = Units.fromLines(lines, ((t) => t === \"E\" ? attackPower : 3)).sort();\n            const startingElves = units.units.filter((u) => u.unitType === \"E\").length;\n            const [round, gameScore, survivors] = await calculateScore(\n                field,\n                units,\n                wrapOutputToClean(outputCallback, 1),\n                pause\n            );\n            if (startingElves === survivors) {\n                await outputCallback(\n                    `First win at attack power ${attackPower} in ${round} rounds with score ${gameScore}`\n                );\n                break;\n            } else {\n                attackPower++;\n            }\n        }\n    },\n    { key: \"beverage-bandits\", title: \"Beverage Bandits\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\nimport { groupBy } from \"../../../support/sequences\";\n\nexport type OpCode =\n    \"addr\" | \"addi\" |\n    \"mulr\" | \"muli\" |\n    \"banr\" | \"bani\" |\n    \"borr\" | \"bori\" |\n    \"setr\" | \"seti\" |\n    \"gtir\" | \"gtri\" | \"gtrr\" |\n    \"eqir\" | \"eqri\" | \"eqrr\";\n\nconst codeList: OpCode[] = [\n    \"addr\", \"addi\",\n    \"mulr\", \"muli\",\n    \"banr\", \"bani\",\n    \"borr\", \"bori\",\n    \"setr\", \"seti\",\n    \"gtir\", \"gtri\", \"gtrr\",\n    \"eqir\", \"eqri\", \"eqrr\"\n];\n\nexport class Instruction {\n\n    public static fromLines(lines: string[], mapping: (s: string) => OpCode): Instruction[] {\n        lines = lines.map((l) => l.replace(/\\/\\/.*/g, \"\"));\n        const instructions = lines.map((line, index) => {\n            let g = line.split(\" \").map((l) => l.trim()).filter((l) => l.length > 0);\n            if (g.length < 4) {\n                g = g.fill(\"0\", g.length, 4);\n            }\n            const p = (s: string) => parseInt(s, 10);\n            return new Instruction(mapping(g[0]), p(g[1]), p(g[2]), p(g[3]), index);\n        });\n        return instructions;\n    }\n    constructor(\n        public code: OpCode | number,\n        public a: number,\n        public b: number,\n        public output: number,\n        public lineNumber?: number\n    ) { }\n\n    public setCode(code: OpCode): Instruction {\n        return new Instruction(code, this.a, this.b, this.output);\n    }\n\n    public allCodes(): Instruction[] {\n        return codeList.map((code) => this.setCode(code));\n    }\n\n    public toString() {\n        return `${this.code} ${this.a} ${this.b} ${this.output}`;\n    }\n}\n\nexport class MutableMachine {\n    constructor(public registers = [0, 0, 0, 0], public instructionPointerRegister: number) {\n    }\n\n    public sameAs(other: Machine): boolean {\n        if (this.registers.length !== other.registers.length) {\n            return false;\n        }\n        return this.registers\n            .map((e, i) => this.registers[i] === other.registers[i])\n            .reduce((acc, v) => acc && v, true);\n    }\n\n    public get nextInstructionAddress(): number {\n        return this.registers[this.instructionPointerRegister];\n    }\n\n    public isExecutable(instructionRange: number): boolean {\n        const newI = this.nextInstructionAddress;\n        return newI >= 0 && newI < instructionRange;\n    }\n\n\n    public execute(instruction: Instruction) {\n        const calculatedValue = this.calculateValue(instruction);\n        this.set(\n            instruction.output,\n            calculatedValue\n        );\n    }\n\n    private set(registerAddress: number, value: number) {\n        const newRegisters = this.registers;\n        newRegisters[registerAddress] = value;\n        newRegisters[this.instructionPointerRegister]++;\n    }\n\n    private calculateValue(instruction: Instruction): number {\n        const i = instruction;\n        switch (i.code) {\n            case \"addr\":\n                return this.registers[i.a] + this.registers[i.b];\n            case \"addi\":\n                return this.registers[i.a] + i.b;\n            case \"mulr\":\n                return this.registers[i.a] * this.registers[i.b];\n            case \"muli\":\n                return this.registers[i.a] * i.b;\n            case \"banr\":\n                return this.registers[i.a] & this.registers[i.b];\n            case \"bani\":\n                return this.registers[i.a] & i.b;\n            case \"borr\":\n                return this.registers[i.a] | this.registers[i.b];\n            case \"bori\":\n                return this.registers[i.a] | i.b;\n\n            case \"setr\":\n                return this.registers[i.a];\n            case \"seti\":\n                return i.a;\n\n            case \"gtir\":\n                return i.a > this.registers[i.b] ? 1 : 0;\n            case \"gtri\":\n                return this.registers[i.a] > i.b ? 1 : 0;\n            case \"gtrr\":\n                return this.registers[i.a] > this.registers[i.b] ? 1 : 0;\n\n            case \"eqir\":\n                return i.a === this.registers[i.b] ? 1 : 0;\n            case \"eqri\":\n                return this.registers[i.a] === i.b ? 1 : 0;\n            case \"eqrr\":\n                return this.registers[i.a] === this.registers[i.b] ? 1 : 0;\n            default:\n                throw RangeError(\"Cannot execute instruction if no op code is given\");\n\n        }\n\n    }\n}\n\nexport class Machine {\n    constructor(public registers = [0, 0, 0, 0], public instructionPointerRegister?: number) {\n    }\n\n    public sameAs(other: Machine): boolean {\n        if (this.registers.length !== other.registers.length) {\n            return false;\n        }\n        return this.registers\n            .map((e, i) => this.registers[i] === other.registers[i])\n            .reduce((acc, v) => acc && v, true);\n    }\n\n    public get nextInstructionAddress(): number {\n        if (this.instructionPointerRegister === undefined) {\n            return 0;\n        } else {\n            return this.registers[this.instructionPointerRegister];\n        }\n    }\n\n    public isExecutable(instructionRange: number): boolean {\n        if (this.instructionPointerRegister === undefined) {\n            return true;\n        } else {\n            const newI = this.nextInstructionAddress;\n            return newI >= 0 && newI < instructionRange;\n        }\n    }\n\n\n    public execute(instruction: Instruction): Machine {\n        if (instruction.output < 0 || instruction.output > this.registers.length) {\n            throw RangeError(\"Output outside of valid range\");\n        }\n        const calculatedValue = this.calculateValue(instruction);\n        return this.set(\n            instruction.output,\n            calculatedValue\n        );\n    }\n\n    private set(registerAddress: number, value: number): Machine {\n        const newRegisters = Array.from(this.registers);\n        newRegisters[registerAddress] = value;\n        if (this.instructionPointerRegister !== undefined) {\n            newRegisters[this.instructionPointerRegister]++;\n        }\n        return new Machine(newRegisters, this.instructionPointerRegister);\n    }\n\n    private calculateValue(instruction: Instruction): number {\n        const r = (...ns: number[]) => {\n            for (const n of ns) {\n                if (n < 0 || n > this.registers.length) {\n                    throw RangeError(\"Register address out of range\");\n                }\n            }\n        };\n        const i = instruction;\n        function rab() {\n            r(i.a, i.b);\n        }\n        function ra() {\n            r(i.a);\n        }\n        function rb() {\n            r(i.b);\n        }\n\n        const existing = (n: number): number => n;\n\n        switch (i.code) {\n            case \"addr\":\n                rab();\n                return existing(this.registers[i.a] + this.registers[i.b]);\n            case \"addi\":\n                ra();\n                return existing(this.registers[i.a] + i.b);\n            case \"mulr\":\n                rab();\n                return existing(this.registers[i.a] * this.registers[i.b]);\n            case \"muli\":\n                ra();\n                return existing(this.registers[i.a] * i.b);\n            case \"banr\":\n                rab();\n                return existing(this.registers[i.a] & this.registers[i.b]);\n            case \"bani\":\n                ra();\n                return existing(this.registers[i.a] & i.b);\n            case \"borr\":\n                rab();\n                return existing(this.registers[i.a] | this.registers[i.b]);\n            case \"bori\":\n                ra();\n                return existing(this.registers[i.a] | i.b);\n\n            case \"setr\":\n                ra();\n                return existing(this.registers[i.a]);\n            case \"seti\":\n                return existing(i.a);\n\n            case \"gtir\":\n                return existing(i.a > this.registers[i.b] ? 1 : 0);\n            case \"gtri\":\n                return existing(this.registers[i.a] > i.b ? 1 : 0);\n            case \"gtrr\":\n                return existing(this.registers[i.a] > this.registers[i.b] ? 1 : 0);\n\n            case \"eqir\":\n                return existing(i.a === this.registers[i.b] ? 1 : 0);\n            case \"eqri\":\n                return existing(this.registers[i.a] === i.b ? 1 : 0);\n            case \"eqrr\":\n                return existing(this.registers[i.a] === this.registers[i.b] ? 1 : 0);\n            default:\n                throw RangeError(\"Cannot execute instruction if no op code is given\");\n\n        }\n\n    }\n}\n\ninterface Calibration {\n    before: Machine;\n    after: Machine;\n    instruction: Instruction;\n}\n\nconst isTokenValid = (token: Calibration, i: Instruction): boolean => {\n    try {\n        if (token.before.execute(i).sameAs(token.after)) {\n            return true;\n        } else {\n            return false;\n        }\n    } catch (RangeError) {\n        return true;\n    }\n};\n\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const testMachineFactory = () => new Machine([0, 1, 2, 3]);\n        const testCreator = (opCode: OpCode, a: number, b: number, e: number) =>\n            ({ i: new Instruction(opCode, a, b, 3), e });\n\n        const tests = [\n            testCreator(\"addr\", 0, 1, 1), // 0\n            testCreator(\"addr\", 0, 1, 1),\n            testCreator(\"addr\", 1, 1, 2),\n            testCreator(\"addi\", 1, 3, 4),\n            testCreator(\"addi\", 2, 4, 6),\n            testCreator(\"mulr\", 2, 0, 0), // 5\n            testCreator(\"mulr\", 2, 1, 2),\n            testCreator(\"muli\", 0, 6, 0),\n            testCreator(\"muli\", 2, 5, 10),\n            testCreator(\"banr\", 1, 2, 0),\n            testCreator(\"bani\", 1, 8, 0), // 10\n            testCreator(\"banr\", 1, 3, 1),\n            testCreator(\"bani\", 1, 9, 1),\n            testCreator(\"borr\", 1, 2, 3),\n            testCreator(\"bori\", 1, 8, 9),\n            testCreator(\"setr\", 1, 8, 1), // 15\n            testCreator(\"setr\", 2, 20, 2),\n            testCreator(\"seti\", 8, 0, 8),\n            testCreator(\"gtir\", 4, 2, 1),\n            testCreator(\"gtir\", 2, 2, 0),\n            testCreator(\"gtri\", 2, 1, 1),\n            testCreator(\"gtri\", 2, 3, 0),\n            testCreator(\"gtri\", 3, 8, 0),\n            testCreator(\"gtrr\", 3, 3, 0),\n            testCreator(\"gtrr\", 3, 2, 1),\n            testCreator(\"eqir\", 4, 2, 0),\n            testCreator(\"eqir\", 2, 2, 1),\n            testCreator(\"eqri\", 2, 1, 0),\n            testCreator(\"eqri\", 2, 3, 0),\n            testCreator(\"eqri\", 3, 8, 0),\n            testCreator(\"eqrr\", 3, 3, 1),\n            testCreator(\"eqrr\", 3, 2, 0)\n        ];\n\n        let i = 0;\n        for (const test of tests) {\n            const m = testMachineFactory();\n            try {\n                const r = m.execute(test.i);\n                if (r.registers[3] !== test.e) {\n                    await outputCallback(`Test ${i} failed`);\n                }\n            } catch (RangeError) {\n                await outputCallback(`Test ${i} was out of range`);\n            }\n            i++;\n        }\n        const calibrationTokens: Calibration[] = parseCalibrationTokens(lines);\n        const result = calibrationTokens.map<number>((token) => {\n            const validCodes = token.instruction.allCodes().map<number>((instruction) => {\n                return isTokenValid(token, instruction) ? 1 : 0;\n            }).reduce((acc, v) => acc + v, 0);\n            if (validCodes >= 3) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }).reduce((acc, v) => acc + v, 0);\n        await outputCallback(\"Ambigous instructions: \" + result);\n    },\n    async ({ lines, outputCallback }) => {\n        const calibrationTokens = parseCalibrationTokens(lines);\n        const mapping: { [key: number]: OpCode } = {};\n        let done: boolean = false;\n        while (!done) {\n            done = true;\n            calibrationTokens.forEach((token) => {\n                if (typeof token.instruction.code === \"number\") {\n                    if (mapping[token.instruction.code]) {\n                        token.instruction.code = mapping[token.instruction.code];\n                    } else {\n                        const toBeMapped = codeList.filter((e) => Object.values(mapping).indexOf(e) === -1);\n                        const valid = toBeMapped.filter((code) =>\n                            isTokenValid(token, token.instruction.setCode(code)));\n                        if (valid.length === 0) {\n                            throw new Error(\"No valid instruction\");\n                        } else if (valid.length === 1) {\n                            done = false;\n                            mapping[token.instruction.code] = valid[0];\n                        }\n                    }\n                }\n            });\n        }\n        await outputCallback(\"Calibration done\");\n        const puzzleLines = parseLines(lines).puzzleLines.filter((l) => l.trim().length > 0);\n        const instructions = Instruction.fromLines(puzzleLines, ((s) => mapping[parseInt(s, 10)]));\n\n        let m = new Machine();\n        let ln = 0;\n        for (const ins of instructions) {\n            try {\n                m = m.execute(ins);\n            } catch (RangeError) {\n                await outputCallback(\"Error on line \" + ln);\n                break;\n            }\n            ln++;\n        }\n\n        await outputCallback(\"First register: \" + m.registers[0]);\n    },\n    { key: \"chronal-classification\", title: \"Chronal Classification\", stars: 2, }\n);\n\nfunction parseCalibrationTokens(lines: string[]) {\n    const { calibrationLines, puzzleLines } = parseLines(lines);\n    const groupped = groupBy(calibrationLines, 3);\n    function getList(l: string): number[] {\n        return l.slice(l.indexOf(\"[\") + 1, l.indexOf(\"]\")).replace(/ /g, \"\").split(\",\").map((e) => parseInt(e, 10));\n    }\n    const calibrationTokens: Calibration[] = groupped.map((group) => {\n        const encodedInstruction = group[1].split(\" \").filter((e) => e.length >= 1).map((e) => parseInt(e, 10));\n        return {\n            before: new Machine(getList(group[0])),\n            after: new Machine(getList(group[2])),\n            instruction: new Instruction(\n                encodedInstruction[0],\n                encodedInstruction[1],\n                encodedInstruction[2],\n                encodedInstruction[3]\n            )\n        };\n    });\n    return calibrationTokens;\n}\n\nfunction parseLines(lines: string[]) {\n    let calibrationLines: string[];\n    let puzzleLines: string[];\n    (() => {\n        const complete = lines.map((l) => l.trim()).join(\"\\n\");\n        const splitLine = complete.indexOf(\"\\n\\n\\n\");\n        calibrationLines = complete.slice(0, splitLine + 1).split(\"\\n\").filter((l) => l.trim().length >= 1);\n        puzzleLines = complete.slice(splitLine + 4).split(\"\\n\");\n    })();\n    return { calibrationLines, puzzleLines };\n}\n","import { entryForFile } from \"../../entry\";\nimport { Coordinate, CCoordinate, getBoundaries, Bounds, isInBounds } from \"../../../support/geometry\";\n\ntype Cell = \".\" | \"|\" | \"~\" | \"#\";\n\nfunction scanLineToClay(line: string): CCoordinate[] {\n    const [xs, ys] = line.split(\", \").sort().map((e) => e.replace(/^.=/, \"\")).map(rangeToValues);\n\n    return xs.flatMap((x) => ys.map((y) => new CCoordinate(x, y)));\n}\n\nclass World {\n\n    public get reachedCells(): number {\n        return this.state.flatMap((row) => row.filter((e) => e === \"|\" || e === \"~\")).length;\n    }\n    public get dryCells(): number {\n        return this.state.flatMap((row) => row.filter((e) => e === \"~\")).length;\n    }\n    public bounds: Bounds;\n    private state: Cell[][];\n\n    private readonly left = new CCoordinate(-1, 0);\n    private readonly right = new CCoordinate(1, 0);\n    private readonly down = new CCoordinate(0, 1);\n\n    private interestingCoordinates: CCoordinate[] = [];\n    public constructor(clayCells: CCoordinate[]) {\n        this.bounds = getBoundaries(clayCells);\n        this.bounds.topLeft.x -= 1;\n        this.bounds.size.x += 2;\n        this.state = new Array(this.bounds.size.y).fill(0).map((e) => new Array(this.bounds.size.x).fill(\".\"));\n        clayCells.forEach((c) => this.setCell(c, \"#\"));\n    }\n\n    public getCell(c: CCoordinate) {\n        c = c.diff(this.bounds.topLeft);\n        return this.state[c.y][c.x];\n    }\n\n    public setCell(c: CCoordinate, cell: Cell) {\n        c = c.diff(this.bounds.topLeft);\n        this.state[c.y][c.x] = cell;\n    }\n\n    public addWater(): boolean {\n        const waterCoordinate = new CCoordinate(500, this.bounds.topLeft.y);\n        this.setCell(waterCoordinate, \"|\");\n        this.interestingCoordinates.push(waterCoordinate);\n        return this.takeTurn();\n    }\n\n\n    public toString(): string {\n        return this.state.map((e) => e.join(\"\")).join(\"\\n\");\n    }\n\n    private takeTurn(): boolean {\n        const oldWaterState = this.toString();\n        for (const coordinate of this.interestingCoordinates) {\n\n            const cell = this.getCell(coordinate);\n            if (cell === \"|\") {\n                const downer = coordinate.sum({ x: 0, y: 1 });\n                if (downer.isInBounds(this.bounds)) {\n                    const downerCell = this.getCell(downer);\n                    if (downerCell === \".\") {\n                        this.setCell(downer, \"|\");\n                        this.interestingCoordinates.push(downer);\n                    } else if (downerCell === \"~\" || downerCell === \"#\") {\n                        this.fillTowards(coordinate, this.left, \"|\");\n                        this.fillTowards(coordinate, this.right, \"|\");\n                        if (this.isStable(coordinate)) {\n                            this.fillTowards(coordinate, this.left, \"~\");\n                            this.fillTowards(coordinate, this.right, \"~\");\n                            this.setCell(coordinate, \"~\");\n                        }\n                    }\n                }\n            }\n        }\n\n        //     }\n        // }\n        const newState = this.toString();\n        return oldWaterState === newState;\n    }\n\n    private fillTowards(c: CCoordinate, direction: CCoordinate, fillWith: Cell): void {\n        const current = this.getCell(c);\n        if (current !== \"|\") {\n            return;\n        }\n        const downer = this.down.sum(c);\n        if (downer.isInBounds(this.bounds)) {\n            const downerCell = this.getCell(downer);\n            if (downerCell === \"|\" || downerCell === \".\") {\n                return;\n            }\n        } else {\n            return;\n        }\n        const next = direction.sum(c);\n        if (!next.isInBounds(this.bounds)) {\n            return;\n        } else {\n            const nextCell = this.getCell(next);\n            if (nextCell === \".\") {\n                this.setCell(next, fillWith);\n                this.interestingCoordinates.push(next);\n            }\n            return this.fillTowards(next, direction, fillWith);\n        }\n    }\n\n    private isClosedOn(c: Coordinate, direction: CCoordinate): boolean {\n        const downer = this.down.sum(c);\n        if (downer.isInBounds(this.bounds)) {\n            const downerCell = this.getCell(downer);\n            if (downerCell === \".\" || downerCell === \"|\") {\n                return false;\n            }\n        } else {\n            return false;\n        }\n        const next = direction.sum(c);\n        if (!next.isInBounds(this.bounds)) {\n            return false;\n        } else {\n            const nextCell = this.getCell(next);\n            if (nextCell === \"#\") {\n                return true;\n            } else {\n                return this.isClosedOn(next, direction);\n            }\n        }\n    }\n\n    private isStable(c: Coordinate): boolean {\n        return this.isClosedOn(c, this.left) && this.isClosedOn(c, this.right);\n    }\n\n\n\n    private getStateSummary(): Array<[Cell, number]> {\n        return this.state\n            .flatMap((row) => row\n                .map((c, index) => c === \"|\" || c === \"~\" ? [c, index] as [Cell, number] : null)\n                .filter((e) => e !== null)) as Array<[Cell, number]>;\n    }\n}\n\nfunction rangeToValues(exp: string): number[] {\n    if (exp.indexOf(\"..\") < 0) {\n        return [parseInt(exp, 10)];\n    } else {\n        const [starts, ends] = exp.split(\"..\").map((e) => parseInt(e, 10));\n        return Array(ends - starts + 1).fill(0).map((e, index) => starts + index);\n    }\n}\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback, pause }) => {\n        const clayCoordinates = lines.flatMap(scanLineToClay);\n        const world = new World(clayCoordinates);\n        let done = false;\n        let iteration = 0;\n        while (!done) {\n            done = world.addWater();\n            if (++iteration % 10 === 0) {\n                await outputCallback(world.toString(), true);\n            } else {\n                await pause();\n            }\n        }\n        await outputCallback(world.reachedCells, true);\n        await outputCallback(world.toString());\n    },\n    async ({ lines, outputCallback, pause }) => {\n        const clayCoordinates = lines.flatMap(scanLineToClay);\n        const world = new World(clayCoordinates);\n        let done = false;\n        let iteration = 0;\n        while (!done) {\n            done = world.addWater();\n            if (++iteration % 100 === 0) {\n                await outputCallback(world.toString(), true);\n            } else {\n                await pause();\n            }\n        }\n        await outputCallback(world.dryCells, true);\n        await outputCallback(world.toString());\n    },\n    { key: \"reservoir-research\", title: \"Reservoir Research\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { CCoordinate, Coordinate, directions, directionList } from \"../../../support/geometry\";\n\nimport wu from \"wu\";\n\ntype Cell = \".\" | \"|\" | \"#\";\n\nfunction isCell(s: string): s is Cell {\n    return s === \".\" || s === \"|\" || s === \"#\";\n}\n\ninterface WorldConstructor {\n    cells?: Cell[][];\n    data?: FixedSizeMatrix<Cell>;\n    minute: number;\n}\n\nconst worldStates = new Set<string>();\nconst worldStateList: string[] = [];\nconst worldStateMap = new Map<string, World>();\nlet worldStateLoop: string[] = [];\n\nclass World {\n\n    public get resourceValue(): number {\n        let lumberTally = 0;\n        let treeTally = 0;\n        const interesting = this.data.data.forEach((e) => {\n            if (e === \"|\") {\n                treeTally++;\n            } else if (e === \"#\") {\n                lumberTally++;\n            }\n        });\n        return lumberTally * treeTally;\n    }\n\n    public static fromLines(lines: string[]): World {\n        return new World({\n            cells: lines.map((line) => line.split(\"\").map((e) => isCell(e) ? e : \".\")),\n            minute: 0\n        });\n    }\n    public minute: number;\n    private size: CCoordinate;\n    private data: FixedSizeMatrix<Cell>;\n    private constructor({ cells, data, minute }: WorldConstructor) {\n        this.minute = minute;\n        if (cells) {\n            this.size = new CCoordinate(cells[0].length, cells.length);\n            this.data = new FixedSizeMatrix<Cell>(this.size);\n            for (let x = 0; x < this.size.x; x++) {\n                for (let y = 0; y < this.size.y; y++) {\n                    this.data.set({ x, y }, cells[y][x]);\n                }\n            }\n        } else if (data) {\n            this.size = new CCoordinate(data.size.x, data.size.y);\n            this.data = data;\n        } else {\n            throw Error();\n        }\n    }\n\n    public takeTurns(howMany: number): World {\n        let world: World = this;\n        if (worldStateLoop.length > 0) {\n            // alert(\"Loop length: \" + worldStateLoop.length);\n            const loopBaseIndex = worldStateLoop.indexOf(this.toString());\n            const targetIndex = (loopBaseIndex + howMany) % worldStateLoop.length;\n            // worldStateLoop.map((l) => worldStateMap.get(l)!.resourceValue).forEach((e) => console.log(e));\n            return worldStateMap.get(worldStateLoop[targetIndex])!;\n        }\n        while (howMany-- > 0) {\n            const newWorld = new World({ data: world.data.copy(), minute: world.minute + 1 });\n            for (let x = 0; x < world.size.x; x++) {\n                for (let y = 0; y < world.size.y; y++) {\n                    const adjacents = Array.from(world.adjacent({ x, y }));\n                    const oldCell = world.data.get({ x, y })!;\n                    newWorld.data.set({ x, y }, this.calculateNew(oldCell, adjacents));\n                }\n            }\n            world = newWorld;\n            const state = world.toString();\n            if (worldStates.has(state)) {\n                worldStateLoop = worldStateList.slice(worldStateList.indexOf(state));\n                return world.takeTurns(howMany);\n            } else {\n                worldStates.add(state);\n                worldStateList.push(state);\n                worldStateMap.set(state, world);\n            }\n\n        }\n        return world;\n    }\n\n    public toString() {\n        return wu(this.data.overRows()).map((row) => row.join(\"\")).toArray().join(\"\\n\");\n    }\n\n    private calculateNew(old: Cell, adjacents: Cell[]): Cell {\n        switch (old) {\n            case \".\":\n                if (adjacents.filter((e) => e === \"|\").length >= 3) {\n                    return \"|\";\n                }\n                return \".\";\n            case \"|\":\n                if (adjacents.filter((e) => e === \"#\").length >= 3) {\n                    return \"#\";\n                }\n                return \"|\";\n            case \"#\":\n                if (adjacents.filter((e) => e === \"#\").length >= 1 && adjacents.filter((e) => e === \"|\").length >= 1) {\n                    return \"#\";\n                }\n                return \".\";\n        }\n    }\n\n    private *adjacent(c: Coordinate): Iterable<Cell> {\n        for (const direction of directionList) {\n            if (direction.sum(c).isInBounds(this.size)) {\n                yield this.data.get(direction.sum(c))!;\n            }\n        }\n    }\n}\n\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback, isCancelled, pause }) => {\n        let world = World.fromLines(lines);\n        await outputCallback([\"Initial state\", world.toString()]);\n        let iteration = 1;\n        while (!isCancelled!()) {\n            world = world.takeTurns(1);\n            await outputCallback([`Minute ${iteration++}`, world.toString(), world.resourceValue], true);\n            await pause();\n        }\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const world = World.fromLines(lines);\n        await outputCallback([\"Initial state\", world.toString()]);\n        const iteration = 1;\n        const target = 1000000000;\n        const newWorld = world.takeTurns(target);\n        await outputCallback([newWorld.resourceValue, newWorld.toString()], true);\n        // const turnsPerIteration = 5000;\n        // while (!isCancelled!()) {\n        //     let subIteration = 0;\n        //     const perSub = 10;\n        //     while (perSub * subIteration < turnsPerIteration) {\n        //         world = world.takeTurns(perSub);\n        //         await pause();\n        //         subIteration++;\n        //     }\n        //     await outputCallback([\n        //         `Minute ${iteration * turnsPerIteration}/${target}`,\n        //         `${iteration * turnsPerIteration / target}`,\n        //         world.toString(),\n        //         world.resourceValue\n        //     ], true);\n        //     iteration++;\n        // }\n    },\n    {\n        key: \"settlers-of-the-north-pole\",\n        title: \"Settlers of the North Pole\",\n        stars: 2,\n        customComponent: \"pause-and-run\",\n    }\n);\n","import { entryForFile } from \"../../entry\";\nimport { groupBy } from \"../../../support/sequences\";\nimport { Machine, Instruction, OpCode } from \"./chronal-classification\";\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const pointer = parseInt(lines[0][4], 10);\n        let machine = new Machine([0, 0, 0, 0, 0, 0], pointer);\n        const instructions = Instruction.fromLines(lines.slice(1), (s) => s as OpCode);\n        let iterations = 0;\n        while (machine.isExecutable(instructions.length)) {\n            const instruction = instructions[machine.nextInstructionAddress];\n            const oldMachine = machine;\n            machine = machine.execute(instruction);\n            const modVal = (++iterations) % 56197;\n            if (modVal <= 30) {\n                await outputCallback(`{${oldMachine.nextInstructionAddress}} ${JSON.stringify(oldMachine.registers)} | ${instruction} -> ${JSON.stringify(machine.registers)} => [${machine.instructionPointerRegister}] ${machine.nextInstructionAddress}`);\n            } else if (modVal === 31) {\n                await outputCallback(null);\n            } else if (iterations % 100 === 0) {\n                await pause();\n            }\n            if (isCancelled && isCancelled()) {\n                await outputCallback(\"Stopped!\");\n                break;\n            }\n        }\n        await outputCallback(`Result: ${machine.registers[0]}`);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const pointer = parseInt(lines[0][4], 10);\n        let machine = new Machine([1, 0, 0, 0, 0, 0], pointer);\n        const instructions = Instruction.fromLines(lines.slice(1), (s) => s as OpCode);\n        let iterations = 0;\n        const print = 30;\n        // const iterationBatch = 56197;\n        const iterationBatch = 1;\n        while (machine.isExecutable(instructions.length)) {\n            const instruction = instructions[machine.nextInstructionAddress];\n            if (machine.nextInstructionAddress === 1) {\n                await outputCallback({registers: machine.registers});\n                break;\n            }\n            const oldMachine = machine;\n            machine = machine.execute(instruction);\n            const modVal = (++iterations) % iterationBatch;\n            if (modVal <= print) {\n                await outputCallback(`{${oldMachine.nextInstructionAddress}} ${JSON.stringify(oldMachine.registers)} | ${instruction} -> ${JSON.stringify(machine.registers)} => [${machine.instructionPointerRegister}] ${machine.nextInstructionAddress}`);\n            } else if (modVal === print + 1) {\n                await outputCallback(null);\n            } else if (iterations % 100 === 0) {\n                await pause();\n            }\n            if (isCancelled && isCancelled()) {\n                await outputCallback(\"Stopped!\");\n                break;\n            }\n        }\n        await outputCallback(`Result: ${machine.registers[0]}`);\n\n        // by looking at the code, it calculates the sum of divisors; here's the one I used, translated:\n        /*\n 0 goto 17\n 1 b = 1\n 2 c = 1\n 3 e = b * c\n 4 eqrr e = (e == d)\n 5 goto 6 + e\n 6 goto 8\n 7 a = a + b\n 8 c++\n 9 e = c > d\n10 goto 11 + e\n11 goto 3\n12 b++\n13 e = b > d\n14 goto 15 + e\n15 goto 2\n16 exit\n17 d = d + 2\n18 d = d * d\n19 d = 19 * d\n20 d = d * 11\n21 e = e + 8\n22 e = e * 22\n23 e = e + 13\n24 d = e + d\n25 goto 26 + a\n26 goto 1\n27 e = 27\n28 e = e * 28\n29 e = e + 29\n30 e = e * 30\n31 e = e * 14\n32 e = e * 32\n33 d = e + d\n34 a = 0\n35 goto 1\n        */\n\n        // the setup of the values is the one in lines 27-34 (the first entry used 17-24); then it's just a question\n        // of calculating sum of divisors, I used the console directly, here's the function:\n        /*\nlet divisorSum = (c) => {\n    let sum = 0;\n    for (let i = 1; i <= c; i++) {\n        if (c % i === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n        */\n    },\n    {\n        key: \"go-with-the-flow\",\n        title: \"Go with the flow\",\n        stars: 2,\n        customComponent: \"pause-and-run\"\n    }\n);\n","import { entryForFile } from \"../../entry\";\nimport { NotImplementedError } from \"../../../support/error\";\nimport { CCoordinate, directions, manhattanDistance, Coordinate, ascendingCompare } from \"../../../support/geometry\";\nimport { UnknownSizeField } from \"../../../support/field\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { calculateDistances } from \"../../../support/labyrinth\";\n\ntype DirectionGroup = Directions[];\ntype Directions = Array<string | DirectionGroup>;\n\nconst parseGroup = (line: string, index: number): [DirectionGroup, number] => {\n    const groups: string[] = [];\n    let currentGroup: string[] = [];\n    index++;\n    let openCount = 0;\n    while (index < line.length) {\n        const currentChar = line[index];\n        if (openCount > 0) {\n            currentGroup.push(line[index]);\n            if (currentChar === \"(\") {\n                openCount++;\n            } else if (currentChar === \")\") {\n                openCount--;\n            }\n        } else {\n            if (currentChar === \"(\") {\n                openCount++;\n                currentGroup.push(currentChar);\n            } else if (currentChar === \")\") {\n                break;\n            } else if (currentChar === \"|\") {\n                groups.push(currentGroup.join(\"\"));\n                currentGroup = [];\n            } else {\n                currentGroup.push(currentChar);\n            }\n        }\n        index++;\n    }\n    if (line[index] !== \")\") {\n        throw new Error(\"Error while parsing, group not ended\");\n    }\n    groups.push(currentGroup.join(\"\"));\n    return [groups.map((group) => parse(group)), index];\n};\n\nconst isGroup = (d: (string | DirectionGroup)): d is DirectionGroup => {\n    return Array.isArray(d);\n};\n\n// if (stateCache) {\n//     const serializedCoordinate = serializeCoordinate(state);\n//     const serializedGroup = serializeDirectionGroup(firstElement);\n//     if (stateCache.has(serializedCoordinate)) {\n//         const directionCache = stateCache.get(serializedCoordinate)!;\n//         if (directionCache.has(serializedGroup)) {\n//             console.log(\"Found in cache!\");\n//             const states = directionCache.get(serializedGroup)!;\n//             for (const state of states) {\n//                 await visitCallback(null, state);\n//             }\n//             return;\n//         }\n//     }\n// }\n\n// if (stateCache) {\n//     if (!stateCache.has(serializedCoordinate)) {\n//         stateCache.set(serializedCoordinate, new Map<string, Coordinate[]>());\n//     }\n//     stateCache.get(serializedCoordinate)!.set(serializedGroup, states);\n// }\n\nconst bfsVisit = async <T>(\n    dirs: Directions,\n    index: number,\n    visitCallback: (token: string | null, state: T) => Promise<T>,\n    argState: T,\n    areStateEqual?: (a: T, b: T) => boolean,\n): Promise<void> => {\n    if (index >= dirs.length) {\n        await visitCallback(null, argState);\n        return;\n    }\n    const firstElement = dirs[index];\n    if (isGroup(firstElement)) {\n        let states: T[] = [];\n        for (const group of firstElement) {\n            await bfsVisit(group, 0, async (token, state) => {\n                const resultState = await visitCallback(token, state);\n                if (token === null) {\n                    states.push(resultState);\n                }\n                return resultState;\n            }, argState, areStateEqual);\n        }\n        if (areStateEqual) {\n            states = deduplicateStates(states, areStateEqual);\n        }\n        for (const s of states) {\n            await bfsVisit(dirs, index + 1, visitCallback, s, areStateEqual);\n        }\n    } else {\n        await bfsVisit(dirs, index + 1, visitCallback, await visitCallback(firstElement, argState), areStateEqual);\n    }\n};\n\nconst deduplicateStates = <T, >(states: T[], areStatesEqual: (a: T, b: T) => boolean): T[] => {\n    for (let i = 0; i < states.length; i++) {\n        const toKeep = states[i];\n        states = states.filter((e, index) => index <= i || !areStatesEqual(toKeep, e));\n    }\n    return states;\n};\n\nconst dfsVisit = async <T>(\n    dirs: Directions,\n    visitCallback: (token: string | null, state: T) => Promise<T>,\n    argState: T\n): Promise<void> => {\n    if (dirs.length === 0) {\n        await visitCallback(null, argState);\n        return;\n    }\n    const firstElement = dirs[0];\n    if (isGroup(firstElement)) {\n        for (const group of firstElement) {\n            await dfsVisit(group, async (token, state) => {\n                if (token === null) {\n                    await dfsVisit(dirs.slice(1), visitCallback, state);\n                    return state;\n                }\n                return await visitCallback(token, state);\n            }, argState);\n        }\n    } else {\n        await dfsVisit(dirs.slice(1), visitCallback, await visitCallback(firstElement, argState));\n    }\n};\n\nconst parse = (line: string): Directions => {\n    if (line.startsWith(\"^\")) {\n        line = line.slice(1);\n    }\n    if (line.endsWith(\"$\")) {\n        line = line.slice(0, -1);\n    }\n    let i = 0;\n    const dirs: Directions = [];\n    while (i < line.length) {\n        if (line[i] !== \"(\") {\n            dirs.push(line[i]);\n        } else {\n            const [group, endIndex] = parseGroup(line, i);\n            i = endIndex;\n            dirs.push(group);\n        }\n        i++;\n    }\n    return dirs;\n};\n\nconst directionMapper = (a: string): CCoordinate => {\n    switch (a.toUpperCase()) {\n        case \"W\":\n            return directions.left;\n        case \"E\":\n            return directions.right;\n        case \"N\":\n            return directions.up;\n        case \"S\":\n            return directions.down;\n        default:\n            throw new Error(\"Invalid direction \" + a);\n    }\n};\n\ninterface Door {\n    from: Coordinate;\n    to: Coordinate;\n}\n\nconst toRoomCoordinates = (coordinate: Coordinate): Coordinate => {\n    return {\n        x: coordinate.x * 2,\n        y: coordinate.y * 2\n    };\n};\n\nconst buildRoom = (field: UnknownSizeField<\"#\">, doors: Door[]): FixedSizeMatrix<string> => {\n    const baseMatrix = field.toMatrix();\n    const resultMatrix = new FixedSizeMatrix<string>({ x: baseMatrix.size.x * 2 + 1, y: baseMatrix.size.y * 2 + 1 });\n    resultMatrix.fill(\"#\");\n    resultMatrix.setDelta(baseMatrix.delta.sum(baseMatrix.delta).sum({ x: -1, y: -1 }));\n    baseMatrix.onEveryCell((coordinate, cell) => {\n        if (cell) {\n            resultMatrix.set(toRoomCoordinates(coordinate), \".\");\n        }\n    }\n    );\n    doors.forEach((door) => {\n        const from = toRoomCoordinates(door.from);\n        const to = toRoomCoordinates(door.to);\n        const dx = (to.x - from.x) / 2;\n        const dy = (to.y - from.y) / 2;\n        const cell = dy === 0 ? \"|\" : \"-\";\n        resultMatrix.set(new CCoordinate(dx, dy).sum(from), cell);\n    });\n    return resultMatrix;\n};\n\nexport const aRegularMap = entryForFile(\n    async ({ lines, outputCallback }) => {\n\n        const field = new UnknownSizeField<\"#\">();\n        field.set({ x: 0, y: 0 }, \"#\");\n        const parsed = parse(lines[0]);\n        let newCellCount = 0;\n        let alreadyVisited = 0;\n        let nullTokens = 0;\n        const doors: Door[] = [];\n        await bfsVisit(parsed, 0, async (token, state) => {\n            if (token === null) {\n                nullTokens++;\n                if (nullTokens > 0 && nullTokens % 1000 === 0) {\n                    await outputCallback(`Closing group ${nullTokens / 1000}k`);\n                }\n                return state;\n            }\n            const direction = directionMapper(token);\n            const newPosition = direction.sum(state);\n            doors.push({ from: state, to: newPosition });\n            if (field.get(newPosition) === null) {\n                newCellCount++;\n                field.set(newPosition, \"#\");\n                if (newCellCount > 0 && newCellCount % 100 === 0) {\n                    const matrix = field.toMatrix();\n                    await outputCallback(matrix.toString((e) => e || \".\"));\n                    await outputCallback(matrix.size);\n                }\n            } else {\n                alreadyVisited++;\n                if (alreadyVisited > 0 && alreadyVisited % 1000 === 0) {\n                    await outputCallback(`Already visited rising to ${alreadyVisited / 1000}k`);\n                }\n            }\n            return newPosition;\n        }, { x: 0, y: 0 }\n            , (a, b) => manhattanDistance(a, b) === 0\n        );\n\n        const resultRoom = buildRoom(field, doors);\n\n        await outputCallback(resultRoom.toString((e) => e || \" \"));\n        const distances = calculateDistances(\n            (coordinate) => field.get(coordinate),\n            (start, end) => (start.distance || 0) + manhattanDistance(start.coordinate, end),\n            (c) => {\n                const from = doors.filter((d) => manhattanDistance(d.from, c) === 0).map((e) => e.to);\n                const to = doors.filter((d) => manhattanDistance(d.to, c) === 0).map((e) => e.from);\n                const all = [...from, ...to];\n                const unique = new Set<string>();\n                const result: Coordinate[] = [];\n                all.forEach((i) => {\n                    const key = JSON.stringify({ x: i.x, y: i.y });\n                    if (unique.has(key)) {\n                        return;\n                    }\n                    unique.add(key);\n                    result.push(i);\n                });\n                return result;\n            },\n            { x: 0, y: 0 }\n        );\n\n        const maxDistance = distances.list.map((e) => e.distance).reduce((acc, next) => Math.max(acc || 0, next || 0));\n        await outputCallback(maxDistance);\n    },\n    async ({ lines, outputCallback }) => {\n        const field = new UnknownSizeField<\"#\">();\n        field.set({ x: 0, y: 0 }, \"#\");\n        const parsed = parse(lines[0]);\n        let newCellCount = 0;\n        let alreadyVisited = 0;\n        let nullTokens = 0;\n        const doors: Door[] = [];\n        await bfsVisit(parsed, 0, async (token, state) => {\n            if (token === null) {\n                nullTokens++;\n                if (nullTokens > 0 && nullTokens % 1000 === 0) {\n                    await outputCallback(`Closing group ${nullTokens / 1000}k`);\n                }\n                return state;\n            }\n            const direction = directionMapper(token);\n            const newPosition = direction.sum(state);\n            doors.push({ from: state, to: newPosition });\n            if (field.get(newPosition) === null) {\n                newCellCount++;\n                field.set(newPosition, \"#\");\n                if (newCellCount > 0 && newCellCount % 100 === 0) {\n                    const matrix = field.toMatrix();\n                    await outputCallback(matrix.toString((e) => e || \".\"));\n                    await outputCallback(matrix.size);\n                }\n            } else {\n                alreadyVisited++;\n                if (alreadyVisited > 0 && alreadyVisited % 1000 === 0) {\n                    await outputCallback(`Already visited rising to ${alreadyVisited / 1000}k`);\n                }\n            }\n            return newPosition;\n        }, { x: 0, y: 0 }\n            , (a, b) => manhattanDistance(a, b) === 0\n        );\n\n        const resultRoom = buildRoom(field, doors);\n\n        await outputCallback(resultRoom.toString((e) => e || \" \"));\n        const distances = calculateDistances(\n            (coordinate) => field.get(coordinate),\n            (start, end) => (start.distance || 0) + manhattanDistance(start.coordinate, end),\n            (c) => {\n                const from = doors.filter((d) => manhattanDistance(d.from, c) === 0).map((e) => e.to);\n                const to = doors.filter((d) => manhattanDistance(d.to, c) === 0).map((e) => e.from);\n                const all = [...from, ...to];\n                const unique = new Set<string>();\n                const result: Coordinate[] = [];\n                all.forEach((i) => {\n                    const key = JSON.stringify({ x: i.x, y: i.y });\n                    if (unique.has(key)) {\n                        return;\n                    }\n                    unique.add(key);\n                    result.push(i);\n                });\n                return result;\n            },\n            { x: 0, y: 0 }\n        );\n\n        const interestingDistances = distances\n            .list\n            .map((e) => e.distance)\n            .filter((d) => (d !== null && d >= 1000))\n            .length;\n        await outputCallback(interestingDistances);\n    },\n    { key: \"a-regular-map\", title: \"A Regular Map\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { Machine, Instruction, OpCode, MutableMachine } from \"./chronal-classification\";\r\n\r\nexport const chronalConversion = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const pointer = parseInt(lines[0][4], 10);\r\n        const machine = new MutableMachine([103548, 0, 0, 0, 0, 0], pointer);\r\n        const instructions = Instruction.fromLines(lines.slice(1), (s) => s as OpCode);\r\n        while (machine.isExecutable(instructions.length)) {\r\n            const instruction = instructions[machine.nextInstructionAddress];\r\n            machine.execute(instruction);\r\n            if (machine.nextInstructionAddress === instructions.length - 3) {\r\n                await outputCallback(machine.registers[4]);\r\n            }\r\n        }\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const pointer = parseInt(lines[0][4], 10);\r\n        const uniques = new Set<number>();\r\n        let lastFour: number = 0;\r\n        let iterations = 0;\r\n        const machine = new MutableMachine([103549, 0, 0, 0, 0, 0], pointer);\r\n        const instructions = Instruction.fromLines(lines.slice(1), (s) => s as OpCode);\r\n        if (instructions[28].code !== \"eqrr\") {\r\n            await outputCallback(\"Sorry, this solution is hardcoded on my input\");\r\n            throw new Error(\"Sorry, this solution is hardcoded on my input\");\r\n        }\r\n        while (machine.isExecutable(instructions.length)) {\r\n            const instruction = instructions[machine.nextInstructionAddress];\r\n            if (instruction.lineNumber === 28) {\r\n                if (++iterations % 10 === 0) {\r\n                    await outputCallback(`New comparison, ${iterations.toString().padStart(6, \" \")}`);\r\n                }\r\n                const fourValue = machine.registers[4];\r\n                if (uniques.has(fourValue)) {\r\n                    break;\r\n                }\r\n                uniques.add(fourValue);\r\n                lastFour = fourValue;\r\n            }\r\n            machine.execute(instruction);\r\n        }\r\n        await outputCallback(\"Last four: \" + lastFour);\r\n    },\r\n    { key: \"chronal-conversion\", title: \"Chronal Conversion\", stars: 2, }\r\n);\r\n","import { Coordinate, sumCoordinate, manhattanDistance, getSurrounding, getBoundaries, CCoordinate, isInBounds } from \"../../../support/geometry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport wu from \"wu\";\r\n\r\nimport Graph from \"node-dijkstra\";\r\nimport { entryForFile } from \"../../entry\";\r\n\r\ninterface Input {\r\n    target: Coordinate;\r\n    depth: number;\r\n}\r\n\r\nconst parseLines = (lines: string[]): Input => {\r\n    const [x, y] = lines[1].split(\" \")[1].split(\",\").map((e) => parseInt(e, 10));\r\n    return {\r\n        depth: parseInt(lines[0].split(\" \")[1], 10),\r\n        target: { x, y }\r\n    };\r\n};\r\n\r\nexport const buildMatrix = (input: Input, delta?: number | Coordinate): FixedSizeMatrix<number> => {\r\n    if (!delta) {\r\n        delta = { x: 1, y: 1 };\r\n    } else {\r\n        if ((delta as Coordinate).x === undefined) {\r\n            const nDelta = delta as number;\r\n            delta = { x: nDelta, y: nDelta };\r\n        }\r\n    }\r\n    return new FixedSizeMatrix<number>(sumCoordinate(input.target, delta as Coordinate));\r\n};\r\n\r\nexport const fillMatrix = (matrix: FixedSizeMatrix<number>, input: Input): void => {\r\n    for (let x = 0; x < matrix.size.x; x++) {\r\n        for (let y = 0; y < matrix.size.y; y++) {\r\n            if (x === 0 && y === 0) {\r\n                matrix.set({ x, y }, input.depth);\r\n            } else if (manhattanDistance({ x, y }, input.target) === 0) {\r\n                matrix.set(input.target, input.depth);\r\n            } else if (x === 0) {\r\n                matrix.set({ x, y }, erode(y * 48271, input));\r\n            } else if (y === 0) {\r\n                matrix.set({ x, y }, erode(x * 16807, input));\r\n            } else {\r\n                matrix.set({ x, y }, erode(matrix.get({ x: x - 1, y })! * matrix.get({ x, y: y - 1 })!, input));\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst erode = (n: number, input: Input): number => {\r\n    return (n + input.depth) % 20183;\r\n};\r\n\r\nexport type ErosionLevel = 0 | 1 | 2;\r\n\r\nconst createErosionMatrix = (matrix: FixedSizeMatrix<number>): FixedSizeMatrix<ErosionLevel> => {\r\n    const newMatrix = new FixedSizeMatrix<ErosionLevel>(matrix.size);\r\n    matrix.onEveryCell((coordinate, cell) => {\r\n        if (cell !== undefined) {\r\n            newMatrix.set(coordinate, (cell % 3) as ErosionLevel);\r\n        }\r\n    });\r\n    return newMatrix;\r\n};\r\n\r\nexport type Tool = \"climb\" | \"light\" | \"none\";\r\n\r\nexport interface Node { coordinate: Coordinate; tool: Tool; }\r\n\r\nexport const serializeNode = ({ coordinate, tool }: Node): string => `${coordinate.x},${coordinate.y},${tool}`;\r\nexport const deserializeNode = (serialized: string): Node => {\r\n    const [x, y, tool] = serialized.split(\",\");\r\n    if (tool !== \"climb\" && tool !== \"light\" && tool !== \"none\") {\r\n        throw new Error(\"Invalid tool\");\r\n    }\r\n    return {\r\n        coordinate: {\r\n            x: parseInt(x, 10),\r\n            y: parseInt(y, 10)\r\n        },\r\n        tool\r\n    };\r\n};\r\n\r\nconst getValidTools = (erosionLevel: ErosionLevel): Tool[] => {\r\n    switch (erosionLevel) {\r\n        case 0:\r\n            return [\"climb\", \"light\"];\r\n        case 1:\r\n            return [\"climb\", \"none\"];\r\n        case 2:\r\n            return [\"light\", \"none\"];\r\n    }\r\n};\r\n\r\nconst tools: Tool[] = [\"climb\", \"light\", \"none\"];\r\n\r\ninterface NodePaths { [key: string]: number; }\r\n\r\ninterface PathNode {\r\n    serialized: string;\r\n    node: Node;\r\n    distance: number | null;\r\n}\r\n\r\nclass CustomGraph {\r\n    private readonly _nodeMap = new Map<string, NodePaths>();\r\n\r\n    public addNode(node: Node, neighbours: Array<{ node: Node, weight: number }>) {\r\n        this._nodeMap.set(\r\n            serializeNode(node),\r\n            neighbours.reduce((acc: NodePaths, next) => {\r\n                acc[serializeNode(next.node)] = next.weight;\r\n                return acc;\r\n            }, {})\r\n        );\r\n    }\r\n\r\n    public path(startNode: Node, endNode: Node, options?: { cost?: boolean }):\r\n        number | null {\r\n        const toVisit: PathNode[] = wu(this._nodeMap.keys()).map((key) => ({\r\n            serialized: key,\r\n            node: deserializeNode(key),\r\n            distance: null\r\n        })).toArray();\r\n        const endSerialized = serializeNode(endNode);\r\n        wu(toVisit)\r\n            .filter((e) =>\r\n                e.node.tool === startNode.tool &&\r\n                manhattanDistance(e.node.coordinate, startNode.coordinate) === 0\r\n            ).forEach((e) => e.distance = 0);\r\n        while (toVisit.length > 0) {\r\n            const candidateDistance = wu(toVisit)\r\n                .filter((n) => n.distance !== null)\r\n                .map((d) => d.distance)\r\n                .reduce((acc, next) => Math.min(acc!, next!))\r\n                ;\r\n            if (candidateDistance === null) {\r\n                break;\r\n            }\r\n            const candidateNode =\r\n                wu(toVisit.map((e, i) => ({ e, i })))\r\n                    .find((e) => e.e.distance === candidateDistance);\r\n            if (candidateNode === undefined || candidateNode.e.distance === null) {\r\n                throw new Error(\"Could not find node :(\");\r\n            }\r\n            if (endSerialized === candidateNode.e.serialized) {\r\n                return candidateNode.e.distance;\r\n            }\r\n            const neighbours = this._nodeMap.get(candidateNode.e.serialized);\r\n            if (neighbours) {\r\n                Object.keys(neighbours).forEach((key) => {\r\n                    const serializedNode = key;\r\n                    const toVisitNode = wu(toVisit).find((node) => node.serialized === serializedNode);\r\n                    if (toVisitNode !== undefined) {\r\n                        toVisitNode.distance = candidateNode.e.distance! + neighbours[key];\r\n                        if (toVisitNode.serialized === endSerialized) {\r\n                            return toVisitNode.distance;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            toVisit.splice(candidateNode.i, 1);\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n\r\nexport const matrixSerializer = (e: 0 | 1 | 2 | undefined): \".\" | \"=\" | \"|\" | \"X\" => {\r\n    switch (e) {\r\n        case 0:\r\n            return \".\";\r\n        case 1:\r\n            return \"=\";\r\n        case 2:\r\n            return \"|\";\r\n        default:\r\n            return \"X\";\r\n    }\r\n};\r\nexport const modeMaze = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const input = parseLines(lines);\r\n        const erosionMatrix = createErosionMatrixFromInput(input);\r\n        await outputCallback(erosionMatrix.toString(matrixSerializer));\r\n        let sum = 0;\r\n        erosionMatrix.onEveryCell((coordinate, cell) => {\r\n            sum = sum + (cell || 0);\r\n        });\r\n        await outputCallback(sum);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const input = parseLines(lines);\r\n        const erosionMatrix = createErosionMatrixFromInput(input);\r\n\r\n        const resultPath = calculatePath(erosionMatrix, input.target);\r\n\r\n        for (const step of resultPath.path) {\r\n            await outputCallback(step);\r\n        }\r\n        await outputCallback(resultPath.cost);\r\n\r\n        new Map<string, number>().keys();\r\n    },\r\n    { key: \"mode-maze\", title: \"Mode Maze\", stars: 2, }\r\n);\r\n\r\nexport function createErosionMatrixFromInput(input: Input, delta: number | Coordinate = 100) {\r\n    const matrix = buildMatrix(input, delta);\r\n    fillMatrix(matrix, input);\r\n    const erosionMatrix = createErosionMatrix(matrix);\r\n    return erosionMatrix;\r\n}\r\n\r\nexport function calculatePath(\r\n    erosionMatrix: FixedSizeMatrix<ErosionLevel>,\r\n    target: Coordinate\r\n): { path: string[], cost: number } {\r\n    const weightedGraph = new Graph();\r\n    erosionMatrix.onEveryCell((coordinate, erosionLevel) => {\r\n        if (erosionLevel !== undefined) {\r\n            const validTools = getValidTools(erosionLevel);\r\n            validTools.forEach((tool) => {\r\n                const neighbours = getSurrounding(coordinate);\r\n                const neighbourNodes: Array<{\r\n                    node: Node;\r\n                    weight: number;\r\n                }> = neighbours.map((nCoord) => {\r\n                    const nErosion = erosionMatrix.get(nCoord);\r\n                    if (nErosion !== undefined) {\r\n                        const nTools = getValidTools(nErosion);\r\n                        if (nTools.indexOf(tool) >= 0) {\r\n                            return {\r\n                                node: {\r\n                                    coordinate: nCoord,\r\n                                    tool\r\n                                },\r\n                                weight: 1\r\n                            };\r\n                        }\r\n                    }\r\n                    return null;\r\n                }).filter((e) => e !== null)\r\n                    .map((e) => e!);\r\n                validTools.forEach((otherTool) => {\r\n                    if (otherTool !== tool) {\r\n                        neighbourNodes.push({ node: { coordinate, tool: otherTool }, weight: 7 });\r\n                    }\r\n                });\r\n                weightedGraph.addNode(serializeNode({ coordinate, tool }), neighbourNodes.reduce((acc: {\r\n                    [key: string]: number;\r\n                },                                                                                next) => {\r\n                    acc[serializeNode(next.node)] = next.weight;\r\n                    return acc;\r\n                }, {}));\r\n            });\r\n        }\r\n    });\r\n    const resultPath =\r\n        weightedGraph.path(\r\n            serializeNode({ coordinate: { x: 0, y: 0 }, tool: \"light\" }),\r\n            serializeNode({ coordinate: target, tool: \"light\" }),\r\n            { cost: true }\r\n        );\r\n    return resultPath;\r\n}\r\n","import { entryForFile } from \"../../entry\";\nimport { Coordinate, Coordinate3d, euclidean3dDistance, manhattanDistance } from \"../../../support/geometry\";\nimport { hexManhattanDistance } from \"../../../support/hex-geometry\";\n\ninterface NanobotInfo {\n    coordinate: Coordinate3d;\n    radius: number;\n}\n\nconst parseLines = (lines: string[]): NanobotInfo[] => {\n    return lines.map((line) => {\n        const [posToken, rToken] = line.split(\", \");\n        const [x, y, z] = posToken.split(\"=\")[1].slice(1, -1).split(\",\").map((e) => parseInt(e, 10));\n        const radius = parseInt(rToken.split(\"=\")[1], 10);\n        return {\n            coordinate: {x, y, z},\n            radius\n        };\n    });\n};\n\nexport const experimentalEmergencyTransportation = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const nanobotInfo = parseLines(lines);\n        await outputCallback(nanobotInfo);\n        const bestNanobot = nanobotInfo.reduce((acc, next) => {\n            if (acc.radius > next.radius) {\n                return acc;\n            } else {\n                return next;\n            }\n        });\n\n        const nanobotsInRange = nanobotInfo\n            .map((nanobot) => ({\n                bot: nanobot.coordinate,\n                r: nanobot.radius,\n                distance: manhattanDistance(nanobot.coordinate, bestNanobot.coordinate)\n            }))\n            .filter((e) => e.distance <= bestNanobot.radius)\n            ;\n        await outputCallback(nanobotsInRange.length);\n    },\n    async ({ lines, outputCallback }) => {\n        const nanobotInfo = parseLines(lines);\n        const distanceRanges = nanobotInfo.map((e) => ({\n            distance: manhattanDistance({x: 0, y: 0, z: 0}, e.coordinate),\n            radius: e.radius\n        })).map((e) => ({\n            start: Math.max(0, e.distance - e.radius),\n            end: e.distance + e.radius\n        }));\n        const segments = distanceRanges.flatMap((e) => [\n            {pos: e.start, value: 1},\n            {pos: e.end, value: -1}\n        ]).sort((a, b) => a.pos - b.pos);\n        let maxCount = 0;\n        let currentCount = 0;\n        let bestPos = null;\n        let bestEnd = null;\n        let updateBestEnd = false;\n        segments.forEach((e) => {\n            currentCount += e.value;\n            if (currentCount > maxCount) {\n                updateBestEnd = true;\n                maxCount = currentCount;\n                bestPos = e.pos;\n            } else if (updateBestEnd) {\n                bestEnd = e.pos;\n                updateBestEnd = false;\n            }\n        });\n        await outputCallback({bestPos, bestEnd});\n    },\n    { key: \"experimental-emergency-transportation\", title: \"Experimental Emergency Transportation\", stars: 2, }\n);\n","import { entryForFile } from \"../../entry\";\r\n\r\ninterface Abilities {\r\n    type: AbilityType;\r\n    damageType: string;\r\n}\r\n\r\ntype AbilityType = \"immune\" | \"weak\";\r\n\r\ninterface Group {\r\n    units: number;\r\n    hp: number;\r\n    damage: number;\r\n    damageType: string;\r\n    initiative: number;\r\n    abilities: Abilities[];\r\n    army: string;\r\n}\r\n\r\ninterface Army {\r\n    name: string;\r\n    groups: Group[];\r\n}\r\n\r\ninterface FightOrder {\r\n    group: Group;\r\n    target: Group | null;\r\n}\r\n\r\nconst fillWithTarget = (groups: Group[]): FightOrder[] => {\r\n    const targetable = [...groups];\r\n    return groups.map((group) => {\r\n        const candidates = targetable\r\n            .map((g, index) => ({ group: g, index }))\r\n            .filter((g) => g.group.army !== group.army)\r\n            .map((g) => ({\r\n                group: g.group,\r\n                damage: getDamage(group, g.group),\r\n                index: g.index\r\n            }))\r\n            .filter((e) => e.damage > 0)\r\n            .sort((a, b) => (b.damage - a.damage));\r\n\r\n\r\n        const target = candidates.length === 0 ? null : candidates[0];\r\n        if (target !== null) {\r\n            targetable.splice(target.index, 1);\r\n        }\r\n        return {\r\n            group,\r\n            target: target !== null ? target.group : null\r\n        };\r\n    });\r\n};\r\n\r\nconst getFightOrder = (armies: Army[]): FightOrder[] => {\r\n    const chooseOrder = armies.flatMap((army) => army.groups).map((g) => ({\r\n        effectivePower: getEffectivePower(g),\r\n        group: g\r\n    })).sort((a, b) => {\r\n        if (a.effectivePower === b.effectivePower) {\r\n            return b.group.initiative - a.group.initiative;\r\n        }\r\n        return b.effectivePower - a.effectivePower;\r\n    });\r\n    const withTarget = fillWithTarget(chooseOrder.map((e) => e.group));\r\n    return withTarget.sort((a, b) => b.group.initiative - a.group.initiative);\r\n};\r\n\r\nconst getEffectivePower = (group: Group): number => {\r\n    return group.units * group.damage;\r\n};\r\n\r\nconst getDamage = (group: Group, target: Group): number => {\r\n    const immunities = target.abilities.filter((a) => a.type === \"immune\").map((e) => e.damageType);\r\n    if (immunities.indexOf(group.damageType) >= 0) {\r\n        return 0;\r\n    }\r\n    const basePower = getEffectivePower(group);\r\n    const weaknesses = target.abilities.filter((a) => a.type === \"weak\").map((e) => e.damageType);\r\n    if (weaknesses.indexOf(group.damageType) >= 0) {\r\n        return basePower * 2;\r\n    }\r\n    return basePower;\r\n};\r\n\r\nconst fightRound = (armies: Army[]): void => {\r\n    const fightOrder = getFightOrder(armies);\r\n    fightOrder.forEach((element) => {\r\n        if (element.group.units > 0 && element.target !== null) {\r\n            const damage = getDamage(element.group, element.target);\r\n            element.target.units -= Math.max(Math.floor(damage / element.target.hp), 0);\r\n        }\r\n    });\r\n    armies.forEach((army) => army.groups = army.groups.filter((e) => e.units > 0));\r\n};\r\n\r\nconst parseAbilities = (section: string): Abilities[] => {\r\n    const singleSections = section.split(\"; \");\r\n    return singleSections.flatMap((single) => {\r\n        const tokens = single.split(\" \");\r\n        const type = tokens[0];\r\n        const damageTypes = tokens.slice(2).map((e) => e.endsWith(\",\") ? e.slice(0, -1) : e);\r\n        return damageTypes.map((damageType) => {\r\n            return {\r\n                type: type as AbilityType,\r\n                damageType\r\n            };\r\n        });\r\n    });\r\n};\r\n\r\nconst parseGroups = (lines: string[], army: string): Group[] => {\r\n    return lines.map((line) => {\r\n        const tokens = line.split(\" \");\r\n        const units = parseInt(tokens[0], 10);\r\n        const hp = parseInt(tokens[tokens.indexOf(\"hit\") - 1], 10);\r\n        const damageWordIndex = tokens.lastIndexOf(\"damage\");\r\n        const damage = parseInt(tokens[damageWordIndex - 2], 10);\r\n        const damageType = tokens[damageWordIndex - 1];\r\n        const initiativeIndex = tokens.lastIndexOf(\"initiative\") + 1;\r\n        const initiative = parseInt(tokens[initiativeIndex], 10);\r\n        const abilitySection = line.indexOf(\"(\") >= 0 ? line.slice(line.indexOf(\"(\") + 1, line.indexOf(\")\")) : \"\";\r\n        return {\r\n            units,\r\n            hp,\r\n            damage,\r\n            initiative,\r\n            damageType,\r\n            abilities: parseAbilities(abilitySection),\r\n            army\r\n        };\r\n    });\r\n};\r\n\r\nconst parseLines = (lines: string[]): Army[] => {\r\n    return lines.join(\"\\n\").split(\"\\n\\n\").map((rawArmy) => {\r\n        const armyLines = rawArmy.split(\"\\n\");\r\n        const name = armyLines[0].trim().slice(0, -1);\r\n        return {\r\n            name,\r\n            groups: parseGroups(armyLines.slice(1), name)\r\n        };\r\n    });\r\n};\r\n\r\nexport const serialize = (armies: Army[]): string => {\r\n    return armies.map((a) => [a.name + \":\"].concat(\r\n        a.groups\r\n            .map((g) => g.units)\r\n            .map((u, i) => `Group ${i} contains ${u} units`)\r\n    ).join(\"\\n\")).join(\"\\n\");\r\n};\r\n\r\nexport const boostArmy = (army: Army, amount: number) => {\r\n    army.groups.forEach((group) => group.damage += amount);\r\n};\r\n\r\nconst countUnits = (armies: Army[]): number => {\r\n    return armies.reduce((acc, next) => acc + next.groups.reduce((a, n) => a + n.units, 0), 0);\r\n};\r\n\r\nexport const immuneSystemSimulator20XX = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const armies = parseLines(lines);\r\n        await outputCallback(serialize(armies));\r\n        while (armies.filter((a) => a.groups.length > 0).length > 1) {\r\n            fightRound(armies);\r\n            await outputCallback(serialize(armies));\r\n        }\r\n        const winningArmy = armies.filter((e) => e.groups.length > 0)[0];\r\n        await outputCallback(`Army ${winningArmy.name} won with ${winningArmy.groups.reduce((acc, next) => acc + next.units, 0)} units`);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const armies = parseLines(lines);\r\n        let hasImmuneWon = false;\r\n        const immuneSystemArmyName = \"Immune System\";\r\n        let boostingBy = 0;\r\n        while (!hasImmuneWon) {\r\n            let isDraw = false;\r\n            boostingBy++;\r\n            const clonedArmies = armies.map((army) => ({\r\n                ...army,\r\n                groups: army.groups.map((group) => ({ ...group }))\r\n            }));\r\n            boostArmy(clonedArmies.filter((army) => army.name === immuneSystemArmyName)[0], boostingBy);\r\n            while (clonedArmies.filter((a) => a.groups.length > 0).length > 1) {\r\n                const lastUnits = countUnits(clonedArmies);\r\n                fightRound(clonedArmies);\r\n                const newUnits = countUnits(clonedArmies);\r\n                if (lastUnits === newUnits) {\r\n                    isDraw = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isDraw) {\r\n                await outputCallback(\"Draw!\");\r\n                continue;\r\n            }\r\n            const winningArmy = clonedArmies.filter((e) => e.groups.length > 0)[0];\r\n            hasImmuneWon = winningArmy.name === immuneSystemArmyName;\r\n            if (boostingBy % 1 === 0) {\r\n                await outputCallback(boostingBy);\r\n                await outputCallback(`${winningArmy.name} won by ${countUnits([winningArmy])} units`);\r\n            }\r\n        }\r\n        await outputCallback(\"Min boost: \" + boostingBy);\r\n    },\r\n    { key: \"immune-system-simulator-20xx\", title: \"Immune System Simulator 20XX\", stars: 2, }\r\n);\r\n","import { entryForFile } from \"../../entry\";\nimport { Stack } from \"linq-typescript\";\nimport wu from \"wu\";\n\ninterface Coordinate {\n    x: number;\n    y: number;\n    z: number;\n    t: number;\n}\n\nconst manhattanDistance = (a: Coordinate, b: Coordinate) => [\n    (e: Coordinate) => e.x,\n    (e: Coordinate) => e.y,\n    (e: Coordinate) => e.z,\n    (e: Coordinate) => e.t\n].map((e) => Math.abs(e(a) - e(b))).reduce((acc, next) => acc + next);\n\nconst parseLines = (lines: string[]): Coordinate[] => {\n    return lines.map(deserializeNode);\n};\n\nconst deserializeNode = (line: string): Coordinate => {\n        const [x, y, z, t] = line.trim().split(\",\").map((e) => parseInt(e, 10));\n        return { x, y, z, t };\n};\n\nclass Graph {\n    private readonly nodeMap: Map<string, Set<string>> = new Map<string, Set<string>>();\n\n    public addNode(node: Coordinate): void {\n        const key = this.serializeNode(node);\n        if (!this.nodeMap.has(key)) {\n            this.nodeMap.set(key, new Set<string>());\n        }\n    }\n\n    public addEdge(a: Coordinate, b: Coordinate): void {\n        this.addDirectEdge(a, b);\n        this.addDirectEdge(b, a);\n    }\n\n    public visit(a: Coordinate | string): Coordinate[] {\n        if (typeof a === \"string\") {\n            a = this.deserializeNode(a);\n        }\n        const visited = new Set<string>();\n        const toVisit = new Stack<string>();\n        toVisit.push(this.serializeNode(a));\n        while (true) {\n            const next = toVisit.pop();\n            if (next === undefined) {\n                break;\n            }\n            if (visited.has(next)) {\n                continue;\n            }\n            visited.add(next);\n            const neighbours = this.nodeMap.get(next) || new Set<string>();\n            neighbours.forEach((neighbour) => {\n                if (!visited.has(neighbour)) {\n                    toVisit.push(neighbour);\n                }\n            });\n        }\n        return wu(visited.values()).map((e) => this.deserializeNode(e)).toArray();\n    }\n\n    public findConstellations(): Coordinate[][] {\n        const allNodes = [...this.nodeMap.keys()];\n        const toVisit = new Stack<string>(allNodes);\n        const visited = new Set<string>();\n        const constellations: Coordinate[][] = [];\n        while (true) {\n            const next = toVisit.pop();\n            if (next === undefined) {\n                break;\n            }\n            if (visited.has(next)) {\n                continue;\n            }\n            const constellation = this.visit(next);\n            constellation.forEach((e) => visited.add(this.serializeNode(e)));\n            constellations.push(constellation);\n        }\n        return constellations;\n    }\n\n    private serializeNode(node: Coordinate): string {\n        return `${node.x},${node.y},${node.z},${node.t}`;\n    }\n\n    private deserializeNode(line: string): Coordinate {\n        return deserializeNode(line);\n    }\n\n    private getNodeList(a: Coordinate): Set<string> {\n        return this.nodeMap.get(this.serializeNode(a))!;\n    }\n\n    private addDirectEdge(a: Coordinate, b: Coordinate): void {\n        this.addNode(a);\n        const nodeList = this.getNodeList(a);\n        nodeList.add(this.serializeNode(b));\n    }\n}\n\nexport const fourDimensionalAdventure = entryForFile(\n    async ({ lines, outputCallback }) => {\n        const points = parseLines(lines);\n\n        const graph = new Graph();\n        for (let outer = 0; outer < points.length; outer++) {\n            graph.addNode(points[outer]);\n            for (let inner = outer + 1; inner < points.length; inner++) {\n                if (manhattanDistance(points[outer], points[inner]) <= 3) {\n                    graph.addEdge(points[outer], points[inner]);\n                }\n            }\n        }\n\n        const constellations = graph.findConstellations();\n        await outputCallback(constellations.length);\n    },\n    async ({ lines, outputCallback }) => {\n        throw Error(\"Not implemented\");\n    },\n    { key: \"four-dimensional-adventure\", title: \"Four-Dimensional Adventure\", stars: 2, }\n);\n","import { entry as frequencyEntry } from \"./frequency\";\nimport { entry as inventoryEntry } from \"./inventory\";\nimport { entry as matterSliceEntry } from \"./no-matter-how-you-slice-it\";\nimport { entry as reposeRecordEntry } from \"./repose-record\";\nimport { entry as alchemicalReduction } from \"./alchemical-reduction\";\nimport { entry as chronalCoordinates } from \"./chronal-coordinates\";\nimport { entry as sumParts } from \"./the-sum-of-its-parts\";\nimport { entry as memoryManeuver } from \"./memory-maneuver\";\nimport { entry as marbleMania } from \"./marble-mania\";\nimport { entry as starsAlign } from \"./the-stars-align\";\nimport { entry as chronalCharge } from \"./chronal-charge\";\nimport { entry as subterranean } from \"./subterranean\";\nimport { mineCartMadness } from \"./mine-cart-madness\";\nimport { entry as chocolateCharts } from \"./chocolate-charts\";\nimport { entry as beverageBandits } from \"./beverage-bandits\";\nimport { entry as chronalClassification } from \"./chronal-classification\";\nimport { entry as reservoirResearch } from \"./reservoir-research\";\nimport { entry as settlers } from \"./settlers-of-the-north-pole\";\nimport { entry as flow } from \"./go-with-the-flow\";\nimport { aRegularMap } from \"./a-regular-map\";\nimport { chronalConversion } from \"./chronal-conversion\";\nimport { modeMaze } from \"./mode-maze\";\nimport { experimentalEmergencyTransportation } from \"./experimental-emergency-transportation\";\nimport { immuneSystemSimulator20XX } from \"./immune-system-simulator-20xx\";\nimport { fourDimensionalAdventure } from \"./four-dimensional-adventure\";\n\nexport const entries = [\n        frequencyEntry,\n        inventoryEntry,\n        matterSliceEntry,\n        reposeRecordEntry,\n        alchemicalReduction,\n        chronalCoordinates,\n        sumParts,\n        memoryManeuver,\n        marbleMania,\n        starsAlign,\n        chronalCharge,\n        subterranean,\n        mineCartMadness,\n        chocolateCharts,\n        beverageBandits,\n        chronalClassification,\n        reservoirResearch,\n        settlers,\n        flow,\n        aRegularMap,\n        chronalConversion,\n        modeMaze,\n        experimentalEmergencyTransportation,\n        immuneSystemSimulator20XX,\n        fourDimensionalAdventure,\n    ];\n","import { entryForFile } from \"../../entry\";\n\nconst fuelCalculator = (mass: number) => Math.floor(mass / 3) - 2;\nconst intelligentFuelCalculator = (mass: number): number => {\n    const requirement = Math.floor(mass / 3) - 2;\n    if (requirement <= 0) {\n        return 0;\n    } else {\n        return requirement + intelligentFuelCalculator(requirement);\n    }\n};\n\nexport const entry = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const requirement = lines\n            .map((line) => parseInt(line, 10))\n            .map(fuelCalculator)\n            .reduce((acc, next) => acc + next, 0);\n\n        await outputCallback(`Result: ${requirement}`);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const requirement = lines\n            .map((line) => parseInt(line, 10))\n            .map(intelligentFuelCalculator)\n            .reduce((acc, next) => acc + next, 0);\n\n        await outputCallback(`Result: ${requirement}`);\n    },\n    { key: \"rocket-tyranny\", title: \"The Tyranny of the Rocket Equation\", stars: 2, embeddedData: true}\n);\n","import { entryForFile } from \"../../entry\";\n\nconst parse = (lines: string[]) => {\n    const joined = lines.join(\"\").split(\",\");\n    return joined.map((e) => parseInt(e, 10));\n};\n\nfunction handleSum(instructionPointer: number, memory: number[]): [number, number[]] {\n    return handleCode(instructionPointer, (a, b) => a + b, memory);\n}\n\nfunction handleMult(instructionPointer: number, memory: number[]): [number, number[]] {\n    return handleCode(instructionPointer, (a, b) => a * b, memory);\n}\n\nfunction handleCode(\n    instructionPointer: number,\n    aggregator: ((a: number, b: number) => number),\n    memory: number[]\n): [number, number[]] {\n    const firstParameter = memory[memory[instructionPointer + 1]];\n    const secondParameter = memory[memory[instructionPointer + 2]];\n    const storageAddress = memory[instructionPointer + 3];\n    memory = [...memory];\n    memory[storageAddress] = aggregator(firstParameter, secondParameter);\n    return iterate(instructionPointer + 4, memory);\n}\n\nfunction iterate(instructionPointer: number, memory: number[]): [number, number[]] {\n    const code = memory[instructionPointer];\n    switch (code) {\n        case 99:\n            return [instructionPointer, memory];\n        case 1:\n            return handleSum(instructionPointer, memory);\n        case 2:\n            return handleMult(instructionPointer, memory);\n        default:\n            throw Error(\"Code \" + code + \" not valid\");\n    }\n}\n\nexport const programAlarm = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const memory = parse(lines);\n        const [_, result] = iterate(0, memory);\n        await outputCallback(`Result: ${result[0]}`);\n        // const requirement = lines\n        //     .map(line => parseInt(line, 10))\n        //     .map(fuelCalculator)\n        //     .reduce((acc, next) => acc + next, 0);\n\n        // await outputCallback(`Result: ${requirement}`);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const memory = parse(lines);\n        for (let i = 0; i < 100; i++) {\n            for (let j = 0; j < 100; j++) {\n                memory[1] = i;\n                memory[2] = j;\n                try {\n                    const [_, result] = iterate(0, memory);\n                    if (result[0] === 19690720) {\n                        await outputCallback(`Result: ${i}${j < 10 ? \"0\" : \"\"}${j}`);\n                        return;\n                    }\n\n                } catch { }\n            }\n        }\n    },\n    { key: \"program-alarm\", title: \"1202 Program Alarm\", stars: 2, embeddedData: \"program-alarm/input\"}\n);\n","import { entryForFile } from \"../../entry\";\nimport { Coordinate, directions, sumCoordinate } from \"../../../support/geometry\";\nimport wu from \"wu\";\nimport { range } from \"../../../support/sequences\";\n\ninterface Movement {\n    direction: \"L\" | \"R\" | \"D\" | \"U\";\n    length: number;\n}\n\ninterface StepCoordinate {\n    step: number;\n    coordinate: Coordinate;\n}\n\nfunction mapDirection(direction: Movement[\"direction\"]): Coordinate {\n    switch (direction) {\n        case \"D\":\n            return directions.down;\n        case \"U\":\n            return directions.up;\n        case \"L\":\n            return directions.left;\n        case \"R\":\n            return directions.right;\n    }\n}\n\nfunction updatePosition(position: Coordinate, movement: Movement): Coordinate[] {\n    const directionCoordinate = mapDirection(movement.direction);\n    return wu(range(movement.length)).map((i) => {\n        position = sumCoordinate(position, directionCoordinate);\n        return position;\n    }).toArray();\n}\n\nfunction parseWire(s: string) {\n    return s.split(\",\").map((e) => ({\n        direction: e[0],\n        length: parseInt(e.slice(1), 10)\n    }) as Movement);\n}\n\ntype Cell = undefined | \"b\" | \"a\" | \"+\";\n\nfunction getIntersection<T, U>(a: T[], b: T[], comparer: (a: T, b: T) => number, mapper: (a: T, b: T) => U): U[] {\n    a = [...a];\n    b = [...b];\n    const result = [];\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < a.length - 1 && bIndex < b.length - 1) {\n        const comparison = comparer(a[aIndex], b[bIndex]);\n        if (comparison === 0) {\n            result.push(mapper(a[aIndex], b[bIndex]));\n            aIndex++;\n            bIndex++;\n        } else if (comparison < 0) {\n            aIndex++;\n        } else {\n            bIndex++;\n        }\n    }\n    return result;\n}\n\nexport const crossedWires = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const firstWire = parseWire(lines[0]);\n        const secondWire = parseWire(lines[1]);\n\n        const comparer = (a: Coordinate, b: Coordinate) => a.x === b.x ? (b.y - a.y) : b.x - a.x;\n        const firstCoordinates = getCoordinates({ x: 0, y: 0 }, firstWire).sort(comparer);\n        await outputCallback(\"Got first\");\n        const secondCoordinates = getCoordinates({ x: 0, y: 0 }, secondWire).sort(comparer);\n        await outputCallback(\"Got second\");\n\n        const intersection = getIntersection(firstCoordinates, secondCoordinates, comparer, (a, b) => a);\n\n        const minDistance = intersection\n            .map((i) => Math.abs(i.x) + Math.abs(i.y))\n            .reduce((acc, next) => Math.min(acc, next));\n\n        await outputCallback(`Result: ${minDistance}`);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const firstWire = parseWire(lines[0]);\n        const secondWire = parseWire(lines[1]);\n\n        const comparer = (a: StepCoordinate, b: StepCoordinate) =>\n            a.coordinate.x === b.coordinate.x ?\n                (b.coordinate.y - a.coordinate.y)\n                : b.coordinate.x - a.coordinate.x;\n        const firstCoordinates = getCoordinates({ x: 0, y: 0 }, firstWire);\n        const sortedFirst = firstCoordinates.map((c, i) => ({ coordinate: c, step: i + 1 })).sort(comparer);\n        await outputCallback(\"Got first\");\n        const secondCoordinates = getCoordinates({ x: 0, y: 0 }, secondWire);\n        const sortedSecond = secondCoordinates.map((c, i) => ({ coordinate: c, step: i + 1 })).sort(comparer);\n        await outputCallback(\"Got second\");\n\n        const intersection = getIntersection(\n            sortedFirst,\n            sortedSecond,\n            comparer,\n            (a, b) => ({ coordinate: a.coordinate, first: a.step, second: b.step })\n        );\n        const result = intersection.map((e) => e.first + e.second).reduce((acc, next) => Math.min(acc, next));\n        await outputCallback(`Result: ${result}`);\n    },\n    { key: \"crossed-wires\", title: \"Crossed Wires\", stars: 2, embeddedData: \"crossed-wires/crossed-wires\"}\n);\n\nfunction getCoordinates(currentPosition: Coordinate, movements: Movement[]) {\n    const coordinates = movements.flatMap((m) => {\n        const positions = updatePosition(currentPosition, m);\n        currentPosition = positions[positions.length - 1];\n        return positions;\n    });\n    return coordinates;\n}\n","import { entryForFile } from \"../../entry\";\n\nfunction isValidPassword(n: number, maxRepeating: number): boolean {\n    const stringed = n.toString();\n    let hasSame = false;\n    let repeating = 0;\n    for (let i = 0; i < stringed.length - 1; i++) {\n        if (stringed[i] === stringed[i + 1]) {\n            hasSame = true;\n            if (repeating === 0) {\n                repeating = 2;\n            } else {\n                repeating++;\n            }\n            if (repeating > maxRepeating) {\n                hasSame = false;\n            }\n        } else {\n            if (hasSame) {\n                break;\n            }\n            repeating = 0;\n        }\n    }\n    if (!hasSame) {\n        return false;\n    }\n\n    let prev = n % 10;\n    n = Math.floor(n / 10);\n    while (n > 0) {\n        const next = n % 10;\n        if (prev < next) {\n            return false;\n        }\n        prev = next;\n        n = Math.floor(n / 10);\n    }\n    return true;\n}\n\nexport const secureContainer = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        await calculate(lines, 6, outputCallback);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        await calculate(lines, 2, outputCallback);\n    },\n    { key: \"secure-container\", title: \"Secure Container\", stars: 2, embeddedData: true}\n);\n\nasync function calculate(\n    lines: string[],\n    maxRepeating: number,\n    outputCallback: (outputLine: any, shouldClear?: boolean | undefined) => Promise<void>\n) {\n    const min = parseInt(lines[0], 10);\n    const max = parseInt(lines[1], 10);\n    let current = min;\n    let count = 0;\n    while (current <= max) {\n        if (isValidPassword(current, maxRepeating)) {\n            count++;\n        }\n        current++;\n    }\n    await outputCallback(`Result: ${count}`);\n}\n","import { voidIsPromise } from \"./async\";\r\n\r\nexport type Memory = number[];\r\n\r\ntype ParameterMode = \"Position\" | \"Immediate\" | \"Relative\";\r\ninterface Operation {\r\n    code: number;\r\n    parameterModes: ParameterMode[];\r\n    parameters: number;\r\n}\r\n\r\nconst parameterMap: { [key: number]: number } = {\r\n    1: 3,\r\n    2: 3,\r\n    3: 1,\r\n    4: 1,\r\n    5: 2,\r\n    6: 2,\r\n    7: 3,\r\n    8: 3,\r\n    9: 1\r\n};\r\n\r\nfunction parseOperation(op: number): Operation {\r\n    const code = op % 100;\r\n    const parameters = parameterMap[code];\r\n    let modes = Math.floor(op / 100);\r\n    const parameterModes: ParameterMode[] = [];\r\n    while (modes > 0) {\r\n        if (modes % 10 === 0) {\r\n            parameterModes.push(\"Position\");\r\n        } else if (modes % 10 === 1) {\r\n            parameterModes.push(\"Immediate\");\r\n        } else if (modes % 10 === 2) {\r\n            parameterModes.push(\"Relative\");\r\n        }\r\n        modes = Math.floor(modes / 10);\r\n    }\r\n    let missing = parameters - parameterModes.length;\r\n    while (missing > 0) {\r\n        parameterModes.push(\"Position\");\r\n        missing--;\r\n    }\r\n    return {\r\n        code,\r\n        parameterModes,\r\n        parameters\r\n    };\r\n}\r\n\r\nasync function executeInstruction(\r\n    pointer: number,\r\n    memory: Memory,\r\n    input: () => Promise<number>,\r\n    output: (x: number) => void,\r\n    data: Data\r\n): Promise<[number, Memory]> {\r\n    const copy = [...memory];\r\n    const op = getMemoryAddress(memory, pointer);\r\n    const operation = parseOperation(op);\r\n    if (operationExecutorMap[operation.code]) {\r\n        let newPointer = await operationExecutorMap[operation.code](operation, pointer, copy, input, output, data);\r\n        if (!newPointer && newPointer !== 0) {\r\n            newPointer = pointer + operation.parameters + 1;\r\n        }\r\n        return [newPointer, copy];\r\n    } else {\r\n        throw Error(\"Operation not valid: \" + operation.code);\r\n    }\r\n}\r\n\r\nexport function inputGenerator(inputList: number[]) {\r\n    let i = 0;\r\n    return async () => {\r\n        if (i > inputList.length) {\r\n            throw new Error(\"Input is empty\");\r\n        }\r\n        return inputList[i++];\r\n    };\r\n}\r\n\r\ninterface Data {\r\n    relativeBase: number;\r\n}\r\n\r\nfunction memoryDump(memory: Memory, address: number): string {\r\n    return memory.map((cell, index) => {\r\n        if (index === address) {\r\n            return `->${cell}`;\r\n        } else {\r\n            return cell ? cell.toString() : \"0\";\r\n        }\r\n    }).map((cell, index) => (index % 10 === 0) ? `${index}: ${cell}` : cell).join(\" | \");\r\n}\r\n\r\ninterface ExecutionArgs {\r\n    memory: Memory;\r\n    input: () => Promise<number>;\r\n    output: (x: number) => void;\r\n    close?: () => void | Promise<void>;\r\n    data?: Data;\r\n    debug?: (e: any) => Promise<void>;\r\n    next?: () => Promise<void>;\r\n}\r\n\r\nexport async function execute({ memory, input, output, close, data, debug, next }: ExecutionArgs): Promise<Memory> {\r\n    if (!data) {\r\n        data = {\r\n            relativeBase: 0\r\n        };\r\n    }\r\n    let instructionPointer = 0;\r\n    if (debug) {\r\n        await debug(memoryDump(memory, instructionPointer));\r\n    }\r\n    while ((getMemoryAddress(memory, instructionPointer) % 100) !== 99) {\r\n        try {\r\n            [instructionPointer, memory] = await executeInstruction(instructionPointer, memory, input, output, data);\r\n            if (next) {\r\n                await next();\r\n            }\r\n        } catch (e) {\r\n            if (isStopExecution(e)) {\r\n                break;\r\n            }\r\n            throw e;\r\n        }\r\n        if (debug) {\r\n            await debug(memoryDump(memory, instructionPointer));\r\n        }\r\n    }\r\n    if (close) {\r\n        const closeResult = close();\r\n        if (voidIsPromise(closeResult)) {\r\n            await closeResult;\r\n        }\r\n    }\r\n    return memory;\r\n}\r\n\r\nclass StopExecution extends Error {\r\n    public readonly flag = \"IS_STOP_EXECUTION\";\r\n}\r\n\r\nfunction isStopExecution(e: Error): e is StopExecution {\r\n    return (e as StopExecution).flag === \"IS_STOP_EXECUTION\";\r\n}\r\n\r\nexport function stopExecution() {\r\n    throw new StopExecution();\r\n}\r\n\r\nexport function parseMemory(line: string): Memory {\r\n    const memory = line.split(\",\").map((e) => parseInt(e, 10));\r\n    return memory;\r\n}\r\n\r\nfunction getMemoryAddress(memory: Memory, address: number): number {\r\n    if (address < 0) {\r\n        throw new InterpreterError(\"Address out of range\", \"NegativeAddress\");\r\n    }\r\n    const value = memory[address];\r\n    if (!value) {\r\n        return 0;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nfunction getParameter(address: number, memory: Memory, parameterMode: ParameterMode, data: Data): number {\r\n    switch (parameterMode) {\r\n        case \"Position\":\r\n            return getMemoryAddress(memory, getMemoryAddress(memory, address));\r\n        case \"Immediate\":\r\n            return getMemoryAddress(memory, address);\r\n        case \"Relative\":\r\n            return getMemoryAddress(memory, getMemoryAddress(memory, address) + data.relativeBase);\r\n\r\n    }\r\n}\r\n\r\ntype ErrorCode = \"NegativeAddress\" | \"WriteError\";\r\n\r\nexport class InterpreterError extends Error {\r\n    public readonly errorType: string;\r\n    // public readonly errorCode: ErrorCode;\r\n    constructor(message: string, public readonly errorCode: ErrorCode) {\r\n        super(message);\r\n        this.errorType = \"InterpreterError\";\r\n\r\n    }\r\n}\r\n\r\nexport function isInterpretedError(e: Error): e is InterpreterError {\r\n    if ((e as InterpreterError).errorType === \"InterpreterError\") {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\ntype OperationExecutor = (\r\n    operation: Operation,\r\n    instructionPointer: number,\r\n    memory: Memory,\r\n    input: () => Promise<number>,\r\n    output: (x: number) => void | Promise<void>,\r\n    data: Data\r\n) => Promise<number | void>;\r\n\r\nfunction getOperationParameter(n: number, address: number, memory: Memory, operation: Operation, data: Data) {\r\n    return getParameter(address + n, memory, operation.parameterModes[n - 1], data);\r\n}\r\n\r\nfunction getParameters(address: number, memory: Memory, operation: Operation, data: Data): number[] {\r\n    const params = [];\r\n    for (let i = 0; i < operation.parameters; i++) {\r\n        params.push(getOperationParameter(i + 1, address, memory, operation, data));\r\n    }\r\n    return params;\r\n}\r\n\r\nfunction writeMemory(\r\n    memory: Memory,\r\n    parameterNumber: number,\r\n    address: number,\r\n    operation: Operation,\r\n    data: Data,\r\n    result: number\r\n) {\r\n    switch (operation.parameterModes[parameterNumber - 1]) {\r\n        case \"Immediate\":\r\n            throw new InterpreterError(\"Cannot write in immediate mode\", \"WriteError\");\r\n        case \"Position\":\r\n            memory[getMemoryAddress(memory, address + parameterNumber)] = result;\r\n            break;\r\n        case \"Relative\":\r\n            memory[data.relativeBase + getMemoryAddress(memory, address + parameterNumber)] = result;\r\n            break;\r\n        default:\r\n            throw new InterpreterError(\"Cannot find parameter mode\", \"WriteError\");\r\n    }\r\n}\r\n\r\nconst operationExecutorMap: { [key: number]: OperationExecutor } = {\r\n    1: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [firstParameter, secondParameter] = getParameters(instructionPointer, memory, operation, data);\r\n        writeMemory(memory, 3, instructionPointer, operation, data, firstParameter + secondParameter);\r\n    },\r\n    2: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [firstParameter, secondParameter] = getParameters(instructionPointer, memory, operation, data);\r\n        writeMemory(memory, 3, instructionPointer, operation, data, firstParameter * secondParameter);\r\n    },\r\n    3: async (operation, instructionPointer, memory, input, output, data) => {\r\n        writeMemory(memory, 1, instructionPointer, operation, data, await input());\r\n    },\r\n    4: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [parameter] = getParameters(instructionPointer, memory, operation, data);\r\n        const result = output(parameter);\r\n        if (voidIsPromise(result)) {\r\n            await result;\r\n        }\r\n    },\r\n    5: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [parameter, ret] = getParameters(instructionPointer, memory, operation, data);\r\n        if (parameter !== 0) {\r\n            return ret;\r\n        }\r\n    },\r\n    6: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [parameter, ret] = getParameters(instructionPointer, memory, operation, data);\r\n        if (parameter === 0) {\r\n            return ret;\r\n        }\r\n    },\r\n    7: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [firstParameter, secondParameter] = getParameters(instructionPointer, memory, operation, data);\r\n        let result: number = 0;\r\n        if (firstParameter < secondParameter) {\r\n            result = 1;\r\n        }\r\n        writeMemory(memory, 3, instructionPointer, operation, data, result);\r\n    },\r\n    8: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [firstParameter, secondParameter] = getParameters(instructionPointer, memory, operation, data);\r\n        let result: number = 0;\r\n        if (firstParameter === secondParameter) {\r\n            result = 1;\r\n        }\r\n        writeMemory(memory, 3, instructionPointer, operation, data, result);\r\n    },\r\n    9: async (operation, instructionPointer, memory, input, output, data) => {\r\n        const [firstParameter] = getParameters(instructionPointer, memory, operation, data);\r\n        data.relativeBase += firstParameter;\r\n    }\r\n};\r\n","import { entryForFile } from \"../../entry\";\nimport { execute } from \"../../../support/intcode\";\nexport const sunnyAsteroids = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const memory = lines[0].split(\",\").map((e) => parseInt(e, 10));\n        const output: number[] = [];\n        await execute({\n            memory,\n            input: (() => {\n                const isFirst = true;\n                return async () => { if (isFirst) { return 1; } else { throw Error(); } };\n            })(),\n            output: (e: number) => output.push(e),\n            debug: outputCallback\n        });\n        // await outputCallback(output[output.length - 1]);\n        await outputCallback(output);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const memory = lines[0].split(\",\").map((e) => parseInt(e, 10));\n        const output: number[] = [];\n        await execute({\n            memory,\n            input: (() => {\n                const isFirst = true;\n                return async () => { if (isFirst) { return 5; } else { throw Error(); } };\n            })(),\n            output: (e: number) => output.push(e)\n        });\n        await outputCallback(output);\n    },\n    { key: \"sunny-asteroids\", title: \"Sunny with a Change of Asteroids\", stars: 2, embeddedData: \"sunny-asteroids/sunny-asteroids\"}\n);\n","import { entryForFile } from \"../../entry\";\nimport { Tree } from \"../../../support/data-structure\";\n\ninterface Planet {\n    code: string;\n    distance: number | null;\n    orbiting: string | null;\n}\n\ntype PlanetChain = Tree<Planet>;\n\ninterface Orbit {\n    center: string;\n    orbiting: string;\n}\n\nfunction parseLine(line: string): Orbit {\n    const tokenized = line.trim().split(\")\");\n    return {\n        center: tokenized[0],\n        orbiting: tokenized[1]\n    };\n}\n\ninterface NodeMap { [key: string]: Planet; }\n\nfunction fillDistance(nodeMap: NodeMap, code: string | null) {\n    if (code == null) {\n        return;\n    }\n    const node = nodeMap[code];\n    if (node.distance !== null) {\n        return;\n    }\n    const parentCode = node.orbiting;\n    if (parentCode === null) {\n        node.distance = 1;\n        return;\n    }\n    const parentNode = nodeMap[parentCode];\n    if (parentNode.distance !== null) {\n        node.distance = parentNode.distance + 1;\n        return;\n    }\n    fillDistance(nodeMap, parentCode);\n    node.distance = parentNode.distance! + 1;\n}\n\nfunction getChain(start: string, nodeMap: NodeMap): string[] {\n    let currentNode = nodeMap[start];\n    const result: string[] = [];\n    while (currentNode.orbiting !== null) {\n        result.push(currentNode.orbiting);\n        currentNode = nodeMap[currentNode.orbiting];\n    }\n    return result;\n}\n\nfunction getFirstIntersection(a: string[], b: string[]): string {\n    const otherSet = new Set<string>(b);\n    for (const planet of a) {\n        if (otherSet.has(planet)) {\n            return planet;\n        }\n    }\n    throw new Error(\"Not intersection found!\");\n}\n\nexport const universalObritMap = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const nodes: NodeMap = {};\n\n        const center = \"COM\";\n        nodes[center] = {\n            code: center,\n            distance: 0,\n            orbiting: null\n        };\n\n        // const chain = new Tree<Planet>(nodes[center]);\n\n        lines.forEach((line) => {\n            const orbit = parseLine(line);\n            nodes[orbit.orbiting] = {\n                code: orbit.orbiting,\n                distance: null,\n                orbiting: orbit.center\n            };\n        });\n        Object.keys(nodes).forEach((n) => fillDistance(nodes, n));\n\n        const sum = Object.values(nodes).map((n) => n.distance!).reduce((acc, next) => acc + next);\n        await outputCallback(sum);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const nodes: NodeMap = {};\n\n        const center = \"COM\";\n        nodes[center] = {\n            code: center,\n            distance: 0,\n            orbiting: null\n        };\n\n        lines.forEach((line) => {\n            const orbit = parseLine(line);\n            nodes[orbit.orbiting] = {\n                code: orbit.orbiting,\n                distance: null,\n                orbiting: orbit.center\n            };\n        });\n\n\n        const mine = \"YOU\";\n        const santa = \"SAN\";\n\n        const mineChain = getChain(mine, nodes);\n        const santaChain = getChain(santa, nodes);\n\n        const firstIntersection = getFirstIntersection(mineChain, santaChain);\n\n        const result = mineChain.indexOf(firstIntersection) + santaChain.indexOf(firstIntersection);\n        await outputCallback(result);\n    },\n    { key: \"universal-orbit-map\", title: \"Universal Orbit Map\", stars: 2, embeddedData: \"universal-orbit-map/universal-orbit-map\"}\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { parseMemory, execute, inputGenerator } from \"../../../support/intcode\";\r\nimport { forEachAsync } from \"../../../support/async\";\r\nimport { programAlarm } from \"./program-alarm\";\r\n\r\ninterface Connector {\r\n    input: () => Promise<number>;\r\n    output: (e: number) => void;\r\n    close: () => void;\r\n}\r\n\r\nfunction generateConnector(startingInput: number[], additionalOutput?: (e: number) => void): Connector {\r\n    const outputBuffer: number[] = [...startingInput];\r\n    let nextReadIndex = 0;\r\n    let resolver: ((e: number) => void) | null = null;\r\n    let rejector: (() => void) | null = null;\r\n    let isClosed: boolean = false;\r\n    const output = (e: number) => {\r\n        outputBuffer.push(e);\r\n        if (additionalOutput) {\r\n            additionalOutput(e);\r\n        }\r\n        if (resolver !== null) {\r\n            resolver(outputBuffer[nextReadIndex++]);\r\n        }\r\n    };\r\n    const input = async (): Promise<number> => {\r\n        if (isClosed) {\r\n            throw Error(\"Input is closed\");\r\n        }\r\n        if (nextReadIndex < outputBuffer.length) {\r\n            return outputBuffer[nextReadIndex++];\r\n        } else {\r\n            const promise = new Promise<number>((resolve, reject) => {\r\n                resolver = resolve;\r\n                rejector = reject;\r\n            });\r\n            return await promise;\r\n        }\r\n    };\r\n    const close = () => {\r\n        isClosed = true;\r\n        if (rejector) {\r\n            rejector();\r\n        }\r\n    };\r\n\r\n    return { output, input, close };\r\n}\r\n\r\nfunction generatePermutations<T>(l: T[]): T[][] {\r\n    const res: T[][] = [];\r\n    if (l.length === 0) {\r\n        return [[]];\r\n    }\r\n\r\n    for (let i = 0; i < l.length; i++) {\r\n        const subs = generatePermutations(l.slice(0, i).concat(l.slice(i + 1, l.length)));\r\n        for (const sub of subs) {\r\n            const full = [l[i]].concat(sub);\r\n            res.push(full);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexport const amplificationCircuit = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const baseMemory = parseMemory(lines[0]);\r\n        const permutations = generatePermutations([0, 1, 2, 3, 4]);\r\n        let currentMax = Number.NEGATIVE_INFINITY;\r\n        // permutations = [[0, 1, 2, 3, 4]];\r\n        permutations.forEach((permutation) => {\r\n            let signal = 0;\r\n            for (const id of permutation) {\r\n                const input = inputGenerator([id, signal]);\r\n                const promiseResult = execute({ memory: baseMemory, input, output: (e) => signal = e });\r\n            }\r\n            currentMax = Math.max(currentMax, signal);\r\n        });\r\n        await outputCallback(currentMax);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const baseMemory = parseMemory(lines[0]);\r\n        const permutations = generatePermutations([9, 8, 7, 6, 5]);\r\n        let currentMax = Number.NEGATIVE_INFINITY;\r\n        // permutations = [[0, 1, 2, 3, 4]];\r\n        await forEachAsync(permutations, async (permutation) => {\r\n            const programs = permutation.map((i) => ({\r\n                memory: baseMemory,\r\n                phase: i,\r\n                isLast: false,\r\n                hasExecuted: false,\r\n                inConnector: null as (Connector | null),\r\n                outConnector: null as (Connector | null)\r\n            }));\r\n            programs[programs.length - 1].isLast = true;\r\n\r\n            for (let i = 1; i < programs.length; i++) {\r\n                const connector = generateConnector([programs[i].phase]);\r\n                programs[i - 1].outConnector = connector;\r\n                programs[i].inConnector = connector;\r\n            }\r\n\r\n            let output: number | null = null;\r\n            const loopConnector = generateConnector([programs[0].phase, 0], (e) => output = e);\r\n            programs[0].inConnector = loopConnector;\r\n            programs[programs.length - 1].outConnector = loopConnector;\r\n\r\n            const promises = programs.map((program) => {\r\n                return execute({\r\n                    memory: baseMemory,\r\n                    input: program.inConnector!.input,\r\n                    output: program.outConnector!.output,\r\n                    close: program.outConnector!.close\r\n                });\r\n            });\r\n\r\n            await Promise.all(promises);\r\n\r\n            if (output == null) {\r\n                throw new Error(\"No outpu!\");\r\n            }\r\n            currentMax = Math.max(currentMax, output);\r\n        });\r\n        await outputCallback(currentMax);\r\n    },\r\n    { key: \"amplification-circuit\", title: \"Amplification Circuit\", stars: 2, embeddedData: \"amplification-circuit/input\"}\r\n);\r\n\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport wu from \"wu\";\r\nimport { forEachAsync } from \"../../../support/async\";\r\n\r\nexport const spaceImageFormat = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const width = 25;\r\n        const height = 6;\r\n        const input = lines[0].split(\"\").map((e) => parseInt(e, 10));\r\n        const inputSize = input.length;\r\n        const layerSize = width * height;\r\n        const layers: Array<FixedSizeMatrix<number>> = [];\r\n        for (let i = 0; i < inputSize; i += layerSize) {\r\n            const newLayer = new FixedSizeMatrix<number>({ x: width, y: height });\r\n            newLayer.setFlatData(input.slice(i, i + layerSize));\r\n            layers.push(newLayer);\r\n        }\r\n\r\n        const smallestLayer = layers.map((layer) => ({\r\n            zeros: layer.data.filter((e) => e === 0).length,\r\n            data: layer.data\r\n        })).sort((a, b) => a.zeros - b.zeros)[0].data;\r\n        const ones = smallestLayer.filter((e) => e === 1).length;\r\n        const twos = smallestLayer.filter((e) => e === 2).length;\r\n        await outputCallback(ones * twos);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const width = 25;\r\n        const height = 6;\r\n        const input = lines[0].split(\"\").map((e) => parseInt(e, 10));\r\n        const inputSize = input.length;\r\n        const layerSize = width * height;\r\n        const layers: Array<FixedSizeMatrix<number>> = [];\r\n        for (let i = 0; i < inputSize; i += layerSize) {\r\n            const newLayer = new FixedSizeMatrix<number>({ x: width, y: height });\r\n            newLayer.setFlatData(input.slice(i, i + layerSize));\r\n            layers.push(newLayer);\r\n        }\r\n\r\n        const result = new FixedSizeMatrix<number>({ x: width, y: height });\r\n        for (let x = 0; x < width; x++) {\r\n            for (let y = 0; y < height; y++) {\r\n                let currentLayer = 0;\r\n                while (layers[currentLayer].get({ x, y }) === 2) {\r\n                    currentLayer++;\r\n                }\r\n                result.set({ x, y }, layers[currentLayer].get({ x, y })!);\r\n            }\r\n        }\r\n\r\n        const output = wu(result.overRows())\r\n            .map((row) => row.map((e) => e === 0 ? \" \" : \"X\").join(\"\"))\r\n            .toArray();\r\n\r\n        await forEachAsync(output, async (row) => await outputCallback(row));\r\n    },\r\n    { key: \"space-image-format\", title: \"Space Image Format\", stars: 2, embeddedData: true}\r\n);\r\n\r\n","import { entryForFile } from \"../../entry\";\nimport { execute, parseMemory } from \"../../../support/intcode\";\nexport const sensorBoost = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const source = lines[0];\n        const memory = parseMemory(source);\n        const output: number[] = [];\n        await execute({\n            memory, input: async () => 1, output: (e) => {\n                output.push(e);\n            }, close: () => { }\n        });\n\n        await outputCallback(output);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const source = lines[0];\n        const memory = parseMemory(source);\n        const output: number[] = [];\n        await execute({\n            memory, input: async () => 2, output: (e) => {\n                output.push(e);\n            }, close: () => { }\n        });\n\n        await outputCallback(output);\n    },\n    { key: \"sensor-boost\", title: \"Sensor Boost\", stars: 2, embeddedData: \"sensor-boost/sensor-boost\"}\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport wu from \"wu\";\r\nimport { Coordinate, diffCoordinate } from \"../../../support/geometry\";\r\n\r\ntype Cell = \".\" | \"#\";\r\n\r\ntype Grid = FixedSizeMatrix<Cell>;\r\n\r\nfunction parseInput(lines: string[]): Grid {\r\n    lines = lines.map((l) => l.trim()).filter((l) => !l.startsWith(\"--\"));\r\n    const rawCells = lines.map((l) => l.split(\"\").map((c) => c === \"#\" ? c : \".\"));\r\n    const width = rawCells[0].length;\r\n    const height = rawCells.length;\r\n    const matrix = new FixedSizeMatrix<Cell>({ x: width, y: height });\r\n    matrix.setFlatData(rawCells.flatMap((c) => c));\r\n    return matrix;\r\n}\r\n\r\ninterface Asteroid {\r\n    coordinate: Coordinate;\r\n    canSee?: Asteroid[];\r\n}\r\n\r\ninterface Visible {\r\n    asteroid: Asteroid;\r\n    isHidden?: boolean;\r\n}\r\n\r\ninterface Coefficients {\r\n    m: number;\r\n    q: number;\r\n}\r\n\r\nfunction fillVisibilities(asteroids: Asteroid[]) {\r\n    asteroids.forEach((asteroid) => fillVisibility(asteroid, asteroids));\r\n}\r\n\r\nfunction fillVisibility(asteroid: Asteroid, asteroids: Asteroid[]) {\r\n    const asteroidsWithVisibility = asteroids.map<Visible>((e) => ({ asteroid: e, isHidden: false }));\r\n    asteroidsWithVisibility.forEach((otherAsteroid) => {\r\n        if (otherAsteroid.isHidden !== true) {\r\n            const mainVector = diffCoordinate(otherAsteroid.asteroid.coordinate, asteroid.coordinate);\r\n            asteroidsWithVisibility.forEach((candidate) => {\r\n                if (candidate.isHidden !== true) {\r\n                    if (candidate.asteroid === asteroid) {\r\n                        candidate.isHidden = true;\r\n                    } else if (candidate.asteroid !== otherAsteroid.asteroid) {\r\n                        const candidateVector = diffCoordinate(candidate.asteroid.coordinate, asteroid.coordinate);\r\n                        if (mainVector.x === 0) {\r\n                            if (candidateVector.x !== 0) {\r\n                                return;\r\n                            }\r\n                        }\r\n                        if (mainVector.x === 0) {\r\n                            if (candidateVector.x === 0) {\r\n                                if (mainVector.y === 0) {\r\n                                    candidate.isHidden = candidateVector.y === 0;\r\n                                } else {\r\n                                    const coeff = candidateVector.y / mainVector.y;\r\n                                    candidate.isHidden = coeff > 1;\r\n                                }\r\n                            }\r\n                        } else if (mainVector.y === 0) {\r\n                            if (candidateVector.y === 0) {\r\n                                const coeff = candidateVector.x / mainVector.x;\r\n                                candidate.isHidden = coeff > 1;\r\n                            }\r\n                        } else {\r\n                            const xCoeff = candidateVector.x / mainVector.x;\r\n                            const yCoeff = candidateVector.y / mainVector.y;\r\n                            if (xCoeff === yCoeff && xCoeff > 1) {\r\n                                candidate.isHidden = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n    asteroid.canSee = asteroidsWithVisibility.filter((a) => a.isHidden !== true).map((e) => e.asteroid);\r\n}\r\n\r\n\r\nexport const monitoringStation = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const asteroids = getVisibilities(lines);\r\n        const maxVisibility = asteroids.reduce((acc, next) => Math.max(acc, (next.canSee || []).length), 0);\r\n        await outputCallback(maxVisibility);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        let asteroids = getAsteroids(lines);\r\n        fillVisibilities(asteroids);\r\n        const station = asteroids.reduce((acc, next) => {\r\n            if (next.canSee && next.canSee.length > acc.canSee!.length) {\r\n                return next;\r\n            } else {\r\n                return acc;\r\n            }\r\n        });\r\n\r\n        await outputCallback(`Station: (${station.coordinate.x}, ${station.coordinate.y})`);\r\n        const topVisible =\r\n            station.canSee!\r\n                .filter((e) => e.coordinate.x === station.coordinate.x)\r\n                .map((e) => e.coordinate.y)\r\n                .join(\" \");\r\n        await outputCallback(`Can see on top: ${topVisible}`);\r\n\r\n        let howManyKilled = 0;\r\n        const howManyToKill = 200;\r\n        while (howManyKilled < howManyToKill) {\r\n            const visible = station.canSee!;\r\n            const killList = visible\r\n                .map((e) => ({\r\n                    e,\r\n                    polar: Math.atan2(station.coordinate.y - e.coordinate.y, -e.coordinate.x + station.coordinate.x)\r\n                }))\r\n                .map((e) => ({ ...e, polar: e.polar < Math.PI / 2 ? e.polar + (2 * Math.PI) : e.polar }))\r\n                .map((e) => ({ ...e, polar: -e.polar }))\r\n                .sort((a, b) => b.polar - a.polar);\r\n            if (killList.length === 0) {\r\n                await outputCallback(\"I'm done without having killed enough :(\");\r\n                break;\r\n            }\r\n\r\n            for (const toKill of killList) {\r\n                const killedCoordinate = `(${toKill.e.coordinate.x}, ${toKill.e.coordinate.y})`;\r\n                await outputCallback(`${howManyKilled + 1}) Killed: ${killedCoordinate}`);\r\n                asteroids = asteroids\r\n                    .filter((e) =>\r\n                        e.coordinate.x !== toKill.e.coordinate.x ||\r\n                        e.coordinate.y !== toKill.e.coordinate.y\r\n                    );\r\n                howManyKilled++;\r\n                if (howManyKilled === howManyToKill) {\r\n                    break;\r\n                }\r\n            }\r\n            fillVisibilities(asteroids);\r\n        }\r\n    },\r\n    { key: \"monitoring-station\", title: \"Monitoring Station\", stars: 2, embeddedData: \"monitoring-station/input\"}\r\n);\r\n\r\nfunction getVisibilities(lines: string[]) {\r\n    const asteroids = getAsteroids(lines);\r\n    fillVisibilities(asteroids);\r\n    return asteroids;\r\n}\r\n\r\nfunction getAsteroids(lines: string[]) {\r\n    const grid = parseInput(lines);\r\n    let y = 0;\r\n    const asteroids = wu(grid.overRows()).map((row) => {\r\n        const mapped = row\r\n            .map((cell, x) => ({ cell, x, y }))\r\n            .filter((e) => e.cell === \"#\")\r\n            .map<Asteroid>((e) => ({ coordinate: { x: e.x, y: e.y } }));\r\n        y++;\r\n        return mapped;\r\n    }).reduce((acc, next) => acc.concat(next), []);\r\n    return asteroids;\r\n}\r\n\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\n\r\nimport * as geometry from \"../../../support/geometry\";\r\nimport { Coordinate, CCoordinate, rotate, Rotation } from \"../../../support/geometry\";\r\nimport { execute, parseMemory } from \"../../..//support/intcode\";\r\nimport { ascending } from \"../../../support/best\";\r\nimport wu from \"wu\";\r\n\r\ntype Color = \"Black\" | \"White\";\r\n\r\ntype Cell = \"#\" | \".\";\r\n\r\n\r\ninterface Step {\r\n    coordinate: Coordinate;\r\n    color: Color;\r\n}\r\n\r\nfunction deserializeRotation(n: number): Rotation {\r\n    if (n === 1) {\r\n        return \"Counterclockwise\";\r\n    } else {\r\n        return \"Clockwise\";\r\n    }\r\n}\r\n\r\n\r\nfunction serializeColor(c: Color): number {\r\n    return c === \"White\" ? 1 : 0;\r\n}\r\n\r\nfunction deserializeColor(n: number): Color {\r\n    return n === 1 ? \"White\" : \"Black\";\r\n}\r\n\r\n\r\nexport const spacePolice = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        let currentDirection = geometry.directions.up;\r\n        let currentPos = { x: 0, y: 0 };\r\n\r\n        const steps: Step[] = [];\r\n\r\n        const input = async () => {\r\n            const filtered = steps.filter((e) => e.coordinate.x === currentPos.x && e.coordinate.y === currentPos.y);\r\n            if (filtered.length === 0) {\r\n                return serializeColor(\"Black\");\r\n            }\r\n            return serializeColor(filtered[filtered.length - 1].color);\r\n        };\r\n\r\n        let isPaint = true;\r\n\r\n        const output = (n: number) => {\r\n            if (isPaint) {\r\n                steps.push({ coordinate: currentPos, color: deserializeColor(n) });\r\n                isPaint = false;\r\n            } else {\r\n                const rotation = deserializeRotation(n);\r\n                currentDirection = rotate(currentDirection, rotation);\r\n                currentPos = currentDirection.sum(currentPos);\r\n                isPaint = true;\r\n            }\r\n        };\r\n\r\n        const memory = parseMemory(lines[0]);\r\n\r\n        await execute({ memory, input, output, close: async () => await outputCallback(\"Closing down\") });\r\n\r\n        const sorted = steps\r\n            .map((e, i) => ({ e, i }))\r\n            .sort((a, b) => (stepComparer(a, b)) * -1).map((e) => e.e);\r\n        let last: Step | null = null;\r\n        const distinct: Step[] = [];\r\n        sorted.forEach((s) => {\r\n            if (last === null || geometry.ascendingCompare(last.coordinate, s.coordinate) !== 0) {\r\n                distinct.push(s);\r\n                last = s;\r\n            }\r\n        });\r\n\r\n        await outputCallback(\"How many: \" + distinct.length);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        let currentDirection = geometry.directions.up;\r\n        let currentPos = { x: 0, y: 0 };\r\n\r\n        const steps: Step[] = [{ color: \"White\", coordinate: currentPos }];\r\n\r\n        const input = async () => {\r\n            const filtered = steps.filter((e) => e.coordinate.x === currentPos.x && e.coordinate.y === currentPos.y);\r\n            if (filtered.length === 0) {\r\n                return serializeColor(\"Black\");\r\n            }\r\n            return serializeColor(filtered[filtered.length - 1].color);\r\n        };\r\n\r\n        let isPaint = true;\r\n\r\n        const output = (n: number) => {\r\n            if (isPaint) {\r\n                steps.push({ coordinate: currentPos, color: deserializeColor(n) });\r\n                isPaint = false;\r\n            } else {\r\n                const rotation = deserializeRotation(n);\r\n                currentDirection = rotate(currentDirection, rotation);\r\n                currentPos = currentDirection.sum(currentPos);\r\n                isPaint = true;\r\n            }\r\n        };\r\n\r\n        const memory = parseMemory(lines[0]);\r\n\r\n        await execute({ memory, input, output, close: async () => await outputCallback(\"Closing down\") });\r\n\r\n        const sorted = steps.map((e, i) => ({ e, i })).sort((a, b) => stepComparer(a, b) * -1).map((e) => e.e);\r\n        let last: Step | null = null;\r\n        const distinct: Step[] = [];\r\n        sorted.forEach((s) => {\r\n            if (last === null || geometry.ascendingCompare(last.coordinate, s.coordinate) !== 0) {\r\n                distinct.push(s);\r\n                last = s;\r\n            }\r\n        });\r\n\r\n        const boundaries = geometry.getBoundaries(sorted.map((s) => s.coordinate));\r\n        const grid = new FixedSizeMatrix<Cell>(boundaries.size);\r\n        for (let x = 0; x < grid.size.x; x++) {\r\n            for (let y = 0; y < grid.size.y; y++) {\r\n                grid.set({ x, y: grid.size.y - y }, \".\");\r\n            }\r\n        }\r\n        steps.forEach((s) => {\r\n            const c = geometry.diffCoordinate(s.coordinate, boundaries.topLeft);\r\n            grid.set(\r\n                { x: c.x, y: c.y },\r\n                s.color === \"Black\" ? \".\" : \"#\"\r\n            );\r\n        });\r\n        const outRows = wu(grid.overRows()).map((row) => row.reverse().join(\"\")).toArray();\r\n\r\n        for (const row of outRows) {\r\n            await outputCallback(row);\r\n        }\r\n\r\n    },\r\n    { key: \"space-police\", title: \"Space Police\", stars: 2, embeddedData: true}\r\n);\r\nfunction stepComparer(a: { e: Step; i: number; }, b: { e: Step; i: number; }) {\r\n    if (geometry.ascendingCompare(a.e.coordinate, b.e.coordinate) === 0) {\r\n        return ascending(a.i, b.i);\r\n    } else {\r\n        return geometry.ascendingCompare(a.e.coordinate, b.e.coordinate);\r\n    }\r\n}\r\n\r\n","import { entryForFile } from \"../../entry\";\r\n\r\ninterface Coordinate3D {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n}\r\n\r\ninterface Planet {\r\n    position: Coordinate3D;\r\n    velocity: Coordinate3D;\r\n}\r\n\r\nfunction addCoordinate(a: Coordinate3D, b: Coordinate3D): Coordinate3D {\r\n    return {\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n        z: a.z + b.z\r\n    };\r\n}\r\n\r\nfunction opposite(a: Coordinate3D): Coordinate3D {\r\n    return {\r\n        x: -a.x,\r\n        y: -a.y,\r\n        z: -a.z\r\n    };\r\n}\r\n\r\nconst emptyCoordinate = {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0\r\n};\r\n\r\nconst baseCoordinates = {\r\n    x: { ...emptyCoordinate, x: 1 },\r\n    y: { ...emptyCoordinate, y: 1 },\r\n    z: { ...emptyCoordinate, z: 1 }\r\n};\r\n\r\n\r\nfunction parsePlanets(lines: string[]): Planet[] {\r\n    const res = lines.map((line) => {\r\n        const coordinates = line\r\n            .trim()\r\n            .slice(1, line.length - 1)\r\n            .split(\",\")\r\n            .map((c) => c.trim().split(\"=\"))\r\n            .map((c) => ({\r\n                name: c[0],\r\n                value: parseInt(c[1], 10)\r\n            }));\r\n        const get = (s: string): number => coordinates.filter((e) => e.name === s)[0].value;\r\n        return {\r\n            position: {\r\n                x: get(\"x\"),\r\n                y: get(\"y\"),\r\n                z: get(\"z\")\r\n            },\r\n            velocity: {\r\n                x: 0,\r\n                y: 0,\r\n                z: 0\r\n            }\r\n        };\r\n    });\r\n    return res;\r\n}\r\n\r\nfunction updater(p: Planet, o: Planet, extractor: (p: Planet) => number, toUpdate: Coordinate3D) {\r\n    const pExtracted = extractor(p);\r\n    const oExtracted = extractor(o);\r\n    if (pExtracted < oExtracted) {\r\n        p.velocity = addCoordinate(p.velocity, toUpdate);\r\n    } else if (pExtracted > oExtracted) {\r\n        p.velocity = addCoordinate(p.velocity, opposite(toUpdate));\r\n    }\r\n}\r\n\r\ninterface UpdaterArgs {\r\n    positionExtractor: (p: Planet) => number;\r\n    velocityExtractor: (p: Planet) => number;\r\n    toUpdate: Coordinate3D;\r\n}\r\n\r\nconst baseUpdaters: UpdaterArgs[] = [\r\n    {\r\n        positionExtractor: (p) => p.position.x,\r\n        velocityExtractor: (p) => p.velocity.x,\r\n        toUpdate: baseCoordinates.x\r\n    },\r\n    {\r\n        positionExtractor: (p) => p.position.y,\r\n        velocityExtractor: (p) => p.velocity.y,\r\n        toUpdate: baseCoordinates.y\r\n    },\r\n    {\r\n        positionExtractor: (p) => p.position.z,\r\n        velocityExtractor: (p) => p.velocity.z,\r\n        toUpdate: baseCoordinates.z\r\n    },\r\n];\r\n\r\n\r\nfunction gravityStep(planets: Planet[], updaters: UpdaterArgs[] = baseUpdaters): Planet[] {\r\n    const outputPlanets = planets.map((p) => ({ ...p }));\r\n    outputPlanets.forEach((p, i) => {\r\n        planets.forEach((o, j) => {\r\n            if (i !== j) {\r\n                updaters.forEach((args) => updater(p, o, args.positionExtractor, args.toUpdate));\r\n                // updater(p, o, e => e.position.x, baseCoordinates.x);\r\n                // updater(p, o, e => e.position.y, baseCoordinates.y);\r\n                // updater(p, o, e => e.position.z, baseCoordinates.z);\r\n            }\r\n        });\r\n    });\r\n    outputPlanets.forEach((p) => p.position = addCoordinate(p.position, p.velocity));\r\n    return outputPlanets;\r\n}\r\n\r\nfunction getSum(c: Coordinate3D): number {\r\n    return Math.abs(c.x) + Math.abs(c.y) + Math.abs(c.z);\r\n}\r\n\r\nfunction getEnergy(planet: Planet) {\r\n    return getSum(planet.velocity) * getSum(planet.position);\r\n}\r\n\r\nfunction serializeCoordinates(c: Coordinate3D): string {\r\n    return `<x=${c.x}, y=${c.y}, z=${c.z}>`;\r\n}\r\n\r\nfunction serializePlanet(planet: Planet): string {\r\n    return `pos=${serializeCoordinates(planet.position)}, vel=${serializeCoordinates(planet.velocity)}`;\r\n}\r\n\r\nfunction serializeTuple(coordinates: number[]): string {\r\n    return coordinates.join(\"|\");\r\n}\r\n\r\nfunction gcd(a: number, b: number): number {\r\n  let t = 0;\r\n  if (a < b) {\r\n      t = b;\r\n      b = a;\r\n      a = t;\r\n  }\r\n//   a < b && (t = b, b = a, a = t); // swap them if a < b\r\n  t = a % b;\r\n  return t ? gcd(b, t) : b;\r\n}\r\n\r\nfunction lcm(a: number, b: number) {\r\n  return a / gcd(a, b) * b;\r\n}\r\n\r\nconst getLcm = lcm;\r\n\r\n// function getLcm(a: number, b: number): number {\r\n//     return mathjs.lcm(a, b);\r\n// }\r\n\r\nexport const nBodyProblem = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        let planets = parsePlanets(lines);\r\n        const steps = 1000;\r\n        for (let i = 0; i < steps; i++) {\r\n            planets = gravityStep(planets);\r\n        }\r\n        await outputCallback(planets.map(serializePlanet));\r\n        await outputCallback(\" \");\r\n        await outputCallback(`Energy after ${steps} steps`);\r\n        await outputCallback(planets.map(getEnergy));\r\n        await outputCallback(`Total: `);\r\n        await outputCallback(planets.map(getEnergy).reduce((a, b) => a + b));\r\n\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const updaters = baseUpdaters;\r\n        const planets = parsePlanets(lines);\r\n        const repetitions = updaters.map((u) => {\r\n            let step = 0;\r\n            const values = new Set<string>();\r\n            let currentPlanets = planets;\r\n            while (true) {\r\n                const key = serializeTuple(\r\n                    currentPlanets\r\n                        .map(u.positionExtractor)\r\n                        .concat(currentPlanets.map(u.velocityExtractor))\r\n                );\r\n                if (values.has(key)) {\r\n                    break;\r\n                }\r\n                values.add(key);\r\n                step++;\r\n                currentPlanets = gravityStep(currentPlanets);\r\n            }\r\n            return step;\r\n        });\r\n        const lcmRepetition = repetitions.reduce((a, b) => getLcm(a, b));\r\n\r\n        await outputCallback(\"Starting positions: \");\r\n        await outputCallback(planets.map(serializePlanet));\r\n\r\n        await outputCallback(lcmRepetition);\r\n    },\r\n    { key: \"n-body-problem\", title: \"N-Body Problem\", stars: 2, embeddedData: \"n-body-problem/n-body-problem\"}\r\n);\r\n","import { Drawable, entryForFile, ScreenPrinter } from \"../../entry\";\r\nimport { parseMemory, execute } from \"../../../support/intcode\";\r\nimport { groupBy } from \"../../../support/sequences\";\r\nimport { Coordinate, getBoundaries, diffCoordinate, sumCoordinate, scalarCoordinates, serialization } from \"../../../support/geometry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport wu from \"wu\";\r\n\r\ntype Tile = \"empty\" | \"wall\" | \"block\" | \"paddle\" | \"ball\";\r\n\r\nconst tileList: Tile[] = [\"empty\", \"wall\", \"block\", \"paddle\", \"ball\"];\r\n\r\ninterface Cell {\r\n    tile: Tile;\r\n    coordinates: Coordinate;\r\n}\r\n\r\nfunction tileSerializer(t: Tile): number {\r\n    return tileList.indexOf(t);\r\n}\r\n\r\nfunction tileDeserializer(n: number): Tile {\r\n    return tileList[n];\r\n}\r\n\r\nfunction parseGroup(e: number[]): Cell {\r\n    return {\r\n        tile: tileDeserializer(e[2]),\r\n        coordinates: {\r\n            x: e[0],\r\n            y: e[1]\r\n        }\r\n    };\r\n}\r\n\r\nfunction tileVisualize(t: Tile): string {\r\n    switch (t) {\r\n        case \"ball\":\r\n            return \"o\";\r\n        case \"block\":\r\n            return \"*\";\r\n        case \"empty\":\r\n            return \" \";\r\n        case \"paddle\":\r\n            return \"-\";\r\n        case \"wall\":\r\n            return \"#\";\r\n    }\r\n}\r\n\r\nfunction tileColor(t: Tile): string {\r\n    switch (t) {\r\n        case \"ball\":\r\n            return \"white\";\r\n        case \"block\":\r\n            return \"black\";\r\n        case \"empty\":\r\n            return \"transparent\";\r\n        case \"paddle\":\r\n            return \"yellow\";\r\n        case \"wall\":\r\n            return \"white\";\r\n    }\r\n}\r\n\r\nexport const carePackage = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled, screen, setAutoStop }) => {\r\n        setAutoStop();\r\n        const memory = parseMemory(lines[0]);\r\n        const output: number[] = [];\r\n        await execute({ memory, input: async () => { throw new Error(\"No input\"); }, output: (e) => output.push(e) });\r\n\r\n        const tiles = parseTiels(output);\r\n        const blocks = tiles.filter((e) => e.tile === \"block\");\r\n\r\n        if (screen) {\r\n            const printer = await screen.requireScreen({x: 300, y: 300});\r\n            const visualization = screenMapTiles(tiles, {x: 300, y: 300});\r\n            printer.replace(visualization);\r\n        } else {\r\n            const visualization = visualizeTiles(tiles);\r\n            await outputCallback(visualization);\r\n        }\r\n\r\n        await outputCallback(\"Blocks: \");\r\n        await outputCallback(blocks.length);\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled, screen, setAutoStop }) => {\r\n        setAutoStop();\r\n        const memory = parseMemory(lines[0]);\r\n        memory[0] = 2;\r\n        let currentPaddleX = 0;\r\n        let currentBallX = 0;\r\n        let output: number[] = [];\r\n        const tiles: Cell[] = [];\r\n        let score: number = 0;\r\n        let printer: ScreenPrinter | undefined;\r\n        if (screen) {\r\n            printer = await screen.requireScreen({x: 300, y: 300});\r\n        }\r\n        await execute({\r\n            memory, input: async () => {\r\n                if (tiles.length > 0) {\r\n                    ({ currentPaddleX, currentBallX } =\r\n                        await updateTileFeedback(\r\n                            tiles, currentPaddleX, currentBallX, score, outputCallback, pause, printer\r\n                        )\r\n\r\n                    );\r\n                }\r\n                const res = Math.sign(currentBallX - currentPaddleX);\r\n                return res;\r\n            }, output: async (e) => {\r\n                output.push(e);\r\n                if (output.length === 3) {\r\n                    if (output[0] === -1 && output[1] === 0) { // is score\r\n                        score = output[2];\r\n                        if (tiles.length > 0) {\r\n                            ({ currentPaddleX, currentBallX } =\r\n                                await updateTileFeedback(\r\n                                    tiles, currentPaddleX, currentBallX, score, outputCallback, pause, printer\r\n                                )\r\n                            );\r\n                        }\r\n                    } else { // is tile\r\n                        const tile = parseGroup(output);\r\n                        const matching =\r\n                            tiles.filter((t) =>\r\n                                t.coordinates.x === tile.coordinates.x &&\r\n                                t.coordinates.y === tile.coordinates.y\r\n                            );\r\n                        if (matching.length > 0) {\r\n                            matching[0].tile = tile.tile;\r\n                        } else {\r\n                            tiles.push(tile);\r\n                        }\r\n                    }\r\n                    output = [];\r\n                }\r\n            }\r\n        });\r\n        await outputCallback(score);\r\n    },\r\n    {\r\n        key: \"care-package\",\r\n        title: \"Care Package\",\r\n        stars: 2,\r\n        embeddedData: true,\r\n        customComponent: \"pause-and-run\"\r\n    }\r\n);\r\n\r\nasync function updateTileFeedback(\r\n    tiles: Cell[],\r\n    currentPaddleX: number,\r\n    currentBallX: number,\r\n    score: number,\r\n    outputCallback: (outputLine: any, shouldClear?: boolean | undefined) => Promise<void>,\r\n    pause: () => Promise<void>,\r\n    screen?: ScreenPrinter\r\n) {\r\n    currentPaddleX = tiles.filter((t) => t.tile === \"paddle\")[0].coordinates.x;\r\n    currentBallX = tiles.filter((t) => t.tile === \"ball\")[0].coordinates.x;\r\n    await outputCallback(null);\r\n    if (screen) {\r\n        await screen.replace(screenMapTiles(tiles, {x: 300, y: 300}));\r\n        await outputCallback(`Score: ${score}`);\r\n    } else {\r\n        const visualization = visualizeTiles(tiles) + `\\n\\nScore: ${score}`;\r\n        await outputCallback(visualization);\r\n    }\r\n    await pause();\r\n    return { currentPaddleX, currentBallX };\r\n}\r\n\r\nfunction visualizeTiles(tiles: Cell[]) {\r\n    const boundaries = getBoundaries(tiles.map((t) => t.coordinates));\r\n    const grid = new FixedSizeMatrix<string>(sumCoordinate(boundaries.size, boundaries.topLeft));\r\n    tiles.forEach((t) => grid.set(t.coordinates, tileVisualize(t.tile)));\r\n    const visualization = wu(grid.overRows()).map((row) => row.join(\"\")).toArray().join(\"\\n\");\r\n    return visualization;\r\n}\r\n\r\nfunction screenMapTiles(tiles: Cell[], size: Coordinate): Drawable[] {\r\n    const boundaries = getBoundaries(tiles.map((t) => t.coordinates));\r\n    const sizes = {x: Math.floor(size.x / boundaries.size.x), y: Math.floor(size.y / boundaries.size.y)};\r\n    const squareSize = Math.min(sizes.x, sizes.y);\r\n    if (squareSize === 0) {\r\n        return [];\r\n    }\r\n\r\n    return tiles.map((tile) => {\r\n        let coordinates = {x: tile.coordinates.x * squareSize, y: tile.coordinates.y * squareSize};\r\n        let padding: number = 0;\r\n        if (squareSize >= 6) {\r\n            const maxPadding = Math.floor(squareSize / 4);\r\n            padding = Math.min(maxPadding, 4);\r\n        }\r\n        coordinates = sumCoordinate(coordinates, {x: padding, y: padding});\r\n        const drawableSize = {x: squareSize - 2 * padding, y: squareSize - 2 * padding};\r\n        return {\r\n            id: serialization.serialize(tile.coordinates),\r\n            color: tileColor(tile.tile),\r\n            type: \"rectangle\",\r\n            c: coordinates,\r\n            size: drawableSize\r\n        } as Drawable;\r\n    });\r\n}\r\n\r\nfunction parseTiels(output: number[]) {\r\n    return groupBy(output, 3).map(parseGroup);\r\n}\r\n","import { entryForFile } from \"../../entry\";\nimport { setTimeoutAsync, mapAsync } from \"../../../support/async\";\n\ninterface Element {\n    name: string;\n    amount: number;\n}\n\ninterface Chain {\n    target: Element;\n    needs: Element[];\n}\n\nfunction serializeElement(e: Element): string {\n    return `${e.amount} ${e.name}`;\n}\n\nfunction serializeChain(c: Chain): string {\n    return `${c.needs.map(serializeElement).join(\", \")} => ${serializeElement(c.target)}`;\n}\n\nfunction serializeChains(c: Chain[]): string {\n    return c.map(serializeChain).join(\"\\n\");\n}\n\nfunction parseElement(raw: string): Element {\n    const [amount, name] = raw.trim().split(\" \");\n    return { amount: parseInt(amount, 10), name };\n}\n\nfunction parseLine(line: string): Chain {\n    const [left, right] = line.split(\"=>\").map((e) => e.trim());\n\n    const needs = left.split(\",\").map((e) => e.trim()).map(parseElement);\n    const target = parseElement(right);\n    return { needs, target };\n}\n\nfunction parseLines(lines: string[]): Chain[] {\n    return lines.filter((l) => !l.startsWith(\"--\")).map((l) => l.trim()).filter((l) => l.length > 0).map(parseLine);\n}\n\nconst targetName = \"FUEL\";\nconst baseName = \"ORE\";\n\ninterface OrePrice {\n    toCreate: number;\n    youNeed: number;\n}\n\ninterface CalculatedPrices { [key: string]: OrePrice; }\n\nclass Remaining {\n    private readonly remainingMap: { [key: string]: number } = {};\n\n    public add(e: Element) {\n        this.ensure(e.name);\n        this.remainingMap[e.name] += e.amount;\n    }\n\n    public askFor(e: Element): number {\n        this.ensure(e.name);\n        const howManyCanTake = Math.min(this.remainingMap[e.name], e.amount);\n        this.remainingMap[e.name] -= howManyCanTake;\n        return howManyCanTake;\n    }\n\n    private ensure(k: string) {\n        if (!this.remainingMap[k]) {\n            this.remainingMap[k] = 0;\n        }\n    }\n}\n\nlet i = 0;\n\nasync function oreRequirement(target: Element, c: Chain[], r: Remaining, d?: Debug): Promise<OrePrice> {\n    i++;\n    const closed = i;\n    const log = async (s: any) => {\n        const intLog = (d && d.log) || (async () => { });\n        if (closed === 1) {\n            await intLog(\"ID: \" + closed);\n            await intLog(s);\n        }\n    };\n    await log(\"Trying to build:\");\n    await log(target);\n    if (target.name === baseName) {\n        await log(\"Trying to build ore, done with requirements:\");\n        const res = { toCreate: target.amount, youNeed: target.amount };\n        await log(res);\n        return res;\n    }\n    await log(\"Trying with remainings\");\n    await log((r as any)._remainingMap);\n    const howManyRequired = target.amount - r.askFor(target);\n    if (howManyRequired === 0) {\n        await log(\"Everything found in remaining\");\n        return {\n            toCreate: target.amount,\n            youNeed: 0\n        };\n    }\n    await log(\"Only some found in remaining, new required:\");\n    await log(howManyRequired);\n    await log(\"New remaining:\");\n    await log((r as any)._remainingMap);\n    const chain = c.filter((e) => e.target.name === target.name)[0];\n    const howManyNeedToBuild = Math.ceil(howManyRequired / chain.target.amount);\n    await log(\n        `Recipe says how to build ${chain.target.amount}, need ${howManyRequired}, building ${howManyNeedToBuild}`\n    );\n    const needs = chain.needs.map((n) => ({ name: n.name, amount: n.amount * howManyNeedToBuild }));\n    await log(`New needs:`);\n    await log(JSON.stringify(needs));\n    const prices = await mapAsync(needs, async (n) => ({ price: await oreRequirement(n, c, r, d), element: n }));\n    // prices.forEach((p) => {\n    //     if (p.price.toCreate > p.element.amount) {\n    //         r.add({ name: p.element.name, amount: p.price.toCreate - p.element.amount });\n    //     }\n    // });\n    r.add({ name: target.name, amount: howManyNeedToBuild * chain.target.amount - howManyRequired });\n    await log(\"Updated remaining:\");\n    await log((r as any)._remainingMap);\n    const finalResult = {\n        toCreate: target.amount,\n        youNeed: prices.map((p) => p.price.youNeed).reduce((a, b) => a + b)\n    };\n    await log(\"Final result:\");\n    await log(finalResult);\n    return finalResult;\n}\n\n\ninterface Debug {\n    pause?: () => Promise<void>;\n    log?: (s: any) => Promise<void>;\n}\n\nexport const spaceStoichiometry = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const chains = parseLines(lines);\n        await outputCallback(serializeChains(chains));\n        // const amount = await getPrice(targetName, chains, { log: outputCallback, pause: pause });\n        const remain = new Remaining();\n        const amount = await oreRequirement(\n            chains.filter((e) => e.target.name === targetName)[0].target,\n            chains,\n            remain\n        );\n        await outputCallback(amount);\n        await outputCallback(\"Remaining:\");\n        await outputCallback((remain as any)._remainingMap);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const chains = parseLines(lines);\n        let current: number = 0;\n        let targetAmount = 1;\n        const storageOres = 1000000000000;\n        const target = chains.filter((e) => e.target.name === targetName)[0].target;\n        while (current < storageOres) {\n            targetAmount *= 2;\n            const newTarget = { ...target, amount: targetAmount };\n            current = (await oreRequirement(newTarget, chains, new Remaining())).youNeed;\n            await outputCallback(\"Current guess:\");\n            await outputCallback({ targetAmount, current });\n        }\n        let under = Math.floor(targetAmount / 2);\n        let over = targetAmount;\n        let guess = Math.floor((under + over) / 2);\n        while (under < over) {\n            // target.amount = guess;\n            const newTarget = { ...target, amount: guess };\n            const needed = (await oreRequirement(newTarget, chains, new Remaining())).youNeed;\n            if (needed === storageOres) {\n                break;\n            } else if (needed > storageOres) {\n                over = guess;\n            } else if (needed < storageOres) {\n                under = guess;\n            }\n            guess = Math.floor((under + over) / 2);\n            await outputCallback(\"New status:\");\n            await outputCallback({ under, over, guess });\n            if (guess === under) {\n                break;\n            }\n        }\n        await outputCallback(\"You can create \" + guess);\n        // const amount = await oreRequirement(target, chains, remain);\n        // await outputCallback(amount);\n        // await outputCallback(\"Remaining:\");\n        // await outputCallback((remain as any)._remainingMap);\n    },\n    { key: \"space-stoichiometry\", title: \"Space Stoichiometry\", stars: 2, embeddedData: \"space-stoichiometry/input\"}\n);\n","import { entryForFile } from \"../../entry\";\nimport {\n    Coordinate,\n    getBoundaries,\n    diffCoordinate,\n    manhattanDistance,\n    getSurrounding\n} from \"../../../support/geometry\";\nimport { parseMemory, execute, stopExecution } from \"../../../support/intcode\";\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\nimport { Queue } from \"../../../support/data-structure\";\nimport { List } from \"linq-typescript\";\ntype Tile = \"#\" | \".\";\n\ninterface Cell {\n    coordinate: Coordinate;\n    tile: Tile;\n}\n\ninterface CellWithDistance extends Cell {\n    distance: number | null;\n}\n\nexport const commands = {\n    up: 1,\n    down: 2,\n    left: 3,\n    right: 4\n};\n\n\ninterface Dictionary<T> { [key: string]: T; }\n\ntype CellMap = Dictionary<Cell>;\n\nexport function getCandidates(\n    distances: Dictionary<CellWithDistance>,\n    cellGetter: (c: Coordinate) => Cell | undefined\n): CellWithDistance[] {\n    const candidates = Object.values(distances)\n        .filter((e) => e.tile === \".\")\n        .filter((e) => e.distance !== null)\n        .filter((candidate) => {\n            const target = getEmptySurrounded(candidate, cellGetter);\n            return target !== null && target !== undefined;\n        })\n        .sort((a, b) => a.distance! - b.distance!);\n    return candidates;\n}\n\nexport class Field {\n\n    public static fromSerialization(serialization: string): Field {\n        const lines = serialization.trim().split(\"\\n\");\n        const matrix = lines.map((l) => l.trim().split(\"\"));\n        const cells: Cell[] = matrix.flatMap((line, lineIndex) => line.map((cell, cellIndex) => {\n            if (cell === \".\" || cell === \"#\") {\n                return {\n                    coordinate: {\n                        x: cellIndex,\n                        y: lineIndex\n                    },\n                    tile: cell\n                } as Cell;\n            } else {\n                return null;\n            }\n        })).filter((c) => c).map((c) => c!);\n        return new Field(cells);\n\n    }\n    private cells: CellMap = {};\n\n    constructor(startingCells: Cell[]) {\n        startingCells.forEach((c) => this.setCell(c));\n    }\n\n    public setCell(c: Cell) {\n        this.cells[coordinateToKey(c.coordinate)] = c;\n    }\n\n    public getCell(c: Coordinate): Cell | undefined {\n        return this.cells[coordinateToKey(c)];\n    }\n\n    public findCommandsToNearestUnkown(c: Coordinate): Array<[number, Coordinate]> {\n        const distances = this.getDistances(c);\n        const nearest = this.findNearestToDiscover(c, distances);\n        if (nearest === null) {\n            return [];\n        }\n        return this.findCommandsForUnkown({ ...nearest, from: c, distances });\n    }\n\n    public findNearestToDiscover(\n        c: Coordinate,\n        distances: Dictionary<CellWithDistance>\n    ): { lastKnown: CellWithDistance, unknown: Coordinate } | null {\n        const candidates = getCandidates(distances, this.getCell.bind(this));\n        if (candidates.length === 0) {\n            return null;\n        }\n        const candidate = candidates[0];\n        const target = getEmptySurrounded(candidate, this.getCell.bind(this));\n        if (!target) {\n            throw new Error(\"This should not happen, target was already ensured\");\n        }\n        return { lastKnown: candidate, unknown: target.coordinate };\n    }\n\n    public findCommandsForUnkown(\n        { from, lastKnown, unknown, distances }: {\n            from: Coordinate,\n            lastKnown: CellWithDistance,\n            unknown: Coordinate,\n            distances: Dictionary<CellWithDistance>\n        }\n    ): Array<[number, Coordinate]> {\n        let currentCell = lastKnown;\n        const localCommands: Array<[number, Coordinate]> =\n            [[this.getCommand(currentCell.coordinate, unknown), unknown]];\n        while (manhattanDistance(currentCell.coordinate, from) !== 0) {\n            const canGo = new List(\n                getSurrounding(currentCell.coordinate)\n                    .map((l) => distances[coordinateToKey(l)])\n            )\n                .where((c) => c !== undefined && c.distance !== null)\n                .where((c) => c.distance === currentCell.distance! - 1)\n                .firstOrDefault();\n            if (canGo === undefined) {\n                return [];\n            }\n            localCommands.push([this.getCommand(canGo.coordinate, currentCell.coordinate), currentCell.coordinate]);\n            currentCell = canGo;\n        }\n        return localCommands.reverse();\n    }\n\n    public getDistances(coordinate: Coordinate): Dictionary<CellWithDistance> {\n        const cellMap: { [key: string]: CellWithDistance } = {};\n        Object.values(this.cells)\n            .filter((c) => c.tile === \".\")\n            .forEach((c) => cellMap[coordinateToKey(c.coordinate)] = {\n                ...c,\n                distance: null\n            });\n        const startingCell = cellMap[coordinateToKey(coordinate)];\n        if (!startingCell) {\n            return cellMap;\n        }\n        startingCell.distance = 0;\n        const visitingQueue = new Queue<CellWithDistance>();\n        visitingQueue.add(startingCell);\n        while (!visitingQueue.isEmpty) {\n            const toVisit = visitingQueue.get();\n            if (toVisit === null) {\n                break;\n            }\n            const next = getSurrounding(toVisit.coordinate).map((c) => cellMap[coordinateToKey(c)]);\n            next.forEach((cell) => {\n                if (cell && cell.distance === null && cell.tile === \".\") {\n                    cell.distance = toVisit.distance! + 1;\n                    visitingQueue.add(cell);\n                }\n            });\n        }\n        return cellMap;\n    }\n\n    public getCommand(from: Coordinate, to: Coordinate): number {\n        if (manhattanDistance(from, to) !== 1) {\n            throw new RangeError(\"Cannot move to distant cell\");\n        }\n        if (from.x > to.x) {\n            return commands.left;\n        } else if (from.x < to.x) {\n            return commands.right;\n        } else if (from.y > to.y) {\n            return commands.up;\n        } else if (from.y < to.y) {\n            return commands.down;\n        } else {\n            throw new Error(\"Something went wrong :(\");\n        }\n    }\n\n    public toString() {\n        const boundaries = getBoundaries(Object.values(this.cells).map((c) => c.coordinate));\n        const matrix = new FixedSizeMatrix<string>(boundaries.size);\n        matrix.fill(undefined);\n        Object.values(this.cells).forEach((c) => matrix.set(diffCoordinate(c.coordinate, boundaries.topLeft), c.tile));\n        return matrix.toString((e) => e ? e : \" \");\n    }\n\n    public getDistance(from: Coordinate, to: Coordinate): number | null {\n        const distances = this.getDistances(from);\n        const distance = distances[coordinateToKey(to)];\n        if (!distance || !distance.distance) {\n            return null;\n        } else {\n            return distance.distance!;\n        }\n    }\n\n    private canMove(from: Coordinate, to: Coordinate): boolean {\n        const fromCell = this.getCell(from);\n        const toCell = this.getCell(to);\n        if (!fromCell || !toCell) {\n            return false;\n        }\n        if (fromCell.tile !== \".\" || toCell.tile !== \".\") {\n            return false;\n        }\n        const distance = manhattanDistance(fromCell.coordinate, toCell.coordinate);\n        if (distance !== 1) {\n            return false;\n        }\n        return true;\n    }\n\n}\n\nfunction getEmptySurrounded(candidate: CellWithDistance, cellGetter: (c: Coordinate) => Cell | undefined) {\n    const surrounding = new List(\n        getSurrounding(candidate.coordinate)\n            .map((c) => ({ coordinate: c, cell: cellGetter(c) }))\n    );\n    const target = surrounding.where((s) => !s.cell).firstOrDefault();\n    return target;\n}\n\nexport function coordinateToKey(c: Coordinate): string {\n    return `${c.x}|${c.y}`;\n}\n\nexport function keyToCoordinate(s: string): Coordinate {\n    const [x, y] = s.split(\"|\");\n    return {\n        x: parseInt(x, 10),\n        y: parseInt(y, 10)\n    };\n}\n\nexport const oxygenSystem = entryForFile(\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const cells: Cell[] = [{\n            coordinate: { x: 0, y: 0 },\n            tile: \".\"\n        }];\n\n        const field = new Field(cells);\n        let currentPosition: Coordinate = { x: 0, y: 0 };\n        let movingTo: Coordinate | null = currentPosition;\n        let suggestedCommands: Array<[number, Coordinate]> = [];\n        const program = parseMemory(lines[0]);\n        let oxygenPosition: Coordinate | null = null;\n        let currentIteration = 0;\n        await execute({\n            memory: program, input: async () => {\n                await pause();\n                let answer: number = -1;\n                if (suggestedCommands.length > 0) {\n                    const [command, position] = suggestedCommands.pop()!;\n                    movingTo = position;\n                    answer = command;\n                } else {\n                    const suggestion = field.findCommandsToNearestUnkown(currentPosition);\n                    if (!suggestion || suggestion.length === 0) {\n                        stopExecution();\n                    } else {\n                        suggestedCommands = suggestion.reverse();\n                    }\n                    const [command, position] = suggestedCommands.pop()!;\n                    movingTo = position;\n                    answer = command;\n                }\n                return answer;\n            },\n            output: async (n) => {\n                switch (n) {\n                    case 0:\n                        field.setCell({ coordinate: movingTo!, tile: \"#\" });\n                        movingTo = null;\n                        break;\n                    case 1:\n                        currentPosition = movingTo!;\n                        field.setCell({ coordinate: movingTo!, tile: \".\" });\n                        movingTo = null;\n                        break;\n                    case 2:\n                        currentPosition = movingTo!;\n                        field.setCell({ coordinate: currentPosition, tile: \".\" });\n                        movingTo = null;\n                        oxygenPosition = currentPosition;\n                        break;\n                }\n                if (currentIteration++ % 100 === 0) {\n                    await outputCallback(field.toString(), true);\n                }\n            }\n        });\n\n        await outputCallback(field.toString());\n\n        const distance = field.getDistance({ x: 0, y: 0 }, oxygenPosition!);\n        await outputCallback(distance);\n    },\n    async ({ lines, outputCallback, pause, isCancelled }) => {\n        const cells: Cell[] = [{\n            coordinate: { x: 0, y: 0 },\n            tile: \".\"\n        }];\n\n        const field = new Field(cells);\n        let currentPosition: Coordinate = { x: 0, y: 0 };\n        let movingTo: Coordinate | null = currentPosition;\n        let suggestedCommands: Array<[number, Coordinate]> = [];\n        const program = parseMemory(lines[0]);\n        let oxygenPosition: Coordinate | null = null;\n        await execute({\n            memory: program, input: async () => {\n                await pause();\n                let answer: number = -1;\n                if (suggestedCommands.length > 0) {\n                    const [command, position] = suggestedCommands.pop()!;\n                    movingTo = position;\n                    answer = command;\n                } else {\n                    const suggestion = field.findCommandsToNearestUnkown(currentPosition);\n                    if (!suggestion || suggestion.length === 0) {\n                        stopExecution();\n                    } else {\n                        suggestedCommands = suggestion.reverse();\n                    }\n                    const [command, position] = suggestedCommands.pop()!;\n                    movingTo = position;\n                    answer = command;\n                }\n                return answer;\n            },\n            output: async (n) => {\n                switch (n) {\n                    case 0:\n                        field.setCell({ coordinate: movingTo!, tile: \"#\" });\n                        movingTo = null;\n                        break;\n                    case 1:\n                        currentPosition = movingTo!;\n                        field.setCell({ coordinate: movingTo!, tile: \".\" });\n                        movingTo = null;\n                        break;\n                    case 2:\n                        currentPosition = movingTo!;\n                        field.setCell({ coordinate: currentPosition, tile: \".\" });\n                        movingTo = null;\n                        oxygenPosition = currentPosition;\n                        break;\n                }\n            }\n        });\n\n        await outputCallback(field.toString());\n\n        const distance = field.getDistance({ x: 0, y: 0 }, oxygenPosition!);\n        const distances = Object.values(field.getDistances(oxygenPosition!));\n        await outputCallback(\n            distances\n                .filter((d) => d !== null)\n                .map((d) => d.distance!)\n                .reduce((a, b) => Math.max(a, b))\n        );\n    },\n    { key: \"oxygen-system\", title: \"Oxygen System\", stars: 2, embeddedData: true, suggestedDelay: 0}\n);\n","import { entryForFile } from \"../../entry\";\r\nimport { List } from \"linq-typescript\";\r\nimport wu from \"wu\";\r\nimport { serializeTime } from \"../../../support/time\";\r\n\r\nconst basePattern = [0, 1, 0, -1];\r\n\r\nexport function applyPattern(elements: number[], pattern: Pattern) {\r\n    return elements.map((_, position) =>\r\n        Math.abs(\r\n            elements\r\n                .map((element, index) => ({ element, index }))\r\n                .reduce((acc, next) => (acc + next.element * pattern.get(next.index, position)), 0)\r\n            % 10)\r\n    );\r\n}\r\n\r\nexport async function applyPatternIteratively(\r\n    elements: number[],\r\n    pattern: Pattern,\r\n    howManyTimes: number,\r\n    debug?: (n: number) => Promise<void>\r\n) {\r\n    let current = 0;\r\n    while (current++ < howManyTimes) {\r\n        elements = applyPattern(elements, pattern);\r\n        if (debug) {\r\n            await debug(current);\r\n        }\r\n    }\r\n    return elements;\r\n}\r\n\r\nexport class Pattern {\r\n\r\n    public get length() {\r\n        return this.localBasePattern.length;\r\n    }\r\n\r\n    public static default(): Pattern {\r\n        return new Pattern(basePattern);\r\n    }\r\n\r\n    public delta: number = 1;\r\n    constructor(private localBasePattern: number[]) {\r\n\r\n    }\r\n\r\n    public get(index: number, position: number): number {\r\n        const factor = position + 1;\r\n        const realIndex = Math.floor((index + this.delta) / factor);\r\n        return this.localBasePattern[realIndex % basePattern.length];\r\n    }\r\n}\r\n\r\nfunction parseLines(lines: string[]): number[] {\r\n    return lines[0].split(\"\").map((l) => parseInt(l, 10));\r\n}\r\n\r\n\r\n\r\nexport const flawedFrequencyTransmission = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const input = parseLines(lines);\r\n        const result = await applyPatternIteratively(input, Pattern.default(), 100);\r\n        await outputCallback(new List(result).take(8).toArray().join(\"\"));\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const input = parseLines(lines);\r\n        const repeatedInput = Array.from({ length: 10000 }, () => input).flat();\r\n        const interestingDigits = parseInt(input.slice(0, 7).join(\"\"), 10);\r\n        let iterationTime: number | null = null;\r\n        for (let iteration = 0; iteration < 100; iteration++) {\r\n            const startIterationTime = new Date().getTime();\r\n            for (let d = repeatedInput.length - 1; d >= interestingDigits; d--) {\r\n                let s = repeatedInput[d];\r\n                if (d + 1 < repeatedInput.length) {\r\n                    s += repeatedInput[d + 1];\r\n                }\r\n                repeatedInput[d] = s;\r\n            }\r\n            for (let d = interestingDigits; d < repeatedInput.length; d++) {\r\n                repeatedInput[d] = Math.abs(repeatedInput[d]) % 10;\r\n            }\r\n            iterationTime = new Date().getTime() - startIterationTime;\r\n            await outputCallback(\"Done iteration \" + iteration);\r\n        }\r\n        await outputCallback(repeatedInput.slice(interestingDigits, interestingDigits + 8).join(\"\"));\r\n    },\r\n    { key: \"flawed-frequency-transmission\", title: \"Flawed Frequency Transmission\", stars: 2, embeddedData: true}\r\n);\r\n","import { entryForFile, simpleOutputCallbackFactory } from \"../../entry\";\r\nimport { parseMemory, execute } from \"../../../support/intcode\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { getSurrounding, Coordinate, CCoordinate, directions, rotate } from \"../../../support/geometry\";\r\nimport { groupBy, subsequenceGenerator } from \"../../../support/sequences\";\r\n\r\nexport type Movement = \"R\" | \"L\" | number | \"A\" | \"B\" | \"C\";\r\n\r\ninterface RobotContext {\r\n    position: Coordinate;\r\n    direction: CCoordinate;\r\n}\r\n\r\nfunction getRobotDirection(s: string): CCoordinate | null {\r\n    switch (s) {\r\n        case \"^\":\r\n            return directions.up;\r\n        case \"<\":\r\n            return directions.left;\r\n        case \"v\":\r\n            return directions.down;\r\n        case \">\":\r\n            return directions.right;\r\n        default:\r\n            return null;\r\n    }\r\n}\r\n\r\nexport class Field {\r\n\r\n    public get width() {\r\n        return this.matrix.size.x;\r\n    }\r\n\r\n    public get height() {\r\n        return this.matrix.size.y;\r\n    }\r\n\r\n    public static fromBuffer(buffer: string[]): Field {\r\n        const fieldLines = buffer.join(\"\").split(\"\\n\").filter((e) => e.length > 0);\r\n        return new Field(fieldLines);\r\n    }\r\n    private readonly matrix: FixedSizeMatrix<string>;\r\n    constructor(rows: string[]) {\r\n        const width = rows[0].length;\r\n        const height = rows.length;\r\n        this.matrix = new FixedSizeMatrix<string>({ x: width, y: height });\r\n        const flatData = rows.join(\"\").split(\"\");\r\n        this.matrix.setFlatData(flatData);\r\n    }\r\n\r\n    public onEveryCell<T>(callback: (c: Coordinate, e: string) => Promise<T | undefined>): Promise<T | undefined> {\r\n        return this.matrix.onEveryCell(async (c, e) => await callback(c, e!));\r\n    }\r\n\r\n    public get(c: Coordinate): string {\r\n        return this.matrix.get(c)!;\r\n    }\r\n\r\n    public async getIntersections() {\r\n        const intersections: Coordinate[] = [];\r\n        await this.onEveryCell(async ({ x, y }, cell) => {\r\n            if (cell && cell === \"#\") {\r\n                const isIntersection = this.isIntersection({ x, y });\r\n                if (isIntersection) {\r\n                    intersections.push({ x, y });\r\n                }\r\n            }\r\n        });\r\n        return intersections;\r\n    }\r\n\r\n    public async getAlignment(): Promise<number> {\r\n        const intersections: Coordinate[] = await this.getIntersections();\r\n        const alignment = intersections.reduce((acc, next) => acc + next.x * next.y, 0);\r\n        return alignment;\r\n    }\r\n\r\n    public async getMovements(shouldDebug?: boolean): Promise<Movement[]> {\r\n        let currentPosition: RobotContext | undefined = await this.onEveryCell(async (c, cell) => {\r\n            if (cell) {\r\n                const direction = getRobotDirection(cell);\r\n                if (direction !== null) {\r\n                    return { position: c, direction };\r\n                }\r\n            }\r\n        });\r\n        if (!currentPosition) {\r\n            throw new Error(\"Could not find the robot\");\r\n        }\r\n        this.matrix.set(currentPosition.position, \"#\");\r\n        const movements: Movement[] = [];\r\n        let currentSteps = 0;\r\n        let shouldClear = true;\r\n        while (true) {\r\n            const forward = this.moveForward(currentPosition);\r\n            if (forward !== null) {\r\n                currentSteps++;\r\n                const isNextIntersection = this.isIntersection(forward.position);\r\n                if (shouldClear) {\r\n                    this.matrix.set(currentPosition.position, \".\");\r\n                }\r\n                shouldClear = !isNextIntersection;\r\n                currentPosition = forward;\r\n                continue;\r\n            }\r\n            if (currentSteps > 0) {\r\n                movements.push(currentSteps);\r\n                currentSteps = 0;\r\n            }\r\n            const right = this.tryRight(currentPosition);\r\n            if (right !== null) {\r\n                movements.push(\"R\");\r\n                currentPosition = { ...currentPosition, direction: right.direction };\r\n                continue;\r\n            }\r\n            const left = this.tryLeft(currentPosition);\r\n            if (left !== null) {\r\n                movements.push(\"L\");\r\n                currentPosition = { ...currentPosition, direction: left.direction };\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        return movements;\r\n    }\r\n\r\n    public toString() {\r\n        return this.matrix.toString((e) => e!);\r\n    }\r\n\r\n    private isIntersection({ x, y }: Coordinate): boolean {\r\n        return getSurrounding({ x, y }).map((c) => this.get({ x: c.x, y: c.y })).every((e) => e === \"#\");\r\n    }\r\n\r\n    private tryLeft(context: RobotContext): RobotContext | null {\r\n        return this.moveForward({ ...context, direction: rotate(context.direction, \"Counterclockwise\") });\r\n    }\r\n\r\n    private tryRight(context: RobotContext): RobotContext | null {\r\n        return this.moveForward({ ...context, direction: rotate(context.direction, \"Clockwise\") });\r\n    }\r\n\r\n    private moveForward(context: RobotContext): RobotContext | null {\r\n        const newCellPosition = context.direction.sum(context.position);\r\n        const cell = this.matrix.get(newCellPosition);\r\n        if (cell !== \"#\") {\r\n            return null;\r\n        }\r\n        return { ...context, position: newCellPosition };\r\n    }\r\n}\r\n\r\nexport const setAndForget = entryForFile(\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const memory = parseMemory(lines[0]);\r\n        const buffer: string[] = [];\r\n        await execute({\r\n            memory, input: async () => {throw new Error(\"Why did you call me?\"); }, output: async (n) => {\r\n                const c = String.fromCharCode(n);\r\n                buffer.push(c);\r\n            }\r\n        });\r\n        const field = Field.fromBuffer(buffer);\r\n        const alignment = await field.getAlignment();\r\n        // await outputCallback(buffer.join(\"\"));\r\n        await outputCallback(field.toString());\r\n        await outputCallback(`Alignment: ${alignment}`);\r\n\r\n    },\r\n    async ({ lines, outputCallback, pause, isCancelled }) => {\r\n        const memory = parseMemory(lines[0]);\r\n        const buffer: string[] = [];\r\n        await execute({\r\n            memory, input: async () => {throw new Error(\"Why did you call me?\"); }, output: async (n) => {\r\n                const c = String.fromCharCode(n);\r\n                buffer.push(c);\r\n            }\r\n        });\r\n        const field = Field.fromBuffer(buffer);\r\n        const movements = await field.getMovements();\r\n\r\n        const serializedMovements = /*movements.join(\",\");//*/groupBy(movements, 2).map((g) => `${g[0]}${g[1]}`).join(\"\\n\");\r\n        await outputCallback(serializedMovements);\r\n        const functions = await findCompressed(movements.map((e) => e.toString()), outputCallback);\r\n        if (functions === null) {\r\n            await outputCallback(\"Nothing found!\");\r\n            return;\r\n        }\r\n\r\n        const toSend = [\r\n            functions.replaced,\r\n            functions.aCandidate.join(\",\"),\r\n            functions.bCandidate.join(\",\"),\r\n            functions.cCandidate.join(\",\"),\r\n            \"n\\n\"\r\n        ].join(\"\\n\").split(\"\").map((c) =>  c.charCodeAt(0));\r\n\r\n        memory[0] = 2;\r\n        let nextSend = 0;\r\n\r\n        const answer: number[] = [];\r\n\r\n        await outputCallback(\"Running program\");\r\n\r\n        await execute({memory, input: async () => {\r\n            if (nextSend >= toSend.length) {\r\n                throw new Error(\"Why are you asking me for input?\");\r\n            }\r\n            return toSend[nextSend++];\r\n        }, output: async (n) => {\r\n            answer.push(n);\r\n        }});\r\n\r\n        await outputCallback(answer[answer.length - 1]);\r\n    },\r\n    {key: \"set-and-forget\", title: \"Set and Forget\", stars: 2, embeddedData: true}\r\n);\r\n\r\nconst findCandidates = <T, >(e: T[], except: T[]): T[][] => {\r\n    let start = 0;\r\n    while (except.indexOf(e[start]) >= 0) {\r\n        start++;\r\n    }\r\n    const results: T[][] = [];\r\n    let end = start + 1;\r\n\r\n    while (end < e.length && (end - start) <= 20) {\r\n        if (except.indexOf(e[end]) >= 0) {\r\n            break;\r\n        }\r\n        results.push(e.slice(start, end));\r\n        end++;\r\n    }\r\n    // if (results.length === 0) {\r\n    //     throw new Error(\"No candidates found\");\r\n    // }\r\n    return results;\r\n};\r\n\r\nexport function smartCompression(movements: string[]): any {\r\n    const aCandidates = findCandidates(movements, []);\r\n    for (const candidate of aCandidates) {\r\n        const aReplaced = replaceCandidate(movements, candidate, \"A\");\r\n        console.log(movements.join(\" \"));\r\n        console.log(candidate.join(\" \"));\r\n        console.log(aReplaced.join(\" \"));\r\n        const bCandidates = findCandidates(aReplaced, [\"A\"]);\r\n        for (const bCandidate of bCandidates) {\r\n            const bReplaced = replaceCandidate(aReplaced, bCandidate, \"B\");\r\n            const cCandidates = findCandidates(bReplaced, [\"A\", \"B\"]);\r\n            for (const cCandidate of cCandidates) {\r\n                const finalReplace = replaceCandidate(bReplaced, cCandidate, \"C\");\r\n                if (finalReplace.filter((e) => e !== \"A\" && e !== \"B\" && e !== \"C\").length > 0) {\r\n                    continue;\r\n                }\r\n                if (finalReplace.length > 20) {\r\n                    continue;\r\n                }\r\n                return finalReplace;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport async function findCompressed(\r\n    movements: string[],\r\n    outputCallback: (outputLine: any, shouldClear?: boolean | undefined) => Promise<void>\r\n): Promise<null | {\r\n        replaced: string,\r\n        aCandidate: string[],\r\n        bCandidate: string[],\r\n        cCandidate: string[],\r\n}> {\r\n    let currentIteration = 0;\r\n    const totalIterations = movements.length * (movements.length + 1) / 2;\r\n    for (const aCandidate of subsequenceGenerator(movements)) {\r\n        await outputCallback(\"Iteration \" + (++currentIteration) + \" over \" + totalIterations);\r\n        if (isCandidateTooLong(aCandidate)) {\r\n            continue;\r\n        }\r\n        const aReplaced = replaceCandidate(movements, aCandidate, \"A\");\r\n        for (const bCandidate of subsequenceGenerator(aReplaced)) {\r\n            if (isCandidateTooLong(bCandidate)) {\r\n                continue;\r\n            }\r\n            if (bCandidate.indexOf(\"A\") >= 0) {\r\n                continue;\r\n            }\r\n            const bReplaced = replaceCandidate(aReplaced, bCandidate, \"B\");\r\n            for (const cCandidate of subsequenceGenerator(bReplaced)) {\r\n                if (isCandidateTooLong(cCandidate)) {\r\n                    continue;\r\n                }\r\n                if (cCandidate.indexOf(\"A\") >= 0 || cCandidate.indexOf(\"B\") >= 0) {\r\n                    continue;\r\n                }\r\n                const cReplaced = replaceCandidate(bReplaced, cCandidate, \"C\");\r\n                if (cReplaced.filter((e) => [\"A\", \"B\", \"C\"].indexOf(e.toString()) >= 0).length === cReplaced.length) {\r\n                    await outputCallback(\"Found!\");\r\n                    return {\r\n                        replaced: cReplaced.join(\",\"),\r\n                        aCandidate,\r\n                        bCandidate,\r\n                        cCandidate\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isCandidateTooLong(candidate: Array<Movement | string>) {\r\n    return candidate.join(\",\").length > 20;\r\n}\r\n\r\nfunction replaceCandidate(movements: string[], candidate: Array<Movement | string>, candidateName: string): string[] {\r\n    const serializedMovements = movements.join(\",\");\r\n    const serializedCandidate = candidate.join(\",\");\r\n    const re = new RegExp(serializedCandidate, \"g\");\r\n    const replaced = serializedMovements.replace(re, candidateName);\r\n    const newMovements = replaced.split(\",\");\r\n    return newMovements;\r\n}\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { calculateDistances, CellWithDistance } from \"../../../support/labyrinth\";\r\nimport { manhattanDistance, getSurrounding, Coordinate, CCoordinate, getDirection } from \"../../../support/geometry\";\r\n\r\nconst parseLines = (lines: string[]): FixedSizeMatrix<string> => {\r\n    const xSize = lines[0].length;\r\n    const ySize = lines.length;\r\n    const matrix = new FixedSizeMatrix<string>({x: xSize, y: ySize});\r\n    matrix.setFlatData(lines.map((e) => e.trim().split(\"\")).flat());\r\n    return matrix;\r\n};\r\n\r\ntype FixedCell = \"#\" | \".\";\r\n\r\nconst isFixedCell = (e: string): e is FixedCell => {\r\n    return e === \"#\" || e === \".\";\r\n};\r\n\r\ntype RawKey = string;\r\n\r\nconst isRawKey = (e: string): e is RawKey => {\r\n    return !isFixedCell(e) && e.toLowerCase() === e;\r\n};\r\n\r\nexport const manyWorldInterpretation = entryForFile(\r\n    async ({ lines, outputCallback, pause, setAutoStop, resultOutputCallback }) => {\r\n        setAutoStop();\r\n        const matrix = parseLines(lines);\r\n        const matrixStart = matrix.findOneWithCoordinate((e, c) => e === \"@\");\r\n        if (matrixStart === null) {\r\n            throw new Error(\"Cannot find start\");\r\n        }\r\n        matrix.set(matrixStart, \".\");\r\n        let expectedOpenDoors = 0;\r\n        await matrix.onEveryCell((c, e) => {\r\n            if (e && isRawKey(e)) {\r\n                expectedOpenDoors++;\r\n            }\r\n        });\r\n        await outputCallback(expectedOpenDoors);\r\n        let iterations = 0;\r\n        await resultOutputCallback(\r\n            await traverseMatrix(\r\n                matrix,\r\n                [matrixStart],\r\n                [],\r\n                expectedOpenDoors,\r\n                new Map<string, number>(),\r\n                async () => {\r\n                    await pause();\r\n                    iterations++;\r\n                    if (iterations % 1000 === 0) {\r\n                        console.log(`Iterations: ${iterations / 1000}k`);\r\n                    }\r\n                }\r\n            ));\r\n    },\r\n    async ({ lines, outputCallback, pause, setAutoStop, resultOutputCallback }) => {\r\n        setAutoStop();\r\n        const matrix = parseLines(lines);\r\n        const matrixStart = matrix.findOneWithCoordinate((e, c) => e === \"@\");\r\n        if (matrixStart === null) {\r\n            throw new Error(\"Cannot find start\");\r\n        }\r\n        matrix.set(matrixStart, \"#\");\r\n        getSurrounding(matrixStart).forEach((s) => matrix.set(s, \"#\"));\r\n        const matrixStarts = [1, -1].flatMap((x) => [1, -1].map((y) => ({x: matrixStart.x + x, y: matrixStart.y + y})));\r\n        let expectedOpenDoors = 0;\r\n        await matrix.onEveryCell((c, e) => {\r\n            if (e && isRawKey(e)) {\r\n                expectedOpenDoors++;\r\n            }\r\n        });\r\n        await outputCallback(expectedOpenDoors);\r\n        let iterations = 0;\r\n        await resultOutputCallback(\r\n            await traverseMatrix(\r\n                matrix,\r\n                matrixStarts,\r\n                [],\r\n                expectedOpenDoors,\r\n                new Map<string, number>(),\r\n                async () => {\r\n                    await pause();\r\n                    iterations++;\r\n                    if (iterations % 1000 === 0) {\r\n                        console.log(`Iterations: ${iterations / 1000}k`);\r\n                    }\r\n                }\r\n            ));\r\n    },\r\n    { key: \"many-worlds-interpretation\", title: \"Many-Worlds Interpration\", stars: 2, embeddedData: true }\r\n);\r\n\r\ntype Cache = Map<string, number>;\r\n\r\nconst serializeState = (coordinate: Coordinate[], openDoors: string[]) => {\r\n    return JSON.stringify({cs: coordinate.map((c) => ({x: c.x, y: c.y})), d: openDoors.sort()});\r\n};\r\n\r\nasync function traverseMatrix(\r\n    matrix: FixedSizeMatrix<string>,\r\n    matrixStarts: Coordinate[],\r\n    openDoors: string[],\r\n    expectedOpenDoors: number,\r\n    cache: Cache,\r\n    debug?: () => Promise<void>): Promise<number> {\r\n    if (debug) {\r\n        await debug();\r\n    }\r\n    const serializedState = serializeState(matrixStarts, openDoors);\r\n    const cachedValue = cache.get(serializedState);\r\n    if (cachedValue !== undefined) {\r\n        return cachedValue;\r\n    }\r\n\r\n    const reachableKeys =\r\n        matrixStarts.flatMap((matrixStart, index) => {\r\n            return calculateDistances((e) => matrix.get(e), (start, end) => {\r\n                const origin = start.cell;\r\n                if (!isFixedCell(origin) &&\r\n                    openDoors.indexOf(origin) < 0 &&\r\n                    openDoors.indexOf(origin.toUpperCase()) < 0) {\r\n                    return null;\r\n                }\r\n                const destination = matrix.get(end);\r\n                if (!destination ||\r\n                    (destination !== \".\" &&\r\n                        destination.toUpperCase() === destination &&\r\n                        openDoors.indexOf(destination) < 0)\r\n                    || destination === \"#\") {\r\n                    return null;\r\n                }\r\n                return manhattanDistance(start.coordinate, end) + (start.distance || 0);\r\n            }, getSurrounding, matrixStart!).list\r\n                .filter((e) => isRawKey(e.cell))\r\n                .filter((e) => openDoors.indexOf(e.cell.toUpperCase()) < 0)\r\n                .map((e) => ({reachable: e, startIndex: index}));\r\n        });\r\n\r\n    if (reachableKeys.length === 0) {\r\n        if (openDoors.length !== expectedOpenDoors) {\r\n            throw new Error(\"Did not open all doors\");\r\n        }\r\n        return 0;\r\n    }\r\n    // console.log({depth, branching: reachableKeys.length});\r\n    const nestedTotals: number[] = [];\r\n    for (const cell of reachableKeys) {\r\n        const newOpenDoors = openDoors.concat([cell.reachable.cell.toUpperCase()]);\r\n        const nestedDistance = await traverseMatrix(\r\n            matrix,\r\n            matrixStarts.map((start, index) => index === cell.startIndex ? cell.reachable.coordinate : start),\r\n            newOpenDoors,\r\n            expectedOpenDoors,\r\n            cache,\r\n            debug);\r\n        nestedTotals.push(nestedDistance + cell.reachable.distance!);\r\n    }\r\n    const bestNestedTotal = nestedTotals.reduce((acc, next) => Math.min(acc, next), Number.POSITIVE_INFINITY);\r\n    cache.set(serializedState, bestNestedTotal);\r\n    return bestNestedTotal;\r\n}\r\n\r\n","import { entryForFile } from \"../../entry\";\r\nimport { parseMemory, execute, Memory } from \"../../../support/intcode\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { UnknownSizeField } from \"../../../support/field\";\r\nimport { Coordinate, CCoordinate, manhattanDistance } from \"../../../support/geometry\";\r\n\r\ninterface BeamOutput {\r\n    field: UnknownSizeField<\"#\" | \".\">;\r\n    size: Coordinate;\r\n}\r\n\r\nconst left = new CCoordinate(-1, 0);\r\nconst right = new CCoordinate(1, 0);\r\n\r\ninterface RowInfo {\r\n    rowStart: number;\r\n    rowLength: number;\r\n}\r\n\r\ntype RowMapData = Array<RowInfo | undefined>;\r\n\r\nconst serializePoint = (c: Coordinate): string => {\r\n    return `${c.x},${c.y}`;\r\n};\r\n\r\n\r\n\r\nexport const tractorBeam = entryForFile(\r\n    async ({ lines, outputCallback, pause }) => {\r\n        const memory = parseMemory(lines[0]);\r\n        let howManyPulled = 0;\r\n        for (let x = 0; x < 50; x++) {\r\n            for (let y = 0; y < 50; y++) {\r\n                const toServe = [x, y];\r\n                let nextToServe = 0;\r\n                await execute({\r\n                    memory,\r\n                    input: async () => {\r\n                        await pause();\r\n                        return toServe[nextToServe++];\r\n                    },\r\n                    output: async (n) => {\r\n                        howManyPulled += n;\r\n                        await pause();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        await outputCallback(howManyPulled);\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const memory = parseMemory(lines[0]);\r\n\r\n        let startPoint = {x: 3, y: 4};\r\n        const delta = new CCoordinate(1, 1);\r\n\r\n        const rowData: RowMapData = [];\r\n\r\n        const expectedSize = 100;\r\n\r\n        while (true) {\r\n            startPoint = delta.sum(startPoint);\r\n            if (!await isPulled(memory, startPoint)) {\r\n                if (await isPulled(memory, left.sum(startPoint))) {\r\n                    startPoint = left.sum(startPoint);\r\n                } else if (await isPulled(memory, right.sum(startPoint))) {\r\n                    startPoint = right.sum(startPoint);\r\n                } else {\r\n                    throw new Error(\"Could not find start point\");\r\n                }\r\n            }\r\n\r\n            console.log(\"Sure point: \" + JSON.stringify(startPoint));\r\n\r\n            let rowStart = startPoint;\r\n            while (await isPulled(memory, rowStart)) {\r\n                rowStart = left.sum(rowStart);\r\n            }\r\n            rowStart = right.sum(rowStart);\r\n\r\n            console.log(\"Left start: \" + serializePoint(rowStart));\r\n\r\n            const lastRowInfo = await setRowData(memory, rowStart, rowData);\r\n            if (\r\n                lastRowInfo.rowLength >= expectedSize &&\r\n                rowStart.x >= expectedSize &&\r\n                rowStart.y >= expectedSize\r\n                ) {\r\n                    const interestingTopRow = rowStart.y - expectedSize + 1;\r\n                    const topRowInfo = rowData[interestingTopRow];\r\n                    if (topRowInfo) {\r\n                        const deltaX = rowStart.x - topRowInfo.rowStart;\r\n                        console.log({\r\n                            top: interestingTopRow,\r\n                            topStart: topRowInfo.rowStart,\r\n                            topLength: topRowInfo.rowLength,\r\n                            delta: deltaX,\r\n                        });\r\n                        if (topRowInfo.rowLength - deltaX >= expectedSize) {\r\n                            await outputCallback({x: rowStart.x, y: interestingTopRow});\r\n                            return;\r\n                        }\r\n                    }\r\n            }\r\n            startPoint = rowStart;\r\n        }\r\n\r\n    },\r\n    { key: \"tractor-beam\", title: \"Tractor Beam\", stars: 2, embeddedData: true}\r\n);\r\n\r\nconst setRowData = async (memory: Memory, rowStart: Coordinate, rowData: RowMapData): Promise<RowInfo> => {\r\n    let length = 0;\r\n    const start = rowStart.x;\r\n    while (await isPulled(memory, rowStart)) {\r\n        length++;\r\n        rowStart = right.sum(rowStart);\r\n    }\r\n    const rowDataEntry = {\r\n        rowStart: start,\r\n        rowLength: length\r\n    };\r\n    rowData[rowStart.y] = rowDataEntry;\r\n    return rowDataEntry;\r\n};\r\n\r\nconst isRowLongEnough = async (\r\n    memory: Memory,\r\n    startPoint: Coordinate,\r\n    long: number\r\n): Promise<boolean> => {\r\n    for (let i = 0; i < long; i++) {\r\n        if (!await isPulled(memory, startPoint)) {\r\n            return false;\r\n        }\r\n        startPoint = right.sum(startPoint);\r\n    }\r\n    return true;\r\n};\r\n\r\nconst isPulled = async (memory: Memory, coordinate: Coordinate): Promise<boolean> => {\r\n    const toServe = [coordinate.x, coordinate.y];\r\n    let nextToServe = 0;\r\n    let result = false;\r\n    await execute({\r\n        memory,\r\n        input: async () => toServe[nextToServe++],\r\n        output: async (n) => result = (n === 1)\r\n    });\r\n    return result;\r\n};\r\n\r\nconst enlarge = async (\r\n    memory: Memory,\r\n    output: BeamOutput,\r\n    toSize: Coordinate\r\n): Promise<void> => {\r\n    const toFill: Coordinate[] = [];\r\n    const newSize = {\r\n        x: Math.max(toSize.x, output.size.x),\r\n        y: Math.max(toSize.y, output.size.y)\r\n    };\r\n    for (let x = Math.max(Math.min(output.size.x, toSize.x) - 1, 0); x < newSize.x; x++) {\r\n        for (let y = Math.max(Math.min(output.size.y, toSize.y) - 1, 0); y < newSize.y; y++) {\r\n            if (x >= output.size.x || y >= output.size.y) {\r\n                toFill.push({x, y});\r\n            }\r\n        }\r\n    }\r\n    await fillField(memory, output, toFill);\r\n    output.size = newSize;\r\n\r\n};\r\n\r\nconst fillField = async (\r\n    memory: Memory,\r\n    output: BeamOutput,\r\n    toFill: Coordinate[]\r\n): Promise<void> => {\r\n    for (const coordinate of toFill) {\r\n        const toServe = [coordinate.x, coordinate.y];\r\n        let nextToServe = 0;\r\n        await execute({\r\n            memory,\r\n            input: async () => toServe[nextToServe++],\r\n            output: async (n) => {\r\n                if (n === 1) {\r\n                    output.field.set(coordinate, \"#\");\r\n                } else {\r\n                    output.field.set(coordinate, \".\");\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { Coordinate, getSurrounding, manhattanDistance } from \"../../../support/geometry\";\r\nimport { NotImplementedError } from \"../../../support/error\";\r\nimport { calculateDistances, calculateDistancesGenericCoordinates } from \"../../../support/labyrinth\";\r\n\r\nconst getPortalCoordinateAndClean = (c: Coordinate, matrix: FixedSizeMatrix<string>): {f: Coordinate, p: string} => {\r\n    const firstLetter = matrix.get(c);\r\n    matrix.set(c, \" \");\r\n    const firstNeighbours = getSurrounding(c)\r\n        .map((ci) => ({c, cell: matrix.get(ci)}))\r\n        .filter((e) => e.cell && (e.cell === \".\" || isLetter(e.cell)))\r\n    ;\r\n    if (firstNeighbours.length === 1) {\r\n        const secondLetter = firstNeighbours[0];\r\n        matrix.set(secondLetter.c, \" \");\r\n        const floorNeighbour = getSurrounding(secondLetter.c)\r\n        .map((ci) => ({\r\n                c: ci,\r\n                cell: matrix.get(ci)\r\n            }))\r\n        .filter((e) => e.cell === \".\")[0].c;\r\n        return {\r\n            f: floorNeighbour,\r\n            p: [firstLetter, secondLetter.cell!].sort().join(\"\")\r\n        };\r\n    } else {\r\n        const secondLetter = firstNeighbours.filter((e) => isLetter(e.cell!))[0];\r\n        matrix.set(secondLetter.c, \" \");\r\n        const floor = firstNeighbours.filter((e) => !isLetter(e.cell!))[0].c;\r\n        return {\r\n            f: floor,\r\n            p: [firstLetter, secondLetter.cell!].sort().join(\"\")\r\n        };\r\n    }\r\n};\r\n\r\nconst isLetter = (s: string): boolean => {\r\n    return s.toLowerCase() !== s || s.toUpperCase() !== s;\r\n};\r\n\r\nconst serializeCoordinate = (c: Coordinate): string => {\r\n    return `${c.x}|${c.y}`;\r\n};\r\n\r\nexport const analyzeMatrix = (matrix: FixedSizeMatrix<string>): {\r\n    portals: Array<{c: Coordinate, name: string}>,\r\n    start: Coordinate,\r\n    end: Coordinate} => {\r\n        let start: Coordinate | null = null;\r\n        let end: Coordinate | null = null;\r\n        const portals: Array<{c: Coordinate, name: string}> = [];\r\n        for (let x = 0; x < matrix.size.x; x++) {\r\n            for (let y = 0; y < matrix.size.y; y++) {\r\n                const cell = matrix.get({x, y});\r\n                if (cell && cell.toLowerCase() !== cell) {\r\n                    const {f: floor, p: name} = getPortalCoordinateAndClean({x, y}, matrix);\r\n                    if (name === \"AA\") {\r\n                        start = floor;\r\n                    } else if (name === \"ZZ\") {\r\n                        end = floor;\r\n                    }\r\n                    portals.push({c: floor, name});\r\n                }\r\n            }\r\n        }\r\n\r\n        if (start === null || end === null) {\r\n            throw new Error(\"No start or end found, parsing went wrong\");\r\n        }\r\n        return {portals, start, end};\r\n};\r\n\r\nconst getBorder = (matrix: FixedSizeMatrix<string>): Border => {\r\n    const midX = Math.floor(matrix.size.x / 2);\r\n    const topLeft: Coordinate = {\r\n        x: 0,\r\n        y: 0\r\n    };\r\n    const bottomRight: Coordinate = {\r\n        x: 0,\r\n        y: 0\r\n    };\r\n    for (let y = 0; y < matrix.size.y; y++) {\r\n        const cell = matrix.get({x: midX, y});\r\n        if (cell !== \" \") {\r\n            topLeft.y = y;\r\n            break;\r\n        }\r\n    }\r\n    for (let y = matrix.size.y - 1; y >= 0; y--) {\r\n        const cell = matrix.get({x: midX, y});\r\n        if (cell !== \" \") {\r\n            bottomRight.y = y;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const midY = Math.floor(matrix.size.y / 2);\r\n\r\n    for (let x = 0; x < matrix.size.x; x++) {\r\n        const cell = matrix.get({x, y: midY});\r\n        if (cell !== \" \") {\r\n            topLeft.x = x;\r\n            break;\r\n        }\r\n    }\r\n    for (let x = matrix.size.x - 1; x >= 0; x--) {\r\n        const cell = matrix.get({x, y: midY});\r\n        if (cell !== \" \") {\r\n            bottomRight.x = x;\r\n            break;\r\n        }\r\n    }\r\n    return {\r\n        topLeft,\r\n        bottomRight\r\n    };\r\n};\r\n\r\ninterface Border {\r\n    topLeft: Coordinate;\r\n    bottomRight: Coordinate;\r\n}\r\n\r\nconst isInBorder = (c: Coordinate, b: Border): boolean => {\r\n    return (c.x === b.topLeft.x || c.x === b.bottomRight.x) || (c.y === b.topLeft.y || c.y === b.bottomRight.y);\r\n};\r\n\r\n\r\nexport const donutMaze = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const matrix = parseLines(lines);\r\n        const {portals, start, end} = analyzeMatrix(matrix);\r\n        const portalMap = createPortalMap(portals);\r\n        const distances = calculateDistances(\r\n            (c) => matrix.get(c),\r\n            (s, _) => (s.distance || 0) + 1,\r\n            (c) => {\r\n                return getSurrounding(c).map((coordinate) => {\r\n                    const n = matrix.get(coordinate);\r\n                    if (n === \".\") {\r\n                        return coordinate;\r\n                    }\r\n                    const portaled = portalMap.get(serializeCoordinate(c));\r\n                    if (portaled === undefined) {\r\n                        return null;\r\n                    }\r\n                    return portaled;\r\n                }).filter((e) => e !== null).map((e) => e!);\r\n            },\r\n            start\r\n        );\r\n        await outputCallback(distances.map(end));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const matrix = parseLines(lines);\r\n        const {portals, start, end} = analyzeMatrix(matrix);\r\n        const portalMap = createPortalMap(portals);\r\n\r\n        const border = getBorder(matrix);\r\n\r\n        let found = false;\r\n        let maxDepth = 0;\r\n\r\n        while (!found) {\r\n            await outputCallback(\"Trying with depth \" + maxDepth);\r\n            const distances = calculateDistancesGenericCoordinates(\r\n                (c) => matrix.get(c),\r\n                (s, _) => (s.distance || 0) + 1,\r\n                (c) => {\r\n                    return getSurrounding(c).map((coordinate) => {\r\n                        const n = matrix.get(coordinate);\r\n                        if (n === \".\") {\r\n                            return {...coordinate, depth: c.depth};\r\n                        }\r\n                        const portaled = portalMap.get(serializeCoordinate(c));\r\n                        if (portaled === undefined) {\r\n                            return null;\r\n                        }\r\n                        const depthIncrement = isInBorder(c, border) ? -1 : 1;\r\n                        const newDepth = c.depth + depthIncrement;\r\n                        if (newDepth < 0 || newDepth > maxDepth) {\r\n                            return null;\r\n                        }\r\n                        return {...portaled, depth: newDepth};\r\n                    }).filter((e) => e !== null).map((e) => e!);\r\n                },\r\n                {x: start.x, y: start.y, depth: 0},\r\n                (e) => `${e.x}|${e.y}|${e.depth}`\r\n            );\r\n            const endDistance = distances.map({...end, depth: 0});\r\n            if (endDistance !== null) {\r\n                await outputCallback(endDistance);\r\n                found = true;\r\n                return;\r\n            }\r\n            maxDepth++;\r\n        }\r\n    },\r\n    { key: \"donut-maze\", title: \"Donut Maze\", stars: 2, embeddedData: true}\r\n);\r\n\r\nfunction parseLines(lines: string[]): FixedSizeMatrix<string> {\r\n    const matrix = new FixedSizeMatrix<string>({ x: lines[0].length, y: lines.length });\r\n    matrix.setFlatData(lines.flatMap((e) => e.split(\"\")));\r\n    return matrix;\r\n}\r\n\r\nfunction createPortalMap(portals: Array<{ c: Coordinate; name: string; }>): Map<string, Coordinate> {\r\n    const portalNameMap = new Map<string, Coordinate[]>();\r\n    portals.forEach((portal) => {\r\n        let l = portalNameMap.get(portal.name);\r\n        if (l === undefined) {\r\n            l = [];\r\n            portalNameMap.set(portal.name, l);\r\n        }\r\n        l.push(portal.c);\r\n    });\r\n    const portalMap = new Map<string, Coordinate>();\r\n    [...portalNameMap.keys()]\r\n        .filter((k) => k !== \"AA\" && k !== \"ZZ\")\r\n        .map((k) => portalNameMap.get(k)!)\r\n        .forEach((ls) => {\r\n            if (ls.length !== 2) {\r\n                throw new Error(\"Parsing went wrong, \" + ls.length);\r\n            }\r\n            portalMap.set(serializeCoordinate(ls[0]), { x: ls[1].x, y: ls[1].y });\r\n            portalMap.set(serializeCoordinate(ls[1]), { x: ls[0].x, y: ls[0].y });\r\n        });\r\n    return portalMap;\r\n}\r\n","import { entryForFile, Pause } from \"../../entry\";\nimport { parseMemory, execute, Memory } from \"../../../support/intcode\";\n\nexport const springdroidAdventure = entryForFile(\n    async ({ lines, outputCallback, pause }) => {\n        const program = [\n            // \"NOT J J\",\n            // \"AND A J\",\n            // \"AND C J\",\n            // \"NOT J J\",\n            // \"OR J T\",\n            // \"AND D J\",\n            // \"AND T J\",\n            \"NOT C T\",\n            \"OR T J\",\n            \"AND D J\",\n            \"NOT A T\",\n            \"OR T J\",\n            \"WALK\"\n        ];\n        const memory = parseMemory(lines[0]);\n        const output: string[] = await executeAscii(program, memory, pause);\n        await outputCallback(output.join(\"\"));\n    },\n    async ({ lines, outputCallback, pause }) => {\n        const program = [\n            \"NOT B J\",\n            \"NOT E T\",\n            \"AND T J\",\n\n            \"OR T T\",\n            \"AND T T\",\n\n            \"AND C T\",\n            \"OR F T\",\n            \"NOT T T\",\n            \"OR T J\",\n\n            \"NOT A T\",\n            \"OR T J\",\n            \"AND D J\",\n            \"RUN\"\n        ];\n\n        const program2 = [\n            \"NOT B J\",\n            \"NOT E T\",\n            \"AND T J\",\n\n            \"OR T T\",\n            \"AND T T\",\n\n            \"AND C T\",\n            \"OR F T\",\n            \"NOT T T\",\n            \"OR T J\",\n\n            \"OR F T\",\n            \"AND E T\",\n            \"OR T J\",\n\n            \"NOT A T\",\n            \"OR T J\",\n            \"AND D J\",\n            \"RUN\"\n        ];\n\n        const program3 = [\n            \"NOT B J\",\n            \"NOT E T\",\n            \"AND T J\",\n\n            \"AND C T\",\n            \"OR F T\",\n            \"NOT T T\",\n            \"OR T J\",\n\n            \"OR C T\",\n            \"OR E T\",\n            \"NOT T T\",\n            \"OR T J\",\n\n            \"NOT A T\",\n            \"OR T J\",\n            \"AND D J\",\n            \"RUN\"\n        ];\n\n        const program4 = [\n            \"NOT B J\",\n            \"NOT E T\",\n            \"AND T J\",\n\n            \"NOT C T\",\n            \"NOT T T\",\n            \"OR F T\",\n            \"NOT T T\",\n            \"OR T J\",\n\n            \"NOT A T\",\n            \"OR T J\",\n            \"AND D J\",\n            \"RUN\",\n        ];\n\n        const program5 = [\n            \"OR A T\",\n            \"AND B T\",\n            \"AND C T\",\n            \"NOT T J\",\n\n            \"OR E T\",\n            \"OR H T\",\n            \"AND T J\",\n\n            \"AND D J\",\n            \"RUN\",\n        ];\n        const memory = parseMemory(lines[0]);\n        const output: string[] = await executeAscii(program5, memory, pause);\n        await outputCallback(output.join(\"\"));\n    },\n    { key: \"springdroid-adventure\", title: \"Springdroid Adventure\", stars: 2, embeddedData: true}\n);\n\nasync function executeAscii(program: string[], memory: Memory, pause: Pause) {\n    const output: string[] = [];\n    const input = program.concat([\"\"]).join(\"\\n\").split(\"\").map((e) => e.charCodeAt(0));\n    let nextInput = 0;\n    let lastTime = 0;\n    await execute({\n        memory,\n        input: async () => {\n            return input[nextInput++];\n        },\n        output: async (n) => {\n            if (n > 255) {\n                output.push(n.toString());\n            } else {\n                output.push(String.fromCharCode(n));\n            }\n        },\n        next: async () => {\n            const current = new Date().getTime();\n            if (current - lastTime > 500) {\n                lastTime = current;\n                await pause();\n            }\n        },\n    });\n    return output;\n}\n","import { entryForFile, simpleOutputCallbackFactory } from \"../../entry\";\r\nimport { modInverse, pow } from \"../../../support/algebra\";\r\n\r\ninterface Coefficients {\r\n    a: bigint;\r\n    b: bigint;\r\n}\r\n\r\nexport class CoefficientCalculator {\r\n    public coefficients: Coefficients;\r\n    constructor(\r\n        private size: bigint,\r\n        coefficients?: Coefficients\r\n    ) {\r\n        if (!coefficients) {\r\n            this.coefficients = {\r\n                a: 1n,\r\n                b: 0n\r\n            };\r\n        } else {\r\n            this.coefficients = coefficients;\r\n        }\r\n    }\r\n    public deal(): CoefficientCalculator {\r\n        const newCoefficients = {\r\n            a: (this.size - this.coefficients.a) % this.size,\r\n            b: (this.size - this.coefficients.b - 1n) % this.size\r\n        };\r\n        this.coefficients = newCoefficients;\r\n        return this;\r\n    }\r\n\r\n    public cut(n: bigint): CoefficientCalculator {\r\n        const newCoefficients = {\r\n            a: this.coefficients.a,\r\n            b: (this.size + this.coefficients.b - n) % this.size\r\n        };\r\n        this.coefficients = newCoefficients;\r\n        return this;\r\n    }\r\n\r\n    public increment(n: bigint): CoefficientCalculator {\r\n        const newCoefficients = {\r\n            a: (this.coefficients.a * n) % this.size,\r\n            b: (this.coefficients.b * n) % this.size\r\n        };\r\n        this.coefficients = newCoefficients;\r\n        return this;\r\n    }\r\n\r\n    public applyTo(x: bigint): bigint {\r\n        return ((this.coefficients.a * x + this.coefficients.b) % this.size + this.size) % this.size;\r\n    }\r\n\r\n    public pow(n: bigint): CoefficientCalculator {\r\n        const factor = this.coefficients;\r\n        const an = pow(factor.a, n, this.size);\r\n        const b = factor.a === 1n ? (factor.b * n) : (factor.b * ((an - 1n) / (factor.a - 1n)));\r\n        this.coefficients = {\r\n            a: an,\r\n            b: b % this.size\r\n        };\r\n        return this;\r\n    }\r\n\r\n    public invert(): CoefficientCalculator {\r\n        const aInverted = modInverse(this.coefficients.a, this.size);\r\n        this.coefficients = {\r\n            a: aInverted,\r\n            b: -(aInverted * this.coefficients.b)\r\n        };\r\n        return this;\r\n    }\r\n}\r\n\r\nexport const getCoefficients = (\r\n    lines: string[],\r\n    size: bigint,\r\n    startCoefficients?: Coefficients\r\n): CoefficientCalculator => {\r\n    const coefficientCalculator = new CoefficientCalculator(size, startCoefficients);\r\n    lines.forEach((line) => {\r\n        if (line.indexOf(\"deal into new stack\") >= 0) {\r\n            coefficientCalculator.deal();\r\n        } else {\r\n            const tokens = line.split(\" \");\r\n            const n = BigInt(parseInt(tokens[tokens.length - 1], 10));\r\n            if (line.indexOf(\"increment\") >= 0) {\r\n                coefficientCalculator.increment(n);\r\n            } else if (line.indexOf(\"cut\") >= 0) {\r\n                coefficientCalculator.cut(n);\r\n            } else {\r\n                throw new Error(\"Could not parse \" + line);\r\n            }\r\n        }\r\n    });\r\n    return coefficientCalculator;\r\n};\r\n\r\n\r\nexport class Deck {\r\n    public positions: Array<bigint>;\r\n\r\n    public shouldReverse: boolean = false;\r\n\r\n    private readonly size: bigint;\r\n\r\n    constructor(\r\n        size: bigint | number,\r\n        positions?: Array<bigint>\r\n    ) {\r\n        this.size = BigInt(size);\r\n        if (positions) {\r\n            this.positions = positions;\r\n        } else {\r\n            this.positions = [...Array(size)].map((e, i) => BigInt(i));\r\n        }\r\n    }\r\n\r\n    public deal(): Deck {\r\n        const length = BigInt(this.size);\r\n        for (let i = 0; i < this.positions.length; i++) {\r\n            this.positions[i] = length - this.positions[i] - 1n;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public cut(n: number): Deck {\r\n        const length = this.size;\r\n        if (this.shouldReverse) {\r\n            n *= -1;\r\n        }\r\n        for (let i = 0; i < this.positions.length; i++) {\r\n            this.positions[i] = (this.positions[i] - BigInt(n) + length) % length;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public increment(n: number): Deck {\r\n        const length = this.size;\r\n        const factor = this.shouldReverse ? modInverse(BigInt(n), length) : BigInt(n);\r\n        for (let i = 0; i < this.positions.length; i++) {\r\n            this.positions[i] = (this.positions[i] * factor) % length;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public sort(): Array<{ card: (number | bigint), index: (number | bigint) }> {\r\n        return this.positions\r\n            .map((e, i) => ({ e, i }))\r\n            .sort((a, b) => Number(a.e - b.e))\r\n            .map((e) => ({ card: e.i, index: e.e }));\r\n    }\r\n\r\n}\r\n\r\nexport const shuffleDeck = (lines: string[], deck: Deck): void => {\r\n    lines.forEach((line) => {\r\n        if (line.indexOf(\"deal into new stack\") >= 0) {\r\n            deck.deal();\r\n        } else {\r\n            const tokens = line.split(\" \");\r\n            const n = parseInt(tokens[tokens.length - 1], 10);\r\n            if (line.indexOf(\"increment\") >= 0) {\r\n                deck.increment(n);\r\n            } else if (line.indexOf(\"cut\") >= 0) {\r\n                deck.cut(n);\r\n            } else {\r\n                throw new Error(\"Could not parse \" + line);\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nexport const findNumberAtPosition = async (\r\n    input: string[],\r\n    size: number,\r\n    position: number,\r\n    times: number,\r\n    debug?: (s: string) => Promise<void>\r\n): Promise<number | bigint> => {\r\n    const reversedInput = [...input].reverse();\r\n    const deck = new Deck(size, [BigInt(position)]);\r\n    deck.shouldReverse = true;\r\n    const cache = new Map<bigint, number>();\r\n    const history: Array<bigint> = [];\r\n    for (let i = 0; i < times; i++) {\r\n        if (debug && i > 0 && i % 10000 === 0) {\r\n            await debug(`Iteration ${i / 1000}k`);\r\n        }\r\n        const e = deck.positions[0];\r\n        const hit = cache.get(e);\r\n        if (hit !== undefined) {\r\n            if (hit !== 0) {\r\n                throw new Error(\"How the hell did this happen?\");\r\n            }\r\n            const loopSize = i - hit;\r\n            const remaining = times - i;\r\n            const delta = remaining % loopSize;\r\n            const index = hit + delta;\r\n            return history[index];\r\n        }\r\n        history.push(e);\r\n        cache.set(e, i);\r\n        shuffleDeck(reversedInput, deck);\r\n    }\r\n    return deck.positions[0];\r\n};\r\n\r\nexport const slamShuffle = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const size = 10007n;\r\n        const coeff = getCoefficients(lines, size);\r\n        const res = coeff.applyTo(2019n);\r\n        await outputCallback(res);\r\n        const newCoeff = getCoefficients(lines, size);\r\n        newCoeff.invert();\r\n        await outputCallback(newCoeff.applyTo(res));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const size = 119315717514047n;\r\n        const times = 101741582076661n;\r\n\r\n        const coeff = getCoefficients(lines, size);\r\n        coeff.pow(times);\r\n        coeff.invert();\r\n        const value = coeff.applyTo(2020n);\r\n        await outputCallback(value);\r\n\r\n        const checkCoeff = getCoefficients(lines, size);\r\n        checkCoeff.pow(times);\r\n        const inv = checkCoeff.applyTo(value);\r\n        await outputCallback(inv);\r\n    },\r\n    { key: \"slam-shuffle\", title: \"Slam Shuffle\", stars: 1, embeddedData: true }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { Memory, parseMemory, execute } from \"../../../support/intcode\";\r\nimport { Queue } from \"../../../support/data-structure\";\r\n\r\ntype PacketSender = (n: number) => (((n: number) => undefined) | undefined);\r\n\r\ninterface Program {\r\n    memory: Memory;\r\n    inputQueue: Queue<Packet | number>;\r\n    address: number;\r\n    packetSender?: PacketSender;\r\n    nextPacket?: Packet;\r\n    resolver?: () => void;\r\n}\r\n\r\ninterface Packet {\r\n    x: number;\r\n    y?: number;\r\n    isFromNat?: boolean;\r\n}\r\n\r\nconst isPacket = (e: Packet | number): e is Packet => {\r\n    return (e as Packet).x !== undefined;\r\n};\r\n\r\nclass ClosingDown extends Error {\r\n    public readonly FLAG = \"ClosingDown\";\r\n    constructor(s: string) {\r\n        super(s);\r\n    }\r\n}\r\n\r\nexport const categorySix = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const memory = parseMemory(lines[0]);\r\n        const programs: Program[] = [...Array(50).keys()].map((i) => ({\r\n            memory,\r\n            inputQueue: new Queue<Packet | number>(),\r\n            address: i\r\n        }));\r\n\r\n        programs.forEach((p) => p.inputQueue.add(p.address));\r\n\r\n        let sentPackets = 0;\r\n        let receivedPackets = 0;\r\n        const iteration = 0;\r\n        let shouldClose = false;\r\n        const emptyPromise = async () => {\r\n            while (!shouldClose) {\r\n                await new Promise<void>((resolve, reject) => resolve());\r\n            }\r\n            await outputCallback(\"NAT closing down\");\r\n        };\r\n        const promises: Array<Promise<any>> = programs.map<Promise<any>>((p) =>\r\n            execute({\r\n                memory: p.memory,\r\n                input: async () => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    if (p.nextPacket !== undefined) {\r\n                        if (p.nextPacket.y === undefined) {\r\n                            throw new Error(\"Packet wasn't full\");\r\n                        }\r\n                        const y = p.nextPacket.y;\r\n                        p.nextPacket = undefined;\r\n                        receivedPackets++;\r\n                        console.log(`Packet received, pkts: ${receivedPackets}/${sentPackets}`);\r\n                        return y;\r\n                    }\r\n                    const res = p.inputQueue.get();\r\n                    if (res === null) {\r\n                        return -1;\r\n                    } else if (isPacket(res)) {\r\n                        p.nextPacket = res;\r\n                        return res.x;\r\n                    } else {\r\n                        return res;\r\n                    }\r\n                },\r\n                output: async (n) => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    if (!p.packetSender) {\r\n                        const address = n;\r\n                        p.packetSender = ((x) => {\r\n                            const packet: Packet = {\r\n                                x\r\n                            };\r\n                            if (address !== 255) {\r\n                                programs[address].inputQueue.add(packet);\r\n                            }\r\n                            return (y) => {\r\n                                if (address === 255) {\r\n                                    console.log(\"Packet: \" + y);\r\n                                    shouldClose = true;\r\n                                } else {\r\n                                    packet.y = y;\r\n                                    sentPackets++;\r\n                                    console.log(`Packet sent, pkts: ${receivedPackets}/${sentPackets}`);\r\n                                }\r\n                                return undefined;\r\n                            };\r\n                        });\r\n                    } else {\r\n                        p.packetSender = p.packetSender(n);\r\n                    }\r\n                },\r\n                close: () => {\r\n                    throw new ClosingDown(`Program ${p.address} is closing down`);\r\n                },\r\n                next: async () => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    const promise = new Promise<void>((resolve, reject) => {\r\n                        p.resolver = resolve;\r\n                    });\r\n                    const otherResolver = programs[(p.address + 1) % programs.length].resolver;\r\n                    if (otherResolver) {\r\n                        otherResolver();\r\n                    }\r\n                    await promise;\r\n                }\r\n            })).concat([emptyPromise()]);\r\n\r\n        try {\r\n            await Promise.all(promises);\r\n        } catch (e) {\r\n            if ((e as ClosingDown).FLAG) {\r\n                // do nothing\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const memory = parseMemory(lines[0]);\r\n        const programs: Program[] = [...Array(50).keys()].map((i) => ({\r\n            memory,\r\n            inputQueue: new Queue<Packet | number>(),\r\n            address: i\r\n        }));\r\n\r\n        programs.forEach((p) => p.inputQueue.add(p.address));\r\n\r\n        let sentPackets = 0;\r\n        let receivedPackets = 0;\r\n        let natPacket: Packet | null = null;\r\n        const iteration = 0;\r\n        let shouldClose = false;\r\n        let lastNatY: number | null = null;\r\n        const isIdle = (): boolean => programs.filter((p) => p.inputQueue.isEmpty).length === programs.length;\r\n        const emptyPromise = async () => {\r\n            while (!shouldClose) {\r\n                if (natPacket === null || !isIdle()) {\r\n                    await new Promise<void>((resolve, reject) => resolve());\r\n                    continue;\r\n                }\r\n                if (natPacket === null) {\r\n                    throw new Error(\"What happened here?\");\r\n                }\r\n                console.log(\"NAT sending package\");\r\n                natPacket.isFromNat = true;\r\n                programs[0].inputQueue.add(natPacket);\r\n                natPacket = null;\r\n            }\r\n            await outputCallback(\"NAT closing down\");\r\n        };\r\n        const promises: Array<Promise<any>> = programs.map<Promise<any>>((p) =>\r\n            execute({\r\n                memory: p.memory,\r\n                input: async () => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    if (p.nextPacket !== undefined) {\r\n                        if (p.nextPacket.y === undefined) {\r\n                            throw new Error(\"Packet wasn't full\");\r\n                        }\r\n                        const y = p.nextPacket.y;\r\n                        if (p.nextPacket.isFromNat) {\r\n                            if (y === lastNatY) {\r\n                                console.log(\"Found duplicate! \" + y);\r\n                                shouldClose = true;\r\n                                throw new ClosingDown(\"Closing down\");\r\n                            }\r\n                            console.log(`From NAT, not duplicate: ${y} !== ${lastNatY} `);\r\n                            lastNatY = y;\r\n                        }\r\n                        p.nextPacket = undefined;\r\n                        receivedPackets++;\r\n                        console.log(`Packet received, pkts: ${receivedPackets}/${sentPackets}`);\r\n                        return y;\r\n                    }\r\n                    const res = p.inputQueue.get();\r\n                    if (res === null) {\r\n                        return -1;\r\n                    } else if (isPacket(res)) {\r\n                        p.nextPacket = res;\r\n                        return res.x;\r\n                    } else {\r\n                        return res;\r\n                    }\r\n                },\r\n                output: async (n) => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    if (!p.packetSender) {\r\n                        const address = n;\r\n                        p.packetSender = ((x) => {\r\n                            const packet: Packet = {\r\n                                x\r\n                            };\r\n                            if (address !== 255) {\r\n                                programs[address].inputQueue.add(packet);\r\n                            } else {\r\n                                console.log(\"Sending packet to NAT\");\r\n                                natPacket = packet;\r\n                            }\r\n                            return (y) => {\r\n                                packet.y = y;\r\n                                sentPackets++;\r\n                                console.log(`Packet sent, pkts: ${receivedPackets}/${sentPackets}`);\r\n                                return undefined;\r\n                            };\r\n                        });\r\n                    } else {\r\n                        p.packetSender = p.packetSender(n);\r\n                    }\r\n                },\r\n                close: () => {\r\n                    throw new ClosingDown(`Program ${p.address} is closing down`);\r\n                },\r\n                next: async () => {\r\n                    if (shouldClose) {\r\n                        throw new ClosingDown(`Program ${p.address} closing down`);\r\n                    }\r\n                    const promise = new Promise<void>((resolve, reject) => {\r\n                        p.resolver = resolve;\r\n                    });\r\n                    const otherResolver = programs[(p.address + 1) % programs.length].resolver;\r\n                    if (otherResolver) {\r\n                        otherResolver();\r\n                    }\r\n                    await promise;\r\n                }\r\n            })).concat([emptyPromise()]);\r\n\r\n        try {\r\n            await Promise.all(promises);\r\n        } catch (e) {\r\n            if ((e as ClosingDown).FLAG) {\r\n                // do nothing\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    },\r\n    { key: \"category-six\", title: \"Category Six\", stars: 2, embeddedData: true }\r\n);\r\n","import { entryForFile } from \"../../entry\";\r\nimport { FixedSizeMatrix } from \"../../../support/matrix\";\r\nimport { getSurrounding, Coordinate, manhattanDistance, directions, CCoordinate } from \"../../../support/geometry\";\r\nimport { coordinateToKey } from \"./oxygen-system\";\r\n\r\ntype Cell = \"#\" | \".\";\r\n\r\nexport type Planet = FixedSizeMatrix<Cell>;\r\n\r\nexport interface PlanetWithDepth {\r\n    planet: Planet;\r\n    depth: number;\r\n}\r\n\r\nconst parseLines = (lines: string[]): Planet => {\r\n    const size = {y: lines.length, x: lines[0].length};\r\n    const matrix = new FixedSizeMatrix<Cell>(size);\r\n    const flatData = [...lines.join(\"\")];\r\n    if (flatData.filter((e) => e !== \"#\" && e !== \".\").length > 0) {\r\n        throw new Error(\"Invalid input\");\r\n    }\r\n    matrix.setFlatData(flatData.map((e) => e as Cell));\r\n    return matrix;\r\n};\r\n\r\nexport const getInnerAdjacentPositions = (c: Coordinate, innerSize: Coordinate): Coordinate[] => {\r\n    const center = getCenter(innerSize);\r\n    if (isDir(c, center, directions.up)) {\r\n        return range(innerSize.x).map((x) => ({x, y: 0}));\r\n    } else if (isDir(c, center, directions.down)) {\r\n        return range(innerSize.x).map((x) => ({x, y: innerSize.y - 1}));\r\n    } else if (isDir(c, center, directions.left)) {\r\n        return range(innerSize.y).map((y) => ({x: 0, y}));\r\n    } else if (isDir(c, center, directions.right)) {\r\n        return range(innerSize.y).map((y) => ({x: innerSize.x - 1, y}));\r\n    } else {\r\n        throw new Error(\"Invalid inner position\");\r\n    }\r\n};\r\n\r\nexport const getOuterAdjacentPositions = (c: Coordinate, outerSize: Coordinate): Coordinate[] => {\r\n    const center = getCenter(outerSize);\r\n    const result: Coordinate[] = [];\r\n    if (c.x === 0) {\r\n        result.push(directions.left.sum(center));\r\n    }\r\n    if (c.y === 0) {\r\n        result.push(directions.up.sum(center));\r\n    }\r\n    if (c.x === outerSize.x - 1) {\r\n        result.push(directions.right.sum(center));\r\n    }\r\n\r\n    if (c.y === outerSize.y - 1) {\r\n        result.push(directions.down.sum(center));\r\n    }\r\n    return result;\r\n};\r\n\r\nconst bugCounter = (acc: number, next: Cell) => acc + (next === \"#\" ? 1 : 0);\r\n\r\nconst countExternal = (c: Coordinate, main: PlanetWithDepth, outer: PlanetWithDepth): number => {\r\n    const adjacentCellPositions = getOuterAdjacentPositions(c, outer.planet.size);\r\n    const adjacentCells: Cell[] = adjacentCellPositions\r\n        .map((adjacentCellPosition) => outer.planet.get(adjacentCellPosition))\r\n        .filter((cell) => cell !== undefined)\r\n        .map((cell) => cell!);\r\n    return adjacentCells.concat(getSurrounding(c).map((e) => main.planet.get(e)).filter((e) => e).map((e) => e!))\r\n        .reduce(bugCounter, 0);\r\n};\r\n\r\nconst range = (n: number) => [...Array(n).keys()];\r\n\r\nconst isDir = (c: Coordinate, r: Coordinate, direction: CCoordinate): boolean => {\r\n    return manhattanDistance(c, direction.sum(r)) === 0;\r\n};\r\n\r\nconst countInternal = (c: Coordinate, main: PlanetWithDepth, inner: PlanetWithDepth): number => {\r\n    const adjacentCellPositions = getInnerAdjacentPositions(c, inner.planet.size);\r\n    const adjacentCells: Cell[] = adjacentCellPositions\r\n        .map((adjacentCellPosition) => inner.planet.get(adjacentCellPosition))\r\n        .filter((cell) => cell !== undefined)\r\n        .map((cell) => cell!);\r\n    return adjacentCells.concat(\r\n            getSurrounding(c)\r\n            .map((e) => main.planet.get(e))\r\n            .filter((e) => e)\r\n            .map((e) => e!)\r\n        )\r\n        .reduce(bugCounter, 0);\r\n};\r\nexport const countNeighbourBugs = (\r\n    c: Coordinate,\r\n    main: PlanetWithDepth,\r\n    outer: PlanetWithDepth | undefined,\r\n    inner: PlanetWithDepth | undefined\r\n): number => {\r\n    if (isExternalBorderCoordinate(main.planet.size, c) && outer) {\r\n        return countExternal(c, main, outer);\r\n    } else if (isInternalBorderCoordinate(main.planet.size, c) && inner) {\r\n        return countInternal(c, main, inner);\r\n    }\r\n    return getSurrounding(c)\r\n        .map((ci) => main.planet.get(ci))\r\n        .filter((ci) => ci)\r\n        .map((ci) => ci!)\r\n        .reduce(bugCounter, 0);\r\n};\r\n\r\nconst passDepthTime = async (ps: PlanetWithDepth[]): Promise<PlanetWithDepth[]> => {\r\n    ps = extendDepths(ps);\r\n    const result = ps.map((e) => ({\r\n        depth: e.depth,\r\n        planet: e.planet.copy()\r\n    }));\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const outer = ps[i - 1];\r\n        const inner = ps[i + 1];\r\n        const main = ps[i];\r\n        main.planet.onEveryCell((coordinate, cell) => {\r\n            const nBugs = countNeighbourBugs(coordinate, main, outer, inner);\r\n            handleCellTimePass(cell, nBugs, result[i].planet, coordinate);\r\n        });\r\n    }\r\n    return result;\r\n};\r\n\r\nconst passPlanetTime = async (p: Planet): Promise<Planet> => {\r\n    const newPlanet = p.copy();\r\n    await newPlanet.onEveryCell((c, e) => {\r\n        const neighbours = getSurrounding(c);\r\n        const nBugs = neighbours.map((n) => p.get(n)).filter((n) => n === \"#\").length;\r\n        handleCellTimePass(e, nBugs, newPlanet, c);\r\n    });\r\n    return newPlanet;\r\n};\r\n\r\nconst isExternalBorderCoordinate = (size: Coordinate, c: Coordinate): boolean => {\r\n    return c.x === 0 || c.y === 0 || c.x === size.x - 1 || c.y === size.y - 1;\r\n};\r\n\r\nconst isInternalBorderCoordinate = (size: Coordinate, c: Coordinate): boolean => {\r\n    const center = getCenter(size);\r\n\r\n    return manhattanDistance(center, c) === 1;\r\n};\r\n\r\nconst emptyPlanetGenerator = (size: Coordinate): Planet => {\r\n    const flatData: Array<\".\"> = [...Array(size.x * size.y).keys()].map((e) => \".\");\r\n    const matrix = new FixedSizeMatrix<Cell>(size);\r\n    matrix.setFlatData(flatData);\r\n    const center = getCenter(size);\r\n    matrix.set(center, undefined);\r\n    return matrix;\r\n};\r\n\r\nconst getAdditionalDepths = (outer: PlanetWithDepth, inner: PlanetWithDepth): PlanetWithDepth[] => {\r\n    const size = outer.planet.size;\r\n    const externalBorderBugs = outer.planet.reduce(\r\n        (acc, next) => acc + (next.cell === \"#\" && isExternalBorderCoordinate(size, next.coordinate) ? 1 : 0),\r\n        0\r\n    );\r\n    const internalBorderBugs = inner.planet.reduce(\r\n        (acc, next) => acc + (next.cell === \"#\" && isInternalBorderCoordinate(size, next.coordinate) ? 1 : 0),\r\n        0\r\n    );\r\n\r\n    const result: PlanetWithDepth[] = [];\r\n\r\n    if (externalBorderBugs > 0) {\r\n        result.push({planet: emptyPlanetGenerator(size), depth: outer.depth - 1});\r\n    }\r\n    if (internalBorderBugs > 0) {\r\n        result.push({planet: emptyPlanetGenerator(size), depth: inner.depth + 1});\r\n    }\r\n    return result;\r\n};\r\n\r\nconst sortDepths = (planets: PlanetWithDepth[]): PlanetWithDepth[] => {\r\n    return planets.sort((a, b) => a.depth - b.depth);\r\n};\r\n\r\nconst extendDepths = (planets: PlanetWithDepth[]): PlanetWithDepth[] => {\r\n    planets = sortDepths(planets);\r\n    const [outer, inner] = [planets[0], planets[planets.length - 1 ]];\r\n    const additional = getAdditionalDepths(outer, inner);\r\n    additional.forEach((a) => planets.push(a));\r\n    return sortDepths(planets);\r\n};\r\n\r\nconst calculateValue = (p: Planet): number => {\r\n    let total = 0;\r\n    let current = 1;\r\n    for (let y = 0; y < p.size.y; y++) {\r\n        for (let x = 0; x < p.size.x; x++) {\r\n            if (p.get({x, y}) === \"#\") {\r\n                total += current;\r\n            }\r\n            current *= 2;\r\n        }\r\n    }\r\n    return total;\r\n};\r\n\r\nexport const planetOfDiscord = entryForFile(\r\n    async ({ lines, outputCallback }) => {\r\n        const visitedStates = new Set<string>();\r\n        const matrix = parseLines(lines);\r\n        let planet = matrix;\r\n        let iteration = 0;\r\n        while (true) {\r\n            iteration++;\r\n            if (iteration % 1000 === 0) {\r\n                await outputCallback(`Iteration ${iteration / 1000}k`);\r\n            }\r\n            const serializedState = planet.simpleSerialize();\r\n            if (visitedStates.has(serializedState)) {\r\n                break;\r\n            }\r\n            visitedStates.add(serializedState);\r\n            planet = await passPlanetTime(planet);\r\n        }\r\n        await outputCallback(`Found it after ${visitedStates.size}!`);\r\n        await outputCallback(\"Bio: \" + (calculateValue(planet)));\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        const basePlanet = parseLines(lines);\r\n        basePlanet.set({x: 2, y: 2}, undefined);\r\n        let depths: PlanetWithDepth[] = [{planet: basePlanet, depth: 0}];\r\n        for (let i = 0; i < 200; i++) {\r\n            depths = await passDepthTime(depths);\r\n        }\r\n\r\n        // for (const d of depths) {\r\n        //     await outputCallback(\"Depth: \" + d.depth);\r\n        //     await outputCallback(d.planet.toString(e => e || \" \"));\r\n        // }\r\n        await outputCallback(\r\n            depths\r\n                .map((d) => d.planet.reduce((acc, next) => acc + (next.cell === \"#\" ? 1 : 0), 0))\r\n                .reduce((acc, next) => acc + next)\r\n        );\r\n    },\r\n    { key: \"planet-of-discord\", title: \"Planet of Discord\", stars: 2, embeddedData: true}\r\n);\r\n\r\nexport function getCenter(size: Coordinate) {\r\n    return {\r\n        x: Math.floor(size.x / 2),\r\n        y: Math.floor(size.y / 2)\r\n    };\r\n}\r\n\r\nfunction handleCellTimePass(e: string | undefined, nBugs: number, newPlanet: FixedSizeMatrix<Cell>, c: Coordinate) {\r\n    if (e === \"#\") {\r\n        if (nBugs !== 1) {\r\n            newPlanet.set(c, \".\");\r\n        }\r\n    } else if (e === \".\") {\r\n        if (nBugs === 1 || nBugs === 2) {\r\n            newPlanet.set(c, \"#\");\r\n        }\r\n    } else if (e === undefined) {\r\n        // center\r\n    } else {\r\n        throw new Error(\"Invalid cell\");\r\n    }\r\n}\r\n","import { entryForFile } from \"../../entry\";\r\nimport { parseMemory, execute, stopExecution } from \"../../../support/intcode\";\r\nimport { UnknownSizeField } from \"../../../support/field\";\r\nimport { directions, CCoordinate, Coordinate, manhattanDistance } from \"../../../support/geometry\";\r\nimport { Field } from \"./oxygen-system\";\r\nimport { subsetGenerator } from \"../../../support/sequences\";\r\n\r\nexport const cryostasis = entryForFile(\r\n    async ({ lines, outputCallback, additionalInputReader }) => {\r\n        if (!additionalInputReader) {\r\n            await outputCallback(\"This puzzle requires input from the user, cannot run\");\r\n            return;\r\n        }\r\n        const memory = parseMemory(lines[0]);\r\n        const inputBuffer: number[] = [];\r\n        const outputBuffer: number[] = [];\r\n        const exploration = {\r\n            exploringLocation: { x: 0, y: 0 } as (Coordinate | null),\r\n            exploreResult: null as (string | null),\r\n            explored: new Set<string>(),\r\n            field: new UnknownSizeField<string>(),\r\n            currentPosition: { x: 0, y: 0 },\r\n            autoMovements: [] as string[]\r\n        };\r\n\r\n        const inventory = {\r\n            elements: [] as string[],\r\n            isPopulating: false\r\n        };\r\n\r\n        const hacking = {\r\n            isHacking: false,\r\n            subsets: [] as string[][],\r\n            dropping: null as (string[] | null),\r\n            lastDrop: null as (string[] | null),\r\n            fullInventory: [] as string[],\r\n            currentInventory: [] as string[],\r\n            startPosition: null as (Coordinate | null),\r\n            toRecover: [] as string[],\r\n            isTooMuch: null as (\"heavy\" | \"light\" | null)\r\n        };\r\n\r\n        const possibleMovements = {\r\n            populating: false,\r\n            movements: [] as string[]\r\n        };\r\n\r\n        const autoTake = {\r\n            enable: false,\r\n            toTake: [] as string[],\r\n            populating: false\r\n        };\r\n\r\n        const movementMap: { [key: string]: CCoordinate } = {\r\n            north: directions.up,\r\n            south: directions.down,\r\n            east: directions.right,\r\n            west: directions.left\r\n        };\r\n\r\n\r\n        const handleCustomCommand = async (line: string) => {\r\n            await outputCallback(\"\");\r\n            const words = line.toLowerCase().split(\" \").filter((e) => e.length > 0);\r\n            const command = words[1];\r\n            switch (command) {\r\n                case \"map\":\r\n                    const output = createMap(exploration);\r\n                    await outputCallback(output);\r\n                    break;\r\n                case \"inv\":\r\n                    await outputCallback(\"Inventory:\");\r\n                    for (const e of inventory.elements) {\r\n                        await outputCallback(\"* \" + e);\r\n                    }\r\n                    break;\r\n                case \"hack\":\r\n                    if (inventory.elements.length === 0) {\r\n                        await outputCallback(\"Cannot hack without inventory\");\r\n                        break;\r\n                    }\r\n                    autoTake.enable = false;\r\n                    hacking.subsets = [...subsetGenerator(inventory.elements, 0)];\r\n                    hacking.isHacking = true;\r\n                    hacking.fullInventory = [...inventory.elements];\r\n                    hacking.currentInventory = [...inventory.elements];\r\n                    hacking.startPosition = exploration.currentPosition;\r\n                    break;\r\n\r\n                case \"auto-take\":\r\n                    autoTake.enable = !autoTake.enable;\r\n                    await outputCallback(\"Auto take: \" + autoTake.enable);\r\n                    break;\r\n\r\n                case \"dirs\":\r\n                    await outputCallback(\"Doors here lead:\");\r\n                    for (const direction of possibleMovements.movements) {\r\n                        await outputCallback(\"- \" + direction);\r\n                    }\r\n                    break;\r\n\r\n                case \"auto-start\":\r\n                    if (manhattanDistance(exploration.currentPosition, { x: 0, y: 0 }) !== 0) {\r\n                        await outputCallback(\"Can only explore automatically from the start\");\r\n                    } else {\r\n                        exploration.autoMovements = [\r\n                            \"cheat auto-take\",\r\n                            \"east\",\r\n                            \"west\",\r\n                            \"north\",\r\n                            \"north\",\r\n                            \"east\",\r\n                            \"south\",\r\n                            \"south\",\r\n                            \"north\",\r\n                            \"north\",\r\n                            \"east\",\r\n                            \"south\",\r\n                            \"north\",\r\n                            \"north\",\r\n                            \"west\",\r\n                            \"west\",\r\n                            \"east\",\r\n                            \"north\",\r\n                            \"south\",\r\n                            \"east\",\r\n                            \"east\",\r\n                            \"north\",\r\n                            \"north\",\r\n                            \"south\",\r\n                            \"south\",\r\n                            \"south\",\r\n                            \"east\",\r\n                            \"south\",\r\n                            \"north\",\r\n                            \"west\",\r\n                            \"north\",\r\n                            \"west\",\r\n                            \"south\",\r\n                            \"west\",\r\n                            \"south\",\r\n                            \"south\",\r\n                            \"inv\"\r\n                        ];\r\n                    }\r\n                    break;\r\n\r\n\r\n                case \"clear\":\r\n                    await outputCallback(null);\r\n                    break;\r\n\r\n                default:\r\n                    break;\r\n            }\r\n            await outputCallback(\"Command?\");\r\n        };\r\n\r\n        const executeCommand = async (line: string) => {\r\n            line.split(\"\").map((e) => e.charCodeAt(0)).forEach((e) => inputBuffer.push(e));\r\n            inputBuffer.push(\"\\n\".charCodeAt(0));\r\n            await outputCallback(\"Executing: \" + line);\r\n        };\r\n        await execute({\r\n            memory,\r\n            input: async () => {\r\n                if (inputBuffer.length === 0) {\r\n                    while (true) {\r\n                        let line: string | null = null;\r\n                        if (autoTake.enable && autoTake.toTake.length > 0) {\r\n                            line = \"take \" + autoTake.toTake.shift()!;\r\n                        } else if (hacking.isHacking) {\r\n                            if (hacking.toRecover.length > 0) {\r\n                                const candidate = hacking.toRecover.shift()!;\r\n                                if (hacking.currentInventory.indexOf(candidate) < 0) {\r\n                                    hacking.currentInventory.push(candidate);\r\n                                    line = \"take \" + candidate;\r\n                                } else {\r\n                                    continue;\r\n                                }\r\n                            } else if (hacking.dropping === null) {\r\n                                if (hacking.subsets.length === 0) {\r\n                                    await outputCallback(\"Hacking failed\");\r\n                                    hacking.isHacking = false;\r\n                                    continue;\r\n                                }\r\n                                if (hacking.isTooMuch === \"light\" && hacking.lastDrop !== null) {\r\n                                    await outputCallback(\"----------------- Too light\");\r\n                                    const length = hacking.subsets.length;\r\n                                    hacking.subsets = hacking.subsets.filter((subset) => {\r\n                                        for (const hasDropped of hacking.lastDrop!) {\r\n                                            if (subset.indexOf(hasDropped) < 0) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                        return false;\r\n                                    });\r\n                                    const drop = length - hacking.subsets.length;\r\n                                    if (drop > 0) {\r\n                                        await outputCallback(`~~~~~~~~~ Hooray! Dropped ${drop}`);\r\n                                    }\r\n                                    await outputCallback(\"Remaining: \" + hacking.subsets.length);\r\n                                } else if (hacking.isTooMuch === \"heavy\" && hacking.lastDrop !== null) {\r\n                                    await outputCallback(\"----------------- Too heavy\");\r\n                                    const length = hacking.subsets.length;\r\n                                    hacking.subsets = hacking.subsets.filter((subset) => {\r\n                                        for (const wouldDrop of subset) {\r\n                                            if (hacking.lastDrop!.indexOf(wouldDrop) < 0) {\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                        return false;\r\n                                    });\r\n                                    const drop = length - hacking.subsets.length;\r\n                                    if (drop > 0) {\r\n                                        await outputCallback(`~~~~~~~~~ Hooray! Dropped ${drop}`);\r\n                                    }\r\n                                    await outputCallback(\"Remaining: \" + hacking.subsets.length);\r\n                                }\r\n                                hacking.dropping = hacking.subsets.shift()!;\r\n                                hacking.lastDrop = [...hacking.dropping];\r\n                                continue;\r\n                            } else if (hacking.dropping.length === 0) {\r\n                                line = \"east\";\r\n                                hacking.dropping = null;\r\n                            } else {\r\n                                const toDrop = hacking.dropping.shift()!;\r\n                                hacking.currentInventory = hacking.currentInventory.filter((e) => e !== toDrop);\r\n                                line = \"drop \" + toDrop;\r\n                            }\r\n                        } else if (exploration.autoMovements.length > 0) {\r\n                            line = exploration.autoMovements.shift()!;\r\n                        } else {\r\n                            line = await additionalInputReader.read();\r\n                        }\r\n                        if (line === null) {\r\n                            stopExecution();\r\n                            continue;\r\n                        }\r\n                        if (line.toLowerCase().startsWith(\"cheat\")) {\r\n                            await handleCustomCommand(line);\r\n                            continue;\r\n                        }\r\n                        if (movementMap[line] !== undefined) {\r\n                            const direction = movementMap[line];\r\n                            exploration.exploringLocation = direction.sum(exploration.currentPosition);\r\n                        }\r\n                        await executeCommand(line);\r\n                        break;\r\n                    }\r\n                }\r\n                return inputBuffer.shift()!;\r\n            },\r\n            output: async (o) => {\r\n                if (\"\\n\".charCodeAt(0) === o) {\r\n                    const line = outputBuffer.map((n) => String.fromCharCode(n)).join(\"\");\r\n                    const trimmed = line.trim();\r\n                    if (trimmed.length === 0) {\r\n                        possibleMovements.populating = false;\r\n                    }\r\n                    if (line.indexOf(\"Pressure-Sensitive Floor\") >= 0) {\r\n                        hacking.isTooMuch = null;\r\n                    }\r\n                    if (line.indexOf(\"loud, robotic voice says \\\"Alert!\") >= 0) {\r\n                        if (line.indexOf(\"are heavier than the detected\") >= 0) {\r\n                            hacking.isTooMuch = \"light\";\r\n                        } else {\r\n                            hacking.isTooMuch = \"heavy\";\r\n                        }\r\n                    }\r\n                    if (line === \"Command?\") {\r\n                        inventory.isPopulating = false;\r\n                        autoTake.populating = false;\r\n                        if (exploration.exploringLocation !== null && exploration.exploreResult !== null) {\r\n                            if (hacking.isHacking) {\r\n                                hacking.isHacking = false;\r\n                                hacking.dropping = null;\r\n                                hacking.subsets = [];\r\n                                hacking.toRecover = [];\r\n                            }\r\n                            exploration.field.set(exploration.exploringLocation, exploration.exploreResult);\r\n                            exploration.explored.add(exploration.exploreResult);\r\n                            exploration.currentPosition = exploration.exploringLocation;\r\n                            exploration.exploringLocation = null;\r\n                            exploration.exploreResult = null;\r\n                        }\r\n                    } else if (possibleMovements.populating) {\r\n                        possibleMovements.movements.push(trimmed.slice(2));\r\n                    } else if (inventory.isPopulating && trimmed.length > 0) {\r\n                        inventory.elements.push(trimmed.slice(2));\r\n                    } else if (autoTake.populating && trimmed.length > 0) {\r\n                        const item = trimmed.slice(2);\r\n                        if ([\r\n                            \"infinite loop\",\r\n                            \"giant electromagnet\",\r\n                            \"escape pod\",\r\n                            \"molten lava\",\r\n                            \"photons\"\r\n                        ].indexOf(item) < 0) {\r\n                            autoTake.toTake.push(item);\r\n                        }\r\n                    } else if (trimmed.startsWith(\"==\")) {\r\n                        if (exploration.exploringLocation !== null && exploration.exploreResult === null) {\r\n                            exploration.exploreResult = trimmed;\r\n                        } else if (exploration.exploreResult !== null) {\r\n                            exploration.exploreResult = null;\r\n                            exploration.exploringLocation = null;\r\n                            if (hacking.isHacking) {\r\n                                // failed exploration\r\n                                hacking.toRecover = [...inventory.elements];\r\n                            }\r\n                        }\r\n                    } else if (trimmed === \"Items in your inventory:\") {\r\n                        inventory.isPopulating = true;\r\n                        inventory.elements = [];\r\n                    } else if (trimmed === \"Items here:\" && autoTake.enable) {\r\n                        autoTake.populating = true;\r\n                        autoTake.toTake = [];\r\n                    } else if (trimmed === \"Doors here lead:\") {\r\n                        possibleMovements.populating = true;\r\n                        possibleMovements.movements = [];\r\n                    }\r\n                    await outputCallback(line);\r\n                    outputBuffer.length = 0;\r\n                } else {\r\n                    outputBuffer.push(o);\r\n                }\r\n            }\r\n        });\r\n\r\n        await outputCallback(\"Program finished\");\r\n        await outputCallback(createMap(exploration));\r\n        additionalInputReader.close();\r\n    },\r\n    async ({ lines, outputCallback }) => {\r\n        throw Error(\"Not implemented\");\r\n    },\r\n    { key: \"cryostasis\", title: \"Cryostasis\", stars: 1, hasAdditionalInput: true, embeddedData: true }\r\n);\r\n\r\nfunction createMap(\r\n    exploration: {\r\n        exploringLocation: Coordinate | null;\r\n        exploreResult: string | null;\r\n        explored: Set<string>;\r\n        field: UnknownSizeField<string>;\r\n        currentPosition: { x: number; y: number; };\r\n        autoMovements: string[];\r\n    }\r\n) {\r\n    const maxLength = [...exploration.explored.values()].reduce((acc, next) => Math.max(acc, next.length), 0);\r\n    const matrix = exploration.field.toMatrix();\r\n    const output = matrix.toString((e) => {\r\n        if (!e) {\r\n            return \"\".padStart(maxLength, \" \");\r\n        }\r\n        const padding = maxLength - e.length;\r\n        return \"\".padStart(Math.floor(padding / 2), \" \") + e + \"\".padEnd(Math.ceil(padding / 2), \" \");\r\n    });\r\n    return output;\r\n}\r\n","import { entry as rocketTyranny } from \"./rocket-tyranny\";\nimport { programAlarm } from \"./program-alarm\";\nimport { crossedWires } from \"./crossed-wires\";\nimport { secureContainer } from \"./secure-container\";\nimport { sunnyAsteroids } from \"./sunny-asteroids\";\nimport { universalObritMap } from \"./universal-orbit-map\";\nimport { amplificationCircuit } from \"./amplification-circuit\";\nimport { spaceImageFormat } from \"./space-image-format\";\nimport { sensorBoost } from \"./sensor-boost\";\nimport { monitoringStation } from \"./monitoring-station\";\nimport { spacePolice } from \"./space-police\";\nimport { nBodyProblem } from \"./n-body-problem\";\nimport { carePackage } from \"./care-package\";\nimport { spaceStoichiometry } from \"./space-stoichiometry\";\nimport { oxygenSystem } from \"./oxygen-system\";\nimport { flawedFrequencyTransmission } from \"./flawed-frequency-transmission\";\nimport { setAndForget } from \"./set-and-forget\";\nimport { manyWorldInterpretation } from \"./many-worlds-interpretation\";\nimport { tractorBeam } from \"./tractor-beam\";\nimport { donutMaze } from \"./donut-maze\";\nimport { springdroidAdventure } from \"./springroid-adventure\";\nimport { slamShuffle } from \"./slam-shuffle\";\nimport { categorySix } from \"./category-six\";\nimport { planetOfDiscord } from \"./planet-of-discord\";\nimport { cryostasis } from \"./cryostasis\";\n\nexport const entries = [\n        rocketTyranny,\n        programAlarm,\n        crossedWires,\n        secureContainer,\n        sunnyAsteroids,\n        universalObritMap,\n        amplificationCircuit,\n        spaceImageFormat,\n        sensorBoost,\n        monitoringStation,\n        spacePolice,\n        nBodyProblem,\n        carePackage,\n        spaceStoichiometry,\n        oxygenSystem,\n        flawedFrequencyTransmission,\n        setAndForget,\n        manyWorldInterpretation,\n        tractorBeam,\n        donutMaze,\n        springdroidAdventure,\n        slamShuffle,\n        categorySix,\n        planetOfDiscord,\n        cryostasis\n    ];\n","import { Coordinate, serialization } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause): IBinaryBoardingVisualizer => {\n    if (screenBuilder) {\n        return new RealVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\nexport interface IBinaryBoardingVisualizer {\n    setup(seats: number[]): Promise<void>;\n    setSeatOwned(seat: number): Promise<void>;\n\n}\n\nclass DummyVisualizer implements IBinaryBoardingVisualizer {\n    public async setup(seats: number[]): Promise<void> { }\n    public async setSeatOwned(seat: number): Promise<void> { }\n\n}\n\nconst constants = (() => {\n    const seatSize = {x: 10, y: 3};\n    const internalSpacing = {x: 6, y: 3};\n    const seatOffset = {x: seatSize.x + internalSpacing.x, y: seatSize.y + internalSpacing.y};\n    const columns = 8;\n    const expected = 1024;\n    const rows = expected / columns;\n\n    const screenSize = {\n        x: columns * seatOffset.x + internalSpacing.x,\n        y: rows * seatOffset.y + internalSpacing.y\n    };\n\n    return {\n        rows,\n        columns,\n        internalSpacing,\n        seatSize,\n        screenSize,\n        seatOffset\n    };\n})();\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nclass RealVisualizer implements IBinaryBoardingVisualizer {\n    private printer!: ScreenPrinter;\n    private readonly drawables: {[key: string]: LocalDrawable} = {};\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) { }\n\n    public async setup(seats: number[]): Promise<void> {\n        this.printer = await this.screenBuilder.requireScreen(constants.screenSize);\n        this.printer.setManualRender();\n\n        for (const seat of seats) {\n            const drawable = this.buildDrawable(seat);\n            this.drawables[serialization.serialize(drawable.c)] = drawable.d;\n        }\n\n        await this.printer.replace(Object.values(this.drawables));\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async setSeatOwned(seat: number): Promise<void> {\n        const coordinates = this.getCoordinates(seat);\n        const serialized = serialization.serialize(coordinates);\n        if (this.drawables[serialized]) {\n            this.drawables[serialized].color = \"red\";\n        } else {\n            const {d: drawable } = this.buildDrawable(seat);\n            drawable.color = \"red\";\n            this.drawables[serialized] = drawable;\n            this.printer.add(drawable);\n        }\n        await this.printer.forceRender();\n        await this.pause();\n    }\n\n    private getCoordinates(seat: number): Coordinate {\n        const coordinates = {\n            x: Math.floor(seat / constants.rows),\n            y: seat % constants.rows\n        };\n        return coordinates;\n    }\n\n    private buildDrawable(seat: number): {c: Coordinate, d: LocalDrawable} {\n        const coordinates = this.getCoordinates(seat);\n        const viewCoordinates = {\n            x: coordinates.x * constants.seatOffset.x + constants.internalSpacing.x,\n            y: coordinates.y * constants.seatOffset.y + constants.internalSpacing.y\n        };\n        return {\n            d: {\n                type: \"rectangle\",\n                c: viewCoordinates,\n                color: \"white\",\n                id: seat.toString(),\n                size: constants.seatSize\n            },\n            c: coordinates\n        };\n    }\n}\n","import { entryForFile } from \"../../../entry\";\nimport { buildVisualizer } from \"./visualizer\";\n\nexport const binaryBoarding = entryForFile(\n    async ({ lines, resultOutputCallback, pause, screen }) => {\n        const visualizer = buildVisualizer(screen, pause);\n        const boards = lines\n            .map((l) => l.split(\"\").map((e) => (e === \"B\" || e === \"R\") ? \"1\" : \"0\").join(\"\"))\n            .map((l) => parseInt(l, 2));\n        await visualizer.setup(boards);\n        const max = boards\n            .reduce((acc, next) => Math.max(acc, next));\n        await resultOutputCallback(max);\n    },\n    async ({ lines, resultOutputCallback, pause, screen }) => {\n        const visualizer = buildVisualizer(screen, pause);\n        const boards = lines\n            .map((l) => l.split(\"\").map((e) => (e === \"B\" || e === \"R\") ? \"1\" : \"0\").join(\"\"))\n            .map((l) => parseInt(l, 2))\n            .sort((a, b) => a - b);\n        await visualizer.setup(boards);\n        for (let i = 0; i < boards.length - 2; i++) {\n                if (boards[i] === boards[i + 1] - 2) {\n                    await visualizer.setSeatOwned(boards[i] + 1);\n                    await resultOutputCallback(boards[i] + 1);\n                    return;\n                }\n            }\n        await resultOutputCallback(\"Didn't find it :(\");\n    },\n    {\n        key: \"binary-boarding\",\n        title: \"Binary Boarding\",\n        stars: 2,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n","import { Passport, validFields } from \".\";\nimport { sumCoordinate } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nexport interface IPassportProcessingVisualizer {\n    setupPassports(passports: Passport[]): Promise<void>;\n    setWrongFields(passportIndex: number, fields: string[]): Promise<void>;\n    setValid(passportIndex: number): Promise<void>;\n}\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new PassportProcessingVisualizer(screenBuilder, pause);\n    }\n    return new DummyVisualizer();\n};\n\nclass DummyVisualizer implements IPassportProcessingVisualizer {\n    public async setValid(passportIndex: number): Promise<void> { }\n    public async setupPassports(passports: Passport[]): Promise<void> { }\n    public async setWrongFields(passportIndex: number, fields: string[]): Promise<void> { }\n\n}\n\nconst constants = (() => {\n    const fieldFullSize = {x: 10, y: 2};\n    const fieldColumns = 2;\n    const fieldRows = 4;\n    const padding = {x: 2, y: 2};\n    const internalSpacing = 2;\n    const externalSpacing = 4;\n    const passportSize = {\n        x: (fieldFullSize.x + internalSpacing) * fieldColumns + internalSpacing + padding.x * 2,\n        y: internalSpacing + (fieldFullSize.y + internalSpacing) * fieldRows + internalSpacing + padding.y * 2\n    };\n    const passportOffset = sumCoordinate(passportSize, {x: externalSpacing, y: externalSpacing});\n    const columns = 13;\n\n    return {\n        padding,\n        fieldRows,\n        internalSpacing,\n        externalSpacing,\n        fieldOffset: {x: fieldFullSize.x + internalSpacing, y: fieldFullSize.y + internalSpacing},\n        passportSize,\n        columns,\n        passportOffset,\n        screenWidth: passportOffset.x * columns + externalSpacing,\n        fieldFullSize,\n        heightCalculator(entries: number) {\n            return Math.ceil(entries / columns) * passportOffset.y + externalSpacing;\n        }\n    };\n\n})();\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nclass PassportProcessingVisualizer implements IPassportProcessingVisualizer {\n\n    private passportDrawables: Array<{main: LocalDrawable, fields: {[key: string]: LocalDrawable}}> = [];\n\n    private screenPrinter!: ScreenPrinter;\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) { }\n\n    public async setValid(passportIndex: number): Promise<void> {\n        this.passportDrawables[passportIndex].main.color = \"lime\";\n        this.screenPrinter.forceRender();\n        await this.pause();\n    }\n    public async setupPassports(passports: Passport[]): Promise<void> {\n        this.screenPrinter = await this.screenBuilder.requireScreen({\n            x: constants.screenWidth,\n            y: constants.heightCalculator(passports.length)\n        });\n        this.screenPrinter.setManualRender();\n        const perRow = Math.ceil(passports.length / constants.columns);\n        this.passportDrawables = passports.map((p, index) => {\n            const coordinates = {y: Math.floor(index / constants.columns), x: index % constants.columns};\n            const viewCoordinates = sumCoordinate({\n                x: constants.externalSpacing,\n                y: constants.externalSpacing\n            }, {\n                x: coordinates.x * constants.passportOffset.x,\n                y: coordinates.y * constants.passportOffset.y\n            });\n            const main: LocalDrawable = {\n                type: \"rectangle\",\n                color: \"white\",\n                id: \"passport-\" + index,\n                size: constants.passportSize,\n                c: viewCoordinates,\n            };\n            const fields: {[key: string]: LocalDrawable} = {};\n            for (let i = 0; i < validFields.length; i++) {\n                const fieldCoordinates = {x: Math.floor(i / constants.fieldRows), y: i % constants.fieldRows};\n                fields[validFields[i]] = {\n                    type: \"rectangle\",\n                    color: \"grey\",\n                    c: sumCoordinate({\n                        x: fieldCoordinates.x * constants.fieldOffset.x +\n                            constants.internalSpacing +\n                            constants.padding.x,\n                        y: fieldCoordinates.y * constants.fieldOffset.y +\n                            constants.internalSpacing +\n                            constants.padding.y\n                    }, viewCoordinates),\n                    id: `passport-${index}-field-${validFields[i]}`,\n                    size: constants.fieldFullSize\n                };\n            }\n            return {main, fields};\n        });\n\n        const drawables: Drawable[] = [];\n        for (const p of this.passportDrawables) {\n            drawables.push(p.main);\n            Object.values(p.fields).forEach((i) => drawables.push(i));\n        }\n        await this.screenPrinter.replace(drawables);\n        await this.pause();\n\n    }\n    public async setWrongFields(passportIndex: number, fields: string[]): Promise<void> {\n        const passport = this.passportDrawables[passportIndex];\n        passport.main.color = \"indianred\";\n        for (const field of fields) {\n            passport.fields[field].color = \"darkred\";\n        }\n        this.screenPrinter.forceRender();\n        await this.pause();\n    }\n}\n","import { entryForFile } from \"../../../entry\";\nimport { buildVisualizer } from \"./visualizer\";\n\nexport interface Passport {[key: string]: string; }\n\nexport const parseLines = (lines: string[]): Passport[] => {\n    const passports: Passport[] = [];\n    let currentPassport: Passport = {};\n    for (let line of lines) {\n        line = line.trim();\n        if (!line && Object.keys(currentPassport).length > 0) {\n            passports.push(currentPassport);\n            currentPassport = {};\n        } else {\n            const tokens = line.split(\" \").map((t) => t.trim().split(\":\"));\n            for (const [field, value] of tokens) {\n                currentPassport[field] = value;\n            }\n        }\n    }\n    if (Object.keys(currentPassport).length > 0) {\n        passports.push(currentPassport);\n    }\n    return passports;\n};\n\nexport const validFields = [\n    \"byr\",\n    \"iyr\",\n    \"eyr\",\n    \"hgt\",\n    \"hcl\",\n    \"ecl\",\n    \"pid\",\n    \"cid\"\n];\n\nconst hasPassportValidFields = (passport: Passport): boolean => {\n    const expectedKeys = new Set<string>(validFields.slice(0, validFields.length - 1));\n    for (const field of Object.keys(passport)) {\n        expectedKeys.delete(field);\n    }\n    return expectedKeys.size === 0;\n};\n\nconst getMissingFields = (passport: Passport): string[] => {\n    const expectedKeys = new Set<string>(validFields.slice(0, validFields.length - 1));\n    for (const field of Object.keys(passport)) {\n        expectedKeys.delete(field);\n    }\n    return [...expectedKeys.values()];\n};\n\nconst getInvalidFields = (passport: Passport): string[] => {\n    const missing = getMissingFields(passport);\n    const invalid = Object.keys(passport).filter((field) => !isValidField(field, passport[field]));\n    return missing.concat(invalid);\n};\n\nexport const isPassportValid = (passport: Passport): boolean => {\n    if (!hasPassportValidFields(passport)) {\n        return false;\n    }\n    for (const field of Object.keys(passport)) {\n        if (!isValidField(field, passport[field])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nexport const isValidField = (field: string, value: string): boolean => {\n        const hasFourDigits = () => value.length === 4;\n        const intValue = () => parseInt(value, 10);\n        switch (field) {\n            case \"byr\":\n                if (!hasFourDigits()) {\n                    return false;\n                }\n                if (intValue() < 1920 || intValue() > 2002) {\n                    return false;\n                }\n                break;\n\n            case \"iyr\":\n                if (!hasFourDigits() || intValue() < 2010 || intValue() > 2020) {\n                    return false;\n                }\n                break;\n            case \"eyr\":\n                if (!hasFourDigits() || intValue() < 2020 || intValue() > 2030) {\n                    return false;\n                }\n                break;\n            case \"hgt\":\n                const suffix = value.slice(-2);\n                const height = parseInt(value.slice(0, -2), 10);\n                if (height.toString() !== value.slice(0, -2)) {\n                    return false;\n                }\n                if (suffix === \"cm\") {\n                    if (height < 150 || height > 193) {\n                        return false;\n                    }\n                } else if (suffix === \"in\") {\n                    if (height < 59 || height > 76) {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n                break;\n\n            case \"hcl\":\n                if (!/^#[0-9a-f]{6}$/.test(value)) {\n                    return false;\n                }\n                break;\n            case \"ecl\":\n                const expectedEyes = [\n\"amb\", \"blu\", \"brn\", \"gry\", \"grn\", \"hzl\", \"oth\"\n                ];\n                if (!expectedEyes.includes(value)) {\n                    return false;\n                }\n                break;\n            case \"pid\":\n                if (!/^[0-9]{9}$/.test(value)) {\n                    console.log(value);\n                    return false;\n                }\n                break;\n            case \"cid\":\n                break;\n            default:\n                console.log(\"Invalid field\");\n                break;\n        }\n        return true;\n};\n\nexport const passportProcessing = entryForFile(\n    async ({\n        lines,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const passports = parseLines(lines);\n        await visualizer.setupPassports(passports);\n        let validPassports = 0;\n        for (let i = 0; i < passports.length; i++) {\n            const passport = passports[i];\n            const missing = getMissingFields(passport);\n            if (missing.length > 0) {\n                await visualizer.setWrongFields(i, missing);\n            } else {\n                await visualizer.setValid(i);\n                validPassports++;\n            }\n        }\n        await resultOutputCallback(validPassports);\n    },\n    async ({\n        lines,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const passports = parseLines(lines);\n        await visualizer.setupPassports(passports);\n        let validPassports = 0;\n        for (let i = 0; i < passports.length; i++) {\n            const passport = passports[i];\n            const missing = getInvalidFields(passport);\n            if (missing.length > 0) {\n                await visualizer.setWrongFields(i, missing);\n            } else {\n                await visualizer.setValid(i);\n                validPassports++;\n            }\n        }\n        await resultOutputCallback(validPassports);\n    },\n    {\n        key: \"passport-processing\",\n        title: \"Passport Processing\",\n        stars: 2,\n        customComponent: \"pause-and-run\",\n        suggestedDelay: 20,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n\n/*\n8:39\nOk, let's start today, I've done the scaffolding and read the puzzle.\nThe first part seems easy, let's see if it is so\n\n11 minutes later...\nFirst part done at the first try, the parsing went pretty smooth and it was pretty fun,\nlet's see about the second\n\n1 hour later...\nOk, turns out I hated the second part. I did a stupid error with regexes (wasn't there\nsomething about trying to solve one problem with regexes and having two problems as a\nconsequence?), I tried to validate the passport with /[0-9]{6}/, when of course I\nshould have used /^[0-9]{6}$/.\nHaving one extra valid passport meant I had no clue about what rule was failing,\nand that meant double checking all the rules; when I found no issue, I started writing\ntests. Luckily, my case was covered in the test cases given in the examples; at the\nsame time, it was the last example, so it took some time. In any case, it's done,\nlet's forget about this one, shall we?\n*/\n","import { Coordinate } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nconst constantsBuilder = ((expectedPasswords: number) => {\n    const padding = 10;\n\n    const columns = 12;\n    const spacing = 2;\n    const lineHeight = 4;\n    const passwordsPerColumn = expectedPasswords / columns;\n\n    const screenSize = {\n        x: 600 + padding * 2,\n        y: padding * 2 + passwordsPerColumn * (lineHeight + spacing) + padding * 2\n    };\n\n    const indicatorSize = lineHeight;\n    const columnLength = (screenSize.x - padding * 2) / columns;\n    return {\n        screenSize,\n        spacing,\n        lineHeight,\n        indicatorSize,\n        columns,\n        padding,\n        passwordsPerColumn,\n        columnLength,\n        lineMaxLength: columnLength - padding - spacing - indicatorSize,\n    };\n});\nexport const buildVisualizer = async (\n    screenBuilder: ScreenBuilder | undefined,\n    pause: Pause\n): Promise<IPasswordPhilosophyVisualizer> =>\n    screenBuilder ? new PasswordPhilosophyVisualizer(screenBuilder, pause) : new DummyPasswordPhilosophyVisualizer();\n\nexport interface IPasswordPhilosophyVisualizer {\n    setupPasswords(passwords: string[]): Promise<void>;\n    colorPassword(passwordIndex: number, indexes: number[], isValid: boolean): Promise<void>;\n}\nclass PasswordPhilosophyVisualizer implements IPasswordPhilosophyVisualizer {\n    private passwords: Array<Drawable & {type: \"rectangle\"}> = [];\n    private indicators: Drawable[] = [];\n    private letterSize: number = 0;\n    private constants?: ReturnType<typeof constantsBuilder>;\n    private printer?: ScreenPrinter;\n    constructor(private screenBuilder: ScreenBuilder, private pause: Pause) {\n    }\n\n    public async setupPasswords(passwords: string[]): Promise<void> {\n        this.constants = constantsBuilder(passwords.length);\n        await this.buildScreen();\n        if (this.printer) {\n            const maxLength = passwords.reduce((acc, next) => Math.max(acc, next.length), 0);\n            this.letterSize = this.constants.lineMaxLength / maxLength;\n            this.passwords = passwords.map((password, i) => {\n                const columnIndex = Math.floor(i / this.constants!.passwordsPerColumn);\n                const rowIndex = Math.floor(i % this.constants!.passwordsPerColumn);\n                return {\n                    color: \"white\",\n                    id: i.toString(),\n                    type: \"rectangle\",\n                    c: {\n                        x: this.constants!.padding +\n                            columnIndex * this.constants!.columnLength,\n                        y: rowIndex * (this.constants!.lineHeight + this.constants!.spacing) +\n                            this.constants!.padding\n                    },\n                    size: {\n                        x: this.constants!.lineMaxLength * (password.length / maxLength),\n                        y: this.constants!.lineHeight\n                    }\n                };\n            });\n            this.indicators = passwords.map((password, i) => {\n                const columnIndex = Math.floor(i / this.constants!.passwordsPerColumn);\n                const rowIndex = Math.floor(i % this.constants!.passwordsPerColumn);\n                return {\n                    color: \"white\",\n                    id: i.toString() + \"-indicator\",\n                    type: \"rectangle\",\n                    c: {\n                        x: this.constants!.padding +\n                            (columnIndex + 1) * this.constants!.columnLength -\n                            this.constants!.padding - this.constants!.indicatorSize,\n                        y: rowIndex * (this.constants!.lineHeight + this.constants!.spacing) +\n                            this.constants!.padding\n                        },\n                    size: {x: this.constants!.indicatorSize, y: this.constants!.lineHeight}\n                };\n\n            });\n            const drawables = (this.passwords as Drawable[]).concat(this.indicators);\n            this.printer.replace(drawables);\n            await this.pause(5);\n        }\n    }\n    public async colorPassword(passwordIndex: number, indexes: number[], isValid: boolean): Promise<void> {\n        if (this.printer) {\n            const drawablePassword = this.passwords[passwordIndex];\n            const selectedLetters: Drawable[] = indexes.map((index) => {\n                return {\n                    type: \"rectangle\",\n                    c: {x: drawablePassword.c.x + index * this.letterSize, y: drawablePassword.c.y },\n                    color: isValid ? \"lime\" : \"red\",\n                    id: `${drawablePassword.id}-letter-${index}`,\n                    size: {x: this.letterSize, y: drawablePassword.size.y}\n                };\n            });\n            for (const letter of selectedLetters) {\n                this.printer.add(letter);\n            }\n            this.indicators[passwordIndex].color = isValid ? \"lime\" : \"red\";\n            await this.pause();\n        }\n    }\n\n    private async buildScreen() {\n        if (this.constants) {\n            this.printer = await this.screenBuilder.requireScreen(this.constants.screenSize);\n        }\n    }\n}\n\nclass DummyPasswordPhilosophyVisualizer implements IPasswordPhilosophyVisualizer {\n    public async setupPasswords(passwords: string[]): Promise<void> {\n    }\n    public async colorPassword(passwordIndex: number, indexes: number[], isValid: boolean): Promise<void> {\n    }\n\n}\n","/*\n8:46\nAlright, let's start this.\n\nSo, the password validation puzzles are back. I haven't actually enjoyed these too much in the previous years,\nbut we're still at the second day, nothing exciting expected.\nI decided yesterday to try and do visualizations for each day, but I'm actually not sure\nwhat I could do here, I'll think about it later.\n\n8:54\nOk, first star done, easy as expected, I think that I've done it in about 6 minutes after the scaffolding.\n\n9:00\nAnd done. I did a stupid error (adding 1 instead of subtracting 1 to the index), losing a lot of time. That's it for the\nproblem solving part, not much to optimize here, I'll try and think of a visualization later on\n*/\n\ninterface PasswordLine {\n    password: string;\n    minRepetitions: number;\n    maxRepetitions: number;\n    letter: string;\n}\n\nconst parseLines = (lines: string[]): PasswordLine[] =>\n    lines.map((line) => {\n        const [header, password] = line.split(\": \");\n        const [repetitions, letter] = header.split(\" \");\n        const [minRepetitions, maxRepetitions] = repetitions.split(\"-\").map((e) => parseInt(e, 10));\n        return {\n            letter,\n            minRepetitions,\n            maxRepetitions,\n            password\n        };\n    });\n\ntype PasswordChecker = (passwordLine: PasswordLine) => [boolean, number[]];\n\nconst isLineValid: PasswordChecker = (passwordLine) => {\n    const repetitions = passwordLine\n        .password\n        .split(\"\")\n        .map((e, i) => ({e, i}))\n        .filter((e) => e.e === passwordLine.letter);\n    const isValid =\n        repetitions.length <= passwordLine.maxRepetitions &&\n        repetitions.length >= passwordLine.minRepetitions;\n    return [isValid, repetitions.map((e) => e.i)];\n};\n\nconst isLineReallyValid: PasswordChecker = (passwordLine) => {\n    const targetIndexes = [passwordLine.minRepetitions, passwordLine.maxRepetitions]\n        .map((e) => e - 1);\n    const targets = targetIndexes\n        .map((e) => passwordLine.password[e]);\n    const matching = targets.filter((e) => e === passwordLine.letter).length;\n    return [matching === 1, targetIndexes];\n};\n\nimport { entryForFile, Pause, ScreenBuilder } from \"../../../entry\";\nimport { buildVisualizer } from \"./visualizer\";\n\nexport const passwordPhilosophy = entryForFile(\n    async ({ lines, resultOutputCallback, screen, pause }) => {\n        await runEntry(screen, pause, lines, isLineValid, resultOutputCallback);\n    },\n    async ({ lines, resultOutputCallback, screen, pause }) => {\n        await runEntry(screen, pause, lines, isLineReallyValid, resultOutputCallback);\n    },\n    {\n        key: \"password-philosophy\",\n        title: \"Password Philosophy\",\n        customComponent: \"pause-and-run\",\n        stars: 2,\n        suggestedDelay: 20,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n\nasync function runEntry(\n    screen: ScreenBuilder | undefined,\n    pause: Pause,\n    lines: string[],\n    passwordChecker: PasswordChecker,\n    outputCallback: (outputLine: any) => Promise<void>) {\n    const visualizer = await buildVisualizer(screen, pause);\n    const passwordLines = parseLines(lines);\n    await visualizer.setupPasswords(passwordLines.map((l) => l.password));\n\n    let satisfied = 0;\n    for (let i = 0; i < passwordLines.length; i++) {\n        const line = passwordLines[i];\n        const [isValid, indexes] = passwordChecker(line);\n        await visualizer.colorPassword(i, indexes, isValid);\n        if (isValid) {\n            satisfied++;\n        }\n    }\n    await outputCallback(satisfied);\n}\n","import { getCoordinateForGrid, multiplyCoordinate, sumCoordinate } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nconst constants = (() => {\n    const columns = 10;\n\n    const letterColumns = 2;\n    const letterRows = 13;\n\n    const letterSpacing = {x: 4, y: 2};\n    const letterSize = {x: 8, y: 4};\n    const letterOffset = sumCoordinate(letterSpacing, letterSize);\n\n    const groupSpacing = {\n        x: 4,\n        y: 4\n    };\n    const groupSize = {\n        x: letterSpacing.x + letterColumns * letterOffset.x,\n        y: letterSpacing.y + letterRows * letterOffset.y\n    };\n\n    const groupOffset = sumCoordinate(groupSize, groupSpacing);\n\n    return {\n        columns,\n        groupSize,\n        groupSpacing,\n        groupOffset,\n        letterSize,\n        letterOffset,\n        letterSpacing,\n        letterRows,\n        rows: 1,\n        screenSizeBuilder(entries: number) {\n            return {\n                x: columns * groupOffset.x + groupSpacing.x,\n                y: 1 * groupOffset.y + groupSpacing.y\n            };\n        }\n    };\n})();\nexport interface ICustomCustomsVisualizer {\n    setup(groups: number): Promise<void>;\n    addLetter(group: number, letter: string): Promise<void>;\n    setLetters(group: number, letters: Iterable<string>): Promise<void>;\n    startGroup(group: number): Promise<void>;\n    endGroup(group: number): Promise<void>;\n}\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new RealVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nconst clear = \"slategray\";\nconst ok = \"lime\";\n\nclass RealVisualizer implements ICustomCustomsVisualizer {\n    private printer!: ScreenPrinter;\n    private drawables: Array<{main: LocalDrawable; letters: LocalDrawable[]}> = [];\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) {\n    }\n    public async setLetters(group: number, letters: Iterable<string>): Promise<void> {\n        this.clearLetters(group);\n        for (const letter of letters) {\n            this.drawables[this.getGroupIndex(group)].letters[this.getIndex(letter)].color = ok;\n        }\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async startGroup(group: number): Promise<void> {\n        const index = this.getGroupIndex(group);\n        this.clearPreviousLetters(index);\n    }\n    public async endGroup(group: number): Promise<void> {\n    }\n    public async setup(groups: number): Promise<void> {\n        const screenSize = constants.screenSizeBuilder(groups);\n        this.printer = await this.screenBuilder.requireScreen(screenSize);\n        this.printer.setManualRender();\n        for (let i = 0; i < constants.columns; i++) {\n            const coordinates = {\n                x: i,\n                y: 0\n            };\n            const viewCoordinates = {\n                x: constants.groupSpacing.x + constants.groupOffset.x * coordinates.x,\n                y: constants.groupSpacing.y + constants.groupOffset.y * coordinates.y\n            };\n            this.drawables.push({\n                main: {\n                    type: \"rectangle\",\n                    color: \"white\",\n                    id: \"main-\" + i.toString(),\n                    size: constants.groupSize,\n                    c: viewCoordinates\n                },\n                letters: [...Array(26).keys()].map((iLetter) => {\n                    const letterCoordinates = getCoordinateForGrid(iLetter, constants.letterRows);\n                    const letterViewCoordinates =\n                        sumCoordinate(\n                            sumCoordinate(\n                                multiplyCoordinate(\n                                    letterCoordinates,\n                                    constants.letterOffset\n                                ),\n                                viewCoordinates)\n                            ,\n                            constants.letterSpacing\n                        );\n                    return {\n                        type: \"rectangle\",\n                        size: constants.letterSize,\n                        c: letterViewCoordinates,\n                        color: clear,\n                        id: `${i}-${iLetter}`\n                    };\n                })\n            });\n        }\n        const totalDrawables = this.drawables.flatMap((d) => [\n            d.main\n        ].concat(d.letters));\n        await this.printer.replace(totalDrawables);\n        this.printer.forceRender();\n        await this.pause();\n    }\n    public async addLetter(group: number, letter: string): Promise<void> {\n        this.drawables[this.getGroupIndex(group)].letters[this.getIndex(letter)].color = ok;\n        this.printer.forceRender();\n        await this.pause();\n    }\n    private getGroupIndex(group: number) {\n        return group % constants.columns;\n\n    }\n    private clearPreviousLetters(i: number) {\n        const previous = [1].map((k) => i + constants.columns + k).map((e) => e % constants.columns);\n        for (const p of previous) {\n            this.clearLetters(p);\n        }\n    }\n\n    private clearLetters(p: number) {\n        this.drawables[this.getGroupIndex(p)].letters.forEach((l) => l.color = clear);\n    }\n    private getIndex(letter: string): number {\n        return letter.charCodeAt(0) - \"a\".charCodeAt(0);\n    }\n}\n\nclass DummyVisualizer implements ICustomCustomsVisualizer {\n    public async setLetters(group: number, letters: Iterable<string>): Promise<void> { }\n    public async startGroup(group: number): Promise<void> { }\n    public async endGroup(group: number): Promise<void> { }\n    public async setup(groups: number): Promise<void> { }\n    public async addLetter(group: number, letter: string): Promise<void> { }\n\n}\n","import wu from \"wu\";\nimport { buildGroupsFromSeparator } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\nimport { buildVisualizer } from \"./visualizer\";\nconst intersect = <T>(a: Set<T>, b: Set<T>): Set<T> => {\n    const result = new Set<T>();\n    for (const e of a) {\n        if (b.has(e)) {\n            result.add(e);\n        }\n    }\n    return result;\n};\n\nconst buildAnswers = (line: string, set?: Set<string> | undefined): Set<string> => {\n    if (set === undefined) {\n        set = new Set<string>();\n    }\n    line.split(\"\").forEach((l) => set!.add(l));\n    return set;\n};\n\nexport const customCustoms = entryForFile(\n    async ({\n        lines,\n        resultOutputCallback,\n        setAutoStop,\n        pause,\n        screen\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const groups = [...buildGroupsFromSeparator(lines, (l) => l.length === 0)];\n        await visualizer.setup(groups.length);\n        let total = 0;\n        for (let i = 0; i < groups.length; i++) {\n            await visualizer.startGroup(i);\n            const group = groups[i];\n            const answers = group.reduce((acc, next) => buildAnswers(next, acc), new Set<string>());\n            for (const letter of answers) {\n                await visualizer.addLetter(i, letter);\n            }\n            await visualizer.endGroup(i);\n            total += answers.size;\n        }\n        await resultOutputCallback(total);\n    },\n    async ({\n        lines,\n        resultOutputCallback,\n        setAutoStop,\n        screen,\n        pause\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const groups = [...buildGroupsFromSeparator(lines, (l) => l.length === 0)];\n        await visualizer.setup(groups.length);\n\n        let total = 0;\n        for (let i = 0; i < groups.length; i++) {\n            const group = groups[i];\n            await visualizer.startGroup(i);\n            let answers: Set<string> | undefined;\n            for (const line of group) {\n                if (answers === undefined) {\n                    answers = buildAnswers(line);\n                } else {\n                    answers = intersect(answers, buildAnswers(line));\n                }\n                await visualizer.setLetters(i, answers);\n            }\n            if (answers) {\n                total += answers.size;\n            }\n        }\n\n        await resultOutputCallback(total);\n    },\n    {\n        key: \"custom-customs\",\n        title: \"Custom Customs\",\n        stars: 2,\n        suggestedDelay: 10,\n        customComponent: \"pause-and-run\",\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n","import { Coordinate } from \"../../../../support/geometry\";\nimport { Drawable, ScreenBuilder } from \"../../../entry\";\n\nexport type VisualizationStatus = \"discarded\" | \"current\" | \"normal\" | \"found\" | \"dead\" | \"candidate\";\nexport interface VisualizeInstruction {status: VisualizationStatus; index: number; maxOrMin?: \"max\" | \"min\"; }\nexport type Visualizer = (...data: VisualizeInstruction[]) => Promise<void>;\n\n\nexport async function updateVisualizerFound(i: number, j: number, visualizer: Visualizer | undefined) {\n    if (i < j && visualizer) {\n        await visualizer({ status: \"found\", index: i }, { status: \"found\", index: j });\n    }\n}\n\nexport async function updateVisualizerCurrent(\n    visualizer: Visualizer | undefined,\n    i: number, visualizerIndex: number,\n    maxOrMin: \"max\" | \"min\"\n) {\n    if (visualizer) {\n        await visualizer({ status: \"discarded\", index: i }, { status: \"current\", index: visualizerIndex, maxOrMin });\n    }\n}\n\nexport async function seedVisualizer(visualizer: Visualizer | undefined, i: number, j: number) {\n    if (visualizer) {\n        const seedInstructions: VisualizeInstruction[] = [];\n        for (let k = i; k <= j; k++) {\n            seedInstructions.push({ status: k === i || k === j ? \"current\" : \"normal\", index: k, maxOrMin: i === k ? \"min\" : \"max\" });\n        }\n        await visualizer(...seedInstructions);\n    }\n}\n\nexport async function buildVisualizer(\n    screen: ScreenBuilder | undefined,\n    ns: number[],\n    start: number,\n    pause: () => Promise<void>\n) {\n    const cellWidth = 2;\n    const screenWidth = ns.length * cellWidth * 2 + 20;\n    const maxHeight = 120;\n    const indicatorHeight = 20;\n    const screenHeight = maxHeight + indicatorHeight + 10;\n    const xCalculator = (index: number) => index * cellWidth * 2 + 10;\n\n    return await (screen ? async () => {\n        const mapColor = (status: VisualizationStatus): string => {\n            switch (status) {\n                case \"current\":\n                    return \"yellow\";\n                case \"discarded\":\n                    return \"red\";\n                case \"found\":\n                    return \"lime\";\n                case \"normal\":\n                    return \"white\";\n                case \"dead\":\n                    return \"black\";\n                case \"candidate\":\n                    return \"cyan\";\n            }\n        };\n        const screenPrinter = await screen.requireScreen({ x: screenWidth, y: screenHeight });\n        const drawables: Drawable[] = [];\n        const maxValue = ns[ns.length - 1];\n        for (let i = 0; i < ns.length; i++) {\n            const value = ns[i];\n            const height = (value / maxValue) * maxHeight;\n            drawables.push({\n                c: { x: xCalculator(i), y: indicatorHeight + (maxHeight - height) + 10 },\n                color: mapColor(\"normal\"),\n                id: i.toString(),\n                type: \"rectangle\",\n                size: { x: cellWidth, y: height }\n            });\n        }\n        const minCurrent: Drawable = {\n            c: { x: xCalculator(start), y: 0 },\n            color: mapColor(\"current\"),\n            id: \"minCurrent\",\n            type: \"rectangle\",\n            size: { x: cellWidth, y: indicatorHeight }\n        };\n        const maxCurrent: Drawable = {\n            c: { x: xCalculator(ns.length - 1), y: 0 },\n            color: mapColor(\"current\"),\n            id: \"maxCurrent\",\n            type: \"rectangle\",\n            size: { x: cellWidth, y: indicatorHeight }\n        };\n        const candidateCoordinates: Coordinate = {x: -4, y: 0};\n        const candidate: Drawable = {\n            c: candidateCoordinates,\n            color: mapColor(\"candidate\"),\n            id: \"candidate\",\n            type: \"rectangle\",\n            size: { x: cellWidth, y: indicatorHeight }\n        };\n        drawables.push(minCurrent);\n        drawables.push(maxCurrent);\n        await screenPrinter.replace(drawables);\n        return async (...data: VisualizeInstruction[]) => {\n            for (const instruction of data) {\n                if (instruction.index >= 0 && instruction.index < drawables.length) {\n                    drawables[instruction.index].color = mapColor(instruction.status);\n                    const newX = xCalculator(instruction.index);\n                    if (instruction.status === \"current\") {\n                        if (instruction.maxOrMin === \"max\") {\n                            maxCurrent.c.x = newX;\n                        } else {\n                            minCurrent.c.x = newX;\n                        }\n                    } else if (instruction.status === \"candidate\") {\n                        if (candidateCoordinates.x < 0) {\n                            screenPrinter.add(candidate);\n                        }\n                        candidateCoordinates.x = newX;\n                    }\n                }\n            }\n            await pause();\n        };\n    } : async () => undefined)();\n}\n\nexport async function updateDeadCandidateVisualizer(visualizer: Visualizer | undefined, i: number) {\n    if (visualizer) {\n        const toVisualize: VisualizeInstruction[] = [{ status: \"candidate\", index: i }];\n        if (i > 0) {\n            toVisualize.push({ status: \"dead\", index: i - 1 });\n        }\n        await visualizer(...toVisualize);\n    }\n}\n","import { entryForFile } from \"../../../entry\";\nimport {\n    buildVisualizer,\n    seedVisualizer,\n    updateDeadCandidateVisualizer,\n    updateVisualizerCurrent,\n    updateVisualizerFound,\n    Visualizer\n} from \"./visualizer\";\n\nconst findProd = async (\n    ns: number[],\n    target: number,\n    startFrom: number = 0,\n    visualizer?: Visualizer\n): Promise<number | null> => {\n    let i = startFrom;\n    let j = ns.length - 1;\n    await seedVisualizer(visualizer, i, j);\n    while (ns[i] + ns[j] !== target && i < j) {\n        if (ns[i] + ns[j] > target) {\n            await updateVisualizerCurrent(visualizer, j, j - 1, \"max\");\n            j--;\n        } else {\n            await updateVisualizerCurrent(visualizer, i, i + 1, \"min\");\n            i++;\n        }\n    }\n    await updateVisualizerFound(i, j, visualizer);\n    return i < j ? ns[i] * ns[j] : null;\n};\n\nexport const reportRepair = entryForFile(\n    async ({\n        lines,\n        outputCallback,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const ns = lines.map((line) => parseInt(line, 10)).sort((a, b) => a - b);\n        console.log(ns);\n        const visualizer = await buildVisualizer(screen, ns, 0, pause);\n        const result = await findProd(ns, 2020, 0, visualizer);\n        await resultOutputCallback(result || \"Not found :(\");\n    },\n    async ({\n        lines,\n        outputCallback,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const ns = lines.map((line) => parseInt(line, 10)).sort((a, b) => a - b);\n        const visualizer = await buildVisualizer(screen, ns, 1, pause);\n        for (let i = 0; i < ns.length; i++) {\n            await updateDeadCandidateVisualizer(visualizer, i);\n            const result = await findProd(ns, 2020 - ns[i], i + 1, visualizer);\n            if (result) {\n                await resultOutputCallback(result * ns[i]);\n                return;\n            }\n        }\n        await outputCallback(\"Not found :(\");\n\n    },\n    {\n        key: \"report-repair\",\n        title: \"Report Repair\",\n        customComponent: \"pause-and-run\",\n        stars: 2 ,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n","import { Coordinate, scalarCoordinates, serialization } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nexport interface ITobogganTrajectoryVisualizer {\n    setupField(grid: string[][], size: Coordinate): Promise<void>;\n    moveToboggan(position: Coordinate, collides: boolean): Promise<void>;\n    resetField(): Promise<void>;\n}\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new TobogganVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\nconst constants = {\n    cellSize: 2,\n    fullCellSize: {x: 2, y: 2}\n};\n\ninterface Dictionary<T> { [key: string]: T; }\n\nclass TobogganVisualizer implements ITobogganTrajectoryVisualizer {\n    private screen!: ScreenPrinter;\n    private readonly trees: Dictionary<Drawable & {type: \"rectangle\"}> = {};\n    private readonly player: Drawable & {type: \"rectangle\"} = {\n        type: \"rectangle\",\n        id: \"player\",\n        color: \"white\",\n        size: constants.fullCellSize,\n        c: {x: 0, y: 0}\n    };\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) { }\n\n    public async setupField(grid: string[][], size: Coordinate): Promise<void> {\n        this.screen = await this.screenBuilder.requireScreen(scalarCoordinates(size, constants.cellSize));\n        for (let x = 0; x < size.x; x++) {\n            for (let y = 0; y < size.y; y++) {\n                if (grid[y][x] === \"#\") {\n                    this.trees[serialization.serialize({x, y})] = {\n                        type: \"rectangle\",\n                        c: scalarCoordinates({x, y}, constants.cellSize),\n                        id: serialization.serialize({x, y}),\n                        color: \"lime\",\n                        size: constants.fullCellSize\n                    };\n                }\n            }\n        }\n        this.screen.replace(Object.values(this.trees));\n        this.screen.add(this.player);\n        await this.pause();\n    }\n    public async resetField() {\n        for (const tree of Object.values(this.trees)) {\n            tree.color = \"lime\";\n        }\n        this.player.c = {x: 0, y: 0};\n        await this.pause();\n    }\n    public async moveToboggan(position: Coordinate, collides: boolean): Promise<void> {\n        this.player.c = scalarCoordinates(position, constants.cellSize);\n        if (collides) {\n            this.trees[serialization.serialize(position)].color = \"red\";\n        }\n        await this.pause();\n    }\n\n}\n\nclass DummyVisualizer implements ITobogganTrajectoryVisualizer {\n    public async setupField(grid: string[][]): Promise<void> {\n    }\n    public async moveToboggan(position: Coordinate, collides: boolean): Promise<void> {\n    }\n    public async resetField() {\n    }\n\n}\n","import { CCoordinate, Coordinate } from \"../../../../support/geometry\";\nimport { entryForFile } from \"../../../entry\";\nimport { buildVisualizer } from \"./visualizer\";\n\nconst parseLines = (lines: string[]): {grid: string[][], size: Coordinate} => {\n    const height = lines.length;\n    const width = lines[0].length;\n    return {grid: lines.map((line) => line.split(\"\")), size: {x: width, y: height}};\n};\n\nexport const tobogganTrajectory = entryForFile(\n    async ({ lines, resultOutputCallback, pause, screen, setAutoStop }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const {grid, size} = parseLines(lines);\n        await visualizer.setupField(grid, size);\n        const slope = new CCoordinate(3, 1);\n        let currentCoordinate = {x: 0, y: 0};\n        let trees = 0;\n        while (currentCoordinate.y < size.y) {\n            const collides = grid[currentCoordinate.y][currentCoordinate.x] === \"#\";\n            if (collides) {\n                trees++;\n            }\n            await visualizer.moveToboggan(currentCoordinate, collides);\n            currentCoordinate = slope.sum(currentCoordinate);\n            currentCoordinate.x %= size.x;\n        }\n        await resultOutputCallback(trees);\n    },\n    async ({ lines, resultOutputCallback, pause, screen, setAutoStop}) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const {grid, size} = parseLines(lines);\n        await visualizer.setupField(grid, size);\n        const candidateSlopes = [\n            {x: 1, y: 1},\n            {x: 3, y: 1},\n            {x: 5, y: 1},\n            {x: 7, y: 1},\n            {x: 1, y: 2}\n        ].map((s) => new CCoordinate(s.x, s.y));\n        let result = 1;\n        for (const slope of candidateSlopes) {\n            await visualizer.resetField();\n            let currentCoordinate = {x: 0, y: 0};\n            let trees = 0;\n            while (currentCoordinate.y < size.y) {\n                const collides = grid[currentCoordinate.y][currentCoordinate.x] === \"#\";\n                if (collides) {\n                    trees++;\n                }\n                await visualizer.moveToboggan(currentCoordinate, collides);\n                currentCoordinate = slope.sum(currentCoordinate);\n                currentCoordinate.x %= size.x;\n            }\n            result *= trees;\n        }\n        await resultOutputCallback(result);\n    },\n    {\n        key: \"toboggan-trajectory\",\n        title: \"Toboggan Trajectory\",\n        stars: 2,\n        customComponent: \"pause-and-run\",\n        suggestedDelay: 50,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n\n/*\n    8:38\n    Ok, let's start\n    8:39\n    Nice! I like this one, it seems I can do some interesting visualizations later on.\n    I'll probably use my field for the second part, but let's do it more simply for the first\n    8:46\n    Ok, first part done, let's see the second one\n    8:50\n    Way easier than expected, no field necessary.\n    I remembered the third days to be more difficult! So, 12 minutes, would I have been able to\n    get in the leaderboard? ... Of course not,\n    00:04:56 is the slowest time. Ok, that's it for now, I'll try some visualizations\n    later\n*/\n","import { DefaultListDictionaryString, Queue } from \"../../../../support/data-structure\";\nimport { entryForFile } from \"../../../entry\";\n\ninterface BagRule {\n    color: string;\n    contains?: Array<{quantity: number; color: string}>;\n}\n\nconst parseContainingBags = (line: string): Array<{quantity: number; color: string}> => {\n    const startFrom = line.indexOf(\"contain\") + \"contain\".length;\n    line = line.slice(startFrom).trim();\n    const bags = line\n        .replace(\".\", \"\")\n        .split(\", \")\n        .map((l) => l.split(\" \"))\n        .map((l) => {\n            const quantity = parseInt(l[0], 10);\n            const color = l.slice(1, 3).join(\" \");\n            return {\n                quantity,\n                color\n            };\n        });\n    return bags;\n};\n\nconst parseLines = (lines: string[]): BagRule[] => {\n    return lines.map((line) => {\n        const splitIndex = line.indexOf(\"bags\");\n        const mainColor = line.slice(0, splitIndex).trim();\n        const isEmpty = line.indexOf(\"contain no\") >= 0;\n        return {\n            color: mainColor,\n            contains: isEmpty ? undefined : parseContainingBags(line)\n        };\n    });\n};\n\nconst toString = (bagRules: BagRule[]): string => {\n    return bagRules\n        .map((b) => `${b.color} bags contain ${b.contains ?\n            b.contains.map((e) => `${e.quantity} ${e.color} bag${e.quantity > 1 ? \"s\" : \"\"}`).join(\",\")\n            : \"no other bags\"}.`)\n        .join(\"\\n\");\n};\n\nexport const handyHaversacks = entryForFile(\n    async ({ lines, resultOutputCallback: resultOutputcallback }) => {\n        const reverseRules = new DefaultListDictionaryString<string>();\n        const rules = parseLines(lines);\n        for (const rule of rules) {\n            if (rule.contains) {\n                for (const target of rule.contains) {\n                    reverseRules.add(target.color, rule.color);\n                }\n            }\n        }\n        const results: Set<string> = new Set<string>();\n        const mainTarget = \"shiny gold\";\n        const toExplore = new Queue<string>();\n        toExplore.add(mainTarget);\n        while (!toExplore.isEmpty) {\n            const newCandidates = reverseRules.get(toExplore.get()!);\n            for (const candidate of newCandidates) {\n                if (!results.has(candidate)) {\n                    if (candidate === mainTarget) {\n                        throw new Error(\"Unexpected\");\n                    }\n                    results.add(candidate);\n                    toExplore.add(candidate);\n                }\n            }\n        }\n\n        await resultOutputcallback(results.size);\n    },\n    async ({ lines, resultOutputCallback }) => {\n        const rules = parseLines(lines);\n        const directRules: {[key: string]: Array<{quantity: number; color: string}>} = {};\n        for (const rule of rules) {\n            directRules[rule.color] = rule.contains || [];\n        }\n        const result: Array<{quantity: number; color: string}> = [];\n        const toExplore = new Queue<{quantity: number; color: string}>();\n        toExplore.add({quantity: 1, color: \"shiny gold\"});\n        while (true) {\n            const current = toExplore.get();\n            if (!current) {\n                break;\n            }\n            const hasToHave = directRules[current.color];\n            for (const nested of hasToHave) {\n                const nestedQuantity = nested.quantity * current.quantity;\n                result.push({quantity: nestedQuantity, color: nested.color});\n                toExplore.add({quantity: nestedQuantity, color: nested.color});\n            }\n        }\n\n        const output = result.reduce((acc, next) => acc + next.quantity, 0);\n        await resultOutputCallback(output);\n    },\n    {\n        key: \"handy-haversacks\",\n        title: \"Handy Haversacks\",\n        stars: 2,\n        supportsQuickRunning: true,\n        embeddedData: true\n    }\n);\n","type Interceptor = (state: State, beforeOrAfter: \"before\" | \"after\", instruction: number) => Promise<boolean>;\ntype InstructionChanger = (currentInstruction: number) => Promise<Instruction>;\nexport type Program = Instruction[];\nexport class HandheldProgram {\n\n    public get length() {\n        return this.program.length;\n    }\n    public program: Program;\n\n    private interceptor?: Interceptor;\n    private instructionChanger?: InstructionChanger;\n    constructor(program: string[] | Program) {\n        if (program.length === 0) {\n            this.program = [];\n        } else if (typeof program[0] === \"string\") {\n            this.program = parseProgram(program as string[]);\n        } else {\n            this.program = program as Program;\n        }\n    }\n\n    public setInterceptor(interceptor: Interceptor) {\n        this.interceptor = interceptor;\n        return this;\n    }\n\n    public setInstructionChanger(changeInstruction?: InstructionChanger) {\n        this.instructionChanger = changeInstruction;\n        return this;\n    }\n\n    public async execute(startState?: State): Promise<State> {\n        const state = startState ? {...startState} : emptyState();\n        while (true) {\n            const nextInstructionIndex = state.currentInstruction;\n            const nextInstruction = (this.instructionChanger) ?\n                    await this.instructionChanger(nextInstructionIndex) :\n                        this.program[nextInstructionIndex];\n            if (this.interceptor) {\n                const shouldContinue = await this.interceptor(state, \"before\", nextInstructionIndex);\n                if (!shouldContinue) {\n                    break;\n                }\n            }\n            executeInstruction(nextInstruction, state);\n            if (this.interceptor) {\n                const shouldContinue = await this.interceptor(state, \"after\", nextInstructionIndex);\n                if (!shouldContinue) {\n                    break;\n                }\n            }\n        }\n        return state;\n\n    }\n}\n\nexport interface Instruction {\n    op: \"acc\" | \"jmp\" | \"nop\";\n    arg: number;\n}\n\nexport interface State {\n    acc: number;\n    currentInstruction: number;\n}\n\nexport const parseProgram = (lines: string[]): Program => {\n    return lines.map((line) => {\n        const [op, arg] = line.split(\" \");\n        return {\n            op: op as \"jmp\" | \"acc\" | \"nop\",\n            arg: parseInt(arg, 10)\n        };\n    });\n};\n\nconst executeInstruction = (instruction: Instruction, state: State) => {\n    let shouldChangeInstruction = true;\n    switch (instruction.op) {\n        case \"acc\":\n            state.acc += instruction.arg;\n            break;\n        case \"jmp\":\n            state.currentInstruction += instruction.arg;\n            shouldChangeInstruction = false;\n            break;\n        case \"nop\":\n            break;\n        default:\n            throw new Error(\"Invalid instruction\");\n    }\n    if (shouldChangeInstruction) {\n        state.currentInstruction++;\n    }\n};\n\nexport const emptyState = (): State => ({\n    acc: 0,\n    currentInstruction: 0\n});\n","import { sumCoordinate } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\nimport { Instruction, Program } from \"../support/handheld\";\n\nexport interface IHandheldHalting {\n    setup(program: Program, instances: number): Promise<void>;\n    setExecuted(programNumber: number, instruction: number): Promise<void>;\n    setStatus(programNumber: number, status: \"loop\" | \"finished\"): Promise<void>;\n}\n\nconst constants = (() => {\n    const programSize = {\n        x: 50,\n        y: 5\n    };\n    const indicatorSize = {\n        x: 0,\n        y: programSize.y\n    };\n    const indicatorSpacing = {\n        x: 2,\n        y: 0\n    };\n    const programSpacing = {\n        x: 5,\n        y: 5\n    };\n    const programOffset = sumCoordinate(programSize, programSpacing);\n    const columns = 7;\n    return {\n        rows: 0,\n        screenSizeBuilder(programs: number) {\n            this.rows = Math.ceil(programs / columns);\n            return {\n                x: programOffset.x * Math.min(columns, programs) + programSpacing.x,\n                y: programOffset.y * this.rows + programSpacing.y\n            };\n        },\n        columns,\n        programOffset,\n        programSize,\n        programSpacing,\n        indicatorSize,\n        indicatorSpacing\n    };\n})();\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new RealVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nclass RealVisualizer implements IHandheldHalting {\n    private printer!: ScreenPrinter;\n    // private programDrawables: LocalDrawable[][] = [];\n    private programs: Array<{\n        drawable: LocalDrawable,\n        instructionsToDraw: number\n    }> = [];\n    private sizeIncrement = 0;\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) {\n    }\n    public async setStatus(programNumber: number, status: \"loop\" | \"finished\"): Promise<void> {\n        for (let i = 0; i <= programNumber; i++) {\n            this.updateSize(i);\n        }\n        this.programs[programNumber].drawable.color = status === \"loop\" ? \"red\" : \"lime\";\n        this.printer.forceRender();\n        await this.pause();\n        for (let i = programNumber + 1; i < this.programs.length; i++) {\n            this.updateSize(i);\n            this.printer.forceRender();\n            await this.pause();\n        }\n    }\n    public async setup(program: Instruction[], instances: number, expectedFill: number = 1): Promise<void> {\n        const screenSize = constants.screenSizeBuilder(instances);\n\n        this.sizeIncrement = (constants.programSize.x - 1) / (program.length * expectedFill);\n\n        this.printer = await this.screenBuilder.requireScreen(screenSize);\n        this.printer.setManualRender();\n\n        const toDraw: Drawable[] = [];\n\n        for (let i = 0; i < instances; i++) {\n            const coordinate = {\n                x: i % constants.columns,\n                y: Math.floor(i / constants.columns)\n            };\n            const viewCoordinates = {\n                x: coordinate.x * constants.programOffset.x + constants.programSpacing.x,\n                y: coordinate.y * constants.programOffset.y + constants.programSpacing.y\n            };\n\n            const drawableProgram: LocalDrawable = {\n                c: viewCoordinates,\n                color: \"white\",\n                id: `program-${i}`,\n                size: {...constants.programSize, x: 1},\n                type: \"rectangle\"\n            };\n            toDraw.push(drawableProgram);\n            this.programs.push({drawable: drawableProgram, instructionsToDraw: 0});\n\n            const indicator: LocalDrawable = {\n                c: {\n                    x: viewCoordinates.x + constants.programSize.x + constants.indicatorSpacing.x,\n                    y: viewCoordinates.y\n                },\n                color: \"white\",\n                id: `indicator-${i}`,\n                size: constants.indicatorSize,\n                type: \"rectangle\"\n            };\n            toDraw.push(indicator);\n        }\n\n        this.printer.replace(toDraw);\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async setExecuted(programNumber: number, instruction: number): Promise<void> {\n        const p = this.programs[programNumber];\n        p.instructionsToDraw++;\n        if (p.instructionsToDraw > 20) {\n            this.updateSize(programNumber);\n            this.printer.forceRender();\n            await this.pause();\n        }\n    }\n    private updateSize(programNumber: number) {\n        const p = this.programs[programNumber];\n        p.drawable.size.x += (this.sizeIncrement * p.instructionsToDraw);\n        p.instructionsToDraw = 0;\n    }\n}\n\nclass DummyVisualizer implements IHandheldHalting {\n    public async setStatus(programNumber: number, status: \"loop\" | \"finished\"): Promise<void> { }\n    public async setup(program: Instruction[], instances: number): Promise<void> { }\n    public async setExecuted(programNumber: number, instruction: number): Promise<void> { }\n\n}\n","import { entryForFile } from \"../../../entry\";\nimport { emptyState, HandheldProgram } from \"../support/handheld\";\nimport { buildVisualizer } from \"./visualizer\";\n\n\nexport const handheldHalting = entryForFile(\n    async ({\n        lines,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        // const program = parseProgram(lines);\n        const program = new HandheldProgram(lines);\n        await visualizer.setup(program.program, 1, 0.4);\n        const executed = new Set<number>();\n        await program\n            .setInterceptor(async (s, beforeOrAfter) => {\n                if (beforeOrAfter === \"after\") {\n                    return true;\n                }\n                if (executed.has(s.currentInstruction)) {\n                    await visualizer.setStatus(0, \"loop\");\n                    await resultOutputCallback(s.acc);\n                    return false;\n                } else {\n                    executed.add(s.currentInstruction);\n                    await visualizer.setExecuted(0, s.currentInstruction);\n                    return true;\n                }\n            })\n            .execute();\n    },\n    async ({\n        lines,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const program = new HandheldProgram(lines);\n        const executions = program.program\n            .map((inst, index) => ({inst, index}))\n            .filter((e) => e.inst.op === \"nop\" || e.inst.op === \"jmp\")\n            .map((e, executionIndex) => {\n                return {\n                    index: e.index,\n                    instruction: {\n                        op: e.inst.op === \"nop\" ? \"jmp\" : \"nop\" as \"jmp\" | \"nop\" | \"acc\",\n                        arg: e.inst.arg\n                    },\n                    state: emptyState(),\n                    stop: false,\n                    executed: new Set<number>(),\n                    executionIndex\n                };\n            });\n\n        await visualizer.setup(program.program, executions.length, 0.25);\n        let found = false;\n        while (!found) {\n            for (const execution of executions) {\n                if (found) {\n                    return;\n                }\n                if (execution.stop) {\n                    continue;\n                }\n                execution.state = await\n                    program.setInterceptor(async (s, beforeOrAfter, nextInstructionIndex) => {\n                        if (beforeOrAfter === \"before\") {\n                            if (execution.executed.has(nextInstructionIndex)) {\n                                await visualizer.setStatus(execution.executionIndex, \"loop\");\n                                execution.stop = true;\n                                return false;\n                            } else if (nextInstructionIndex < 0 || nextInstructionIndex >= program.length) {\n                                await visualizer.setStatus(execution.executionIndex, \"finished\");\n                                found = true;\n                                await resultOutputCallback(s.acc);\n                                return false;\n                            } else {\n                                return true;\n                            }\n                        } else {\n                            await visualizer.setExecuted(execution.executionIndex, nextInstructionIndex);\n                            execution.executed.add(nextInstructionIndex);\n                            return false;\n                        }\n                    })\n                    .setInstructionChanger(async (currentInstruction) => {\n                        if (currentInstruction === execution.index) {\n                            return execution.instruction;\n                        }\n                        return program.program[currentInstruction];\n                    })\n                    .execute(execution.state);\n            }\n        }\n    },\n    {\n        key: \"handheld-halting\",\n        title: \"Handheld Halting\",\n        stars: 2,\n        supportsQuickRunning: true,\n        customComponent: \"pause-and-run\",\n        embeddedData: true\n    }\n);\n","import { logarithm } from \"../../../../support/algebra\";\nimport { Coordinate, sumCoordinate } from \"../../../../support/geometry\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nexport interface IEncodingErrorVisualizer {\n    setupInvalidFinder(numbers: number[], preamble: number[]): Promise<void>;\n    changeBag(preamble: number[]): Promise<void>;\n    setCurrent(index: number): Promise<void>;\n    setCalculatedBag(index: number): Promise<void>;\n    setWinnerBag(index: number): Promise<void>;\n    setInvalid(index: number): Promise<void>;\n\n    setupWeakness(numbers: number[]): Promise<void>;\n    addBagItem(number: number): Promise<void>;\n    updateBagSize(index: number, newSize: number): Promise<void>;\n    setWrongBag(index: number): Promise<void>;\n}\n\nconst constants = (() => {\n    const columns = 20;\n    const numberSize = {\n        x: 10,\n        y: 2\n    };\n    const numberSpacing = {\n        x: 2,\n        y: 2\n    };\n    const numberOffset = sumCoordinate(numberSize, numberSpacing);\n\n    const bagColumns = 5;\n    const bagRows = 5;\n    const bagSize = {\n        x: numberSpacing.x + numberOffset.x * bagColumns,\n        y: numberSpacing.y + numberOffset.y * bagRows\n    };\n\n    return {\n        columns,\n        number: {\n            size: numberSize,\n            spacing: numberSpacing,\n            offset: numberOffset,\n        },\n        bag: {\n            size: bagSize,\n            columns: bagColumns,\n            rows: bagRows\n        },\n        screenSizeBuilder(hasBag: boolean, entries: number[]) {\n            const baseSize = hasBag ? sumCoordinate(bagSize, numberSpacing) : numberSpacing;\n            const rows = Math.floor(entries.length / columns);\n            return {\n                x: Math.max(baseSize.x, columns * numberOffset.x + numberSpacing.x),\n                y: baseSize.y + numberSpacing.y + rows * numberOffset.y\n            };\n        },\n        bigBagSizeBuilder(entries: number[]) {\n            const rows = Math.floor(entries.length / columns);\n            return {\n                x: columns * numberOffset.x + numberSpacing.x * 2,\n                y: rows * numberOffset.y + numberSpacing.y * 2\n            };\n        },\n        weaknessScreenSizeBuilder(entries: number[]) {\n            const bs = this.bigBagSizeBuilder(entries);\n            const rows = Math.floor(entries.length / columns);\n            return {\n                x: bs.x,\n                y: bs.y + numberSpacing.y + numberOffset.y * rows\n            };\n        }\n    };\n})();\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new RealVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nclass RealVisualizer implements IEncodingErrorVisualizer {\n    private printer!: ScreenPrinter;\n\n    private bagItems: LocalDrawable[] = [];\n    private drawableNumbers: LocalDrawable[] = [];\n\n    private k = 10000;\n    private maxLog = Number.MAX_VALUE;\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) {\n    }\n\n    public async setupWeakness(numbers: number[]) {\n        this.printer = await this.screenBuilder.requireScreen(constants.weaknessScreenSizeBuilder(numbers));\n        this.printer.setManualRender();\n        const maxNumber = numbers.reduce((acc, next) => Math.max(acc, next));\n\n        this.maxLog = Math.log2(maxNumber + this.k);\n        const bagSize = constants.bigBagSizeBuilder(numbers);\n        const bag: LocalDrawable = {\n            c: constants.number.spacing,\n            id: \"bag\",\n            color: \"darkblue\",\n            size: bagSize,\n            type: \"rectangle\"\n        };\n        this.bagItems = [];\n\n        this.drawableNumbers = numbers.map((n, i) => {\n            const coordinates = {\n                x: i % constants.columns,\n                y: Math.floor(i / constants.columns)\n            };\n            const viewCoordinates = {\n                x: constants.number.spacing.x + constants.number.offset.x * coordinates.x,\n                y: bag.c.y + bag.size.y + constants.number.spacing.y + constants.number.offset.y * coordinates.y,\n            };\n            return {\n                c: viewCoordinates,\n                color: \"white\",\n                id: `n-${i}`,\n                size: {\n                    x: this.calculateNumberSize(n),\n                    y: constants.number.size.y\n                },\n                type: \"rectangle\"\n            } as LocalDrawable;\n        });\n\n        this.printer.replace([bag].concat(this.bagItems).concat(this.drawableNumbers));\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async addBagItem(number: number) {\n        const newIndex = this.bagItems.length;\n        const coordinates = {\n            x: newIndex % constants.columns,\n            y: Math.floor(newIndex / constants.columns)\n        };\n        const viewCoordinates = {\n            x: constants.number.spacing.x * 2 + coordinates.x * constants.number.offset.x,\n            y: constants.number.spacing.y * 2 + coordinates.y * constants.number.offset.y,\n        };\n        const newItem: LocalDrawable = {\n            id: `bag-item-${newIndex}`,\n            color: \"white\",\n            size: {\n                x: this.calculateNumberSize(number),\n                y: constants.number.size.y\n            },\n            type: \"rectangle\",\n            c: viewCoordinates\n        };\n        this.bagItems.push(newItem);\n        await this.printer.add(newItem);\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async updateBagSize(index: number, newSize: number) {\n        this.bagItems[index].size.x = this.calculateNumberSize(newSize);\n    }\n\n    public async setWrongBag(index: number) {\n        this.bagItems[index].color = \"red\";\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async setInvalid(index: number): Promise<void> {\n        this.drawableNumbers[index].color = \"red\";\n        this.printer.forceRender();\n        await this.pause();\n    }\n    public async setWinnerBag(index: number): Promise<void> {\n        this.bagItems[index].color = \"lime\";\n        this.printer.forceRender();\n        await this.pause(10);\n    }\n\n    public async setCalculatedBag(index: number): Promise<void> {\n        this.bagItems[index].color = \"grey\";\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async changeBag(preamble: number[]) {\n        if (preamble.length !== 25) {\n            throw new Error(\"Cannot run without 25 items in preamble\");\n        }\n        for (let i = 0; i < preamble.length; i++) {\n            this.bagItems[i].size.x = this.calculateNumberSize(preamble[i]);\n            this.bagItems[i].color = \"white\";\n        }\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async setCurrent(index: number) {\n        this.drawableNumbers[index].color = \"pink\";\n        if (index > 0) {\n            this.drawableNumbers[index - 1].color = \"lime\";\n        }\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    public async setupInvalidFinder(numbers: number[], preamble: number[]) {\n        this.printer = await this.screenBuilder.requireScreen(constants.screenSizeBuilder(true, numbers));\n        this.printer.setManualRender();\n        if (preamble.length !== 25) {\n            throw new Error(\"Cannot run without 25 items in preamble\");\n        }\n        const maxNumber = numbers.reduce((acc, next) => Math.max(acc, next));\n        this.maxLog = Math.log2(maxNumber + this.k);\n        const bag: LocalDrawable = {\n            c: constants.number.spacing,\n            id: \"bag\",\n            color: \"darkblue\",\n            size: constants.bag.size,\n            type: \"rectangle\"\n        };\n        this.bagItems = preamble.map((n, i) => {\n            const coordinates = {\n                x: i % constants.bag.columns,\n                y: Math.floor(i / constants.bag.columns)\n            };\n            const viewCoordinates = {\n                x: bag.c.x + coordinates.x * constants.number.offset.x + constants.number.spacing.x,\n                y: bag.c.y + coordinates.y * constants.number.offset.y + constants.number.spacing.y\n            };\n            return {\n                c: viewCoordinates,\n                color: \"white\",\n                id: `bag-${i}`,\n                size: {\n                    x: this.calculateNumberSize(n),\n                    y: constants.number.size.y\n                },\n                type: \"rectangle\"\n            } as LocalDrawable;\n        });\n\n        this.drawableNumbers = numbers.map((n, i) => {\n            const coordinates = {\n                x: i % constants.columns,\n                y: Math.floor(i / constants.columns)\n            };\n            const viewCoordinates = {\n                x: constants.number.spacing.x + constants.number.offset.x * coordinates.x,\n                y: bag.c.y + bag.size.y + constants.number.spacing.y + constants.number.offset.y * coordinates.y,\n            };\n            return {\n                c: viewCoordinates,\n                color: i < 25 ? \"grey\" : \"white\",\n                id: `n-${i}`,\n                size: {\n                    x: this.calculateNumberSize(n),\n                    y: constants.number.size.y\n                },\n                type: \"rectangle\"\n            } as LocalDrawable;\n        });\n\n        this.printer.replace([bag].concat(this.bagItems).concat(this.drawableNumbers));\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    private calculateNumberSize(n: number): number {\n        return Math.max(constants.number.size.x * (Math.log2(n + this.k) / this.maxLog), 1);\n    }\n}\n\nclass DummyVisualizer implements IEncodingErrorVisualizer {\n    public async setupWeakness(numbers: number[]): Promise<void> { }\n    public async addBagItem(number: number): Promise<void> { }\n    public async updateBagSize(index: number, newSize: number): Promise<void> { }\n    public async setWrongBag(index: number): Promise<void> { }\n    public async setInvalid(index: number): Promise<void> { }\n    public async setCalculatedBag(index: number): Promise<void> { }\n    public async setWinnerBag(index: number): Promise<void> { }\n    public async changeBag(preamble: number[]): Promise<void> { }\n    public async setCurrent(index: number): Promise<void> { }\n    public async setupInvalidFinder(numbers: number[], preamble: number[]): Promise<void> { }\n\n}\n","import { LinkedList } from \"../../../../support/data-structure\";\nimport { entryForFile } from \"../../../entry\";\nimport { buildVisualizer, IEncodingErrorVisualizer } from \"./visualizer\";\n\nconst findInvalid = async (ns: number[], visualizer?: IEncodingErrorVisualizer): Promise<number | null> => {\n    for (let i = 25; i < ns.length; i++) {\n        if (visualizer) {\n            await visualizer.setCurrent(i);\n        }\n        const target = ns[i];\n        const lookingFor = new Set<number>();\n        let found = false;\n        if (visualizer) {\n            await visualizer.changeBag(ns.slice(i - 25, i));\n        }\n        for (let j = i - 25; j < i; j++) {\n            if (lookingFor.has(ns[j])) {\n                if (visualizer) {\n                    await visualizer.setWinnerBag(j - (i - 25));\n                }\n                found = true;\n                break;\n            } else {\n                if (visualizer) {\n                    await visualizer.setCalculatedBag(j - (i - 25));\n                }\n                lookingFor.add(target - ns[j]);\n            }\n        }\n        if (!found) {\n            if (visualizer) {\n                await visualizer.setInvalid(i);\n            }\n            return target;\n        }\n    }\n    return null;\n};\n\nexport const encodingError = entryForFile(\n    async ({\n        lines,\n        resultOutputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        const ns = lines.map((l) => parseInt(l, 10));\n        await visualizer.setupInvalidFinder(ns, ns.slice(0, 25));\n        const invalid = await findInvalid(ns, screen && visualizer);\n        await resultOutputCallback(ns === null ? \"Did not find it :(\" : invalid);\n    },\n    async ({\n        lines,\n        resultOutputCallback ,\n        outputCallback,\n        screen,\n        pause,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const ns = lines.map((l) => parseInt(l, 10));\n        const visualizer = buildVisualizer(screen, pause);\n        await visualizer.setupWeakness(ns);\n\n        const invalid = await findInvalid(ns);\n        if (invalid === null) {\n            throw new Error(\"Could not find invalid\");\n        }\n        const sums = new LinkedList<{min: number, max: number, value: number, i: number}>();\n        let i = 0;\n        for (const n of ns) {\n            await visualizer.setCurrent(i);\n            for (const sum of sums) {\n                sum.element.value += n;\n                sum.element.min = Math.min(n, sum.element.min);\n                sum.element.max = Math.max(n, sum.element.max);\n                if (sum.element.value === invalid) {\n                    await visualizer.setWinnerBag(sum.element.i);\n                    await resultOutputCallback(sum.element.min + sum.element.max);\n                    return;\n                } else if (sum.element.value > invalid) {\n                    await visualizer.setWrongBag(sum.element.i);\n                    sum.remove();\n                } else {\n                    await visualizer.updateBagSize(sum.element.i, sum.element.value);\n                }\n            }\n            const node = {min: n, max: n, value: n, i: i++};\n            sums.addNode(node);\n            await visualizer.addBagItem(n);\n        }\n        await resultOutputCallback(\"Could not find it\");\n    },\n    {\n        key: \"encoding-error\",\n        title: \"Encoding Error\",\n        stars: 2,\n        supportsQuickRunning: true,\n        suggestedDelay: 15,\n        customComponent: \"pause-and-run\",\n        embeddedData: true\n    }\n);\n","import { groupBy } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\n\nconst prettyPrint = (lines: string[]) =>\n        [...groupBy(lines.map((l) => parseInt(l, 10)).concat([0, 51]).sort((a, b) => a - b), 10)]\n            .map((e) => e.map((x) => x.toString().padStart(3, \" \")).join(\" \")).join(\"\\n\");\n\nexport const adapterArray = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const ns = lines\n            .map((l) => parseInt(l, 10))\n            .sort((a, b) => a - b)\n            .reduce((acc, next) => {\n                acc.differences[next - acc.prev] = (acc.differences[next - acc.prev] || 0) + 1;\n                acc.prev = next;\n                return acc;\n            }, {\n                prev: 0,\n                differences: {} as {[key: number]: number}\n            });\n        ns.differences[3]++;\n        await outputCallback(ns.differences);\n        await resultOutputCallback(ns.differences[1] * ns.differences[3]);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const ns = lines\n            .map((l) => parseInt(l, 10))\n            .sort((a, b) => a - b)\n            .reduce((acc, next) => (\n                {\n                prev: next,\n                vs: [...acc.vs, next - acc.prev]\n            }\n            ), {prev: 0, vs: [] as number[]});\n        ns.vs.push(3);\n\n        const factors: number[] = [];\n        let isOnStreak = false;\n        let count = 0;\n        for (const n of ns.vs) {\n            if (n === 1) {\n                count++;\n                isOnStreak = true;\n            } else {\n                if (isOnStreak && count > 0) {\n                    factors.push(count - 1);\n                }\n                count = 0;\n                isOnStreak = false;\n            }\n        }\n\n        await outputCallback(prettyPrint(lines));\n        await outputCallback(\"\");\n\n        await outputCallback(factors);\n        await resultOutputCallback(\n            factors\n                .filter((f) => f > 0)\n                .reduce((acc, next) => acc * (\n                    next <= 2 ?\n                        (2 ** next)  // if there are at most 2 optional adapters, all subsets are fine\n                        : 7 // if there are 3, not all are fine; in particular, the empty subset does not work\n                ), 1));\n    },\n    { key: \"adapter-array\", title: \"Adapter Array\", stars: 2, embeddedData: true, supportsQuickRunning: true}\n);\n","import { Grid } from \".\";\nimport { Coordinate, multiplyCoordinate, serialization } from \"../../../../support/geometry\";\nimport { FixedSizeMatrix } from \"../../../../support/matrix\";\nimport { Drawable, Pause, ScreenBuilder, ScreenPrinter } from \"../../../entry\";\n\nexport interface ISeatingSystemVisualizer {\n    setup(size: Coordinate): Promise<void>;\n    update(grid: Grid): Promise<void>;\n}\n\nexport const buildVisualizer = (screenBuilder: ScreenBuilder | undefined, pause: Pause) => {\n    if (screenBuilder) {\n        return new RealVisualizer(screenBuilder, pause);\n    } else {\n        return new DummyVisualizer();\n    }\n};\n\nconst constants = (() => {\n    const cellSize = {x: 4, y: 4};\n    return {\n        cellSize\n    };\n})();\n\ntype LocalDrawable = Drawable & {type: \"rectangle\"};\n\nclass RealVisualizer implements ISeatingSystemVisualizer {\n    private printer!: ScreenPrinter;\n    private drawables!: FixedSizeMatrix<Drawable>;\n\n    constructor(\n        private readonly screenBuilder: ScreenBuilder,\n        private readonly pause: Pause\n    ) {\n    }\n    public async setup(size: Coordinate): Promise<void> {\n        const screenSize = multiplyCoordinate(size, constants.cellSize);\n        this.printer = await this.screenBuilder.requireScreen(screenSize);\n        this.printer.setManualRender();\n\n        this.drawables = new FixedSizeMatrix<LocalDrawable>(size);\n        this.drawables.fillFactory((c) => {\n            return {\n                c: multiplyCoordinate(constants.cellSize, c),\n                id: serialization.serialize(c),\n                color: this.mapState(\".\"),\n                type: \"rectangle\",\n                size: constants.cellSize\n            };\n        });\n\n        this.printer.replace(this.drawables.getFlatData());\n\n        this.printer.forceRender();\n        await this.pause();\n    }\n    public async update(grid: Grid): Promise<void> {\n        grid.onEveryCellSync((c, e) => {\n            this.drawables.get(c)!.color = this.mapState(e!);\n        });\n        this.printer.forceRender();\n        await this.pause();\n    }\n\n    private mapState(cell: \"#\" | \".\" | \"L\"): string {\n        if (cell === \"#\") {\n            return \"#ff6961\"; // \"red\";\n        } else if (cell === \".\") {\n            return \"white\";\n        } else {\n            return \"#77dd77\"; // \"lime\";\n        }\n    }\n}\n\nclass DummyVisualizer implements ISeatingSystemVisualizer {\n    public async setup(size: Coordinate): Promise<void> { }\n    public async update(grid: Grid): Promise<void> { }\n\n}\n","import { CCoordinate, Coordinate, directionList, getFullSurrounding, manhattanDistance } from \"../../../../support/geometry\";\nimport { FixedSizeMatrix } from \"../../../../support/matrix\";\nimport { entryForFile, ResultOutputCallback } from \"../../../entry\";\nimport { buildVisualizer, ISeatingSystemVisualizer } from \"./visualizer\";\n\ntype Cell = \"#\" | \"L\" | \".\";\nexport type Grid = FixedSizeMatrix<Cell>;\n\nconst parseLines = (lines: string[]): Grid => {\n    const size = {x: lines[lines.length - 1].length, y: lines.length};\n    const grid = new FixedSizeMatrix<Cell>(size);\n    const flatData = lines\n        .map((e) => e.length !== size.x ? e.slice(0, size.x) : e)\n        .join(\"\")\n        .split(\"\")\n        .map((e) => e as Cell);\n    grid.setFlatData(flatData);\n    return grid;\n};\n\nconst iterate = async (grid: Grid): Promise<Grid> => {\n    return grid.map<Cell>((element, coordinate) => {\n        if (element === \".\") {\n            return element;\n        }\n        const adjacent = getFullSurrounding(coordinate)\n            .map((c) => grid.get(c))\n            .filter((e) => e);\n        const occupied = adjacent.filter((e) => e === \"#\").length;\n\n        if (element === \"L\") {\n            if (occupied === 0) {\n                return \"#\";\n            }\n        } else if (element === \"#\") {\n            if (occupied >= 4) {\n                return \"L\";\n            }\n        }\n        return element!;\n    });\n};\n\nconst findFirstSeat = (grid: Grid, start: Coordinate, direction: CCoordinate): Cell | null => {\n    start = direction.sum(start);\n    while (true) {\n        const cell = grid.get(start);\n        if (!cell) {\n            return null;\n        }\n        if (cell !== \".\") {\n            return cell;\n        }\n        start = direction.sum(start);\n    }\n};\n\nconst realIterate = async (grid: Grid): Promise<Grid> => {\n    const g = grid.map<Cell>((element, coordinate) => {\n        if (element === \".\") {\n            return element;\n        }\n        const adjacent = directionList.map((d) => findFirstSeat(grid, coordinate, d)).filter((e) => e) as Cell[];\n        const occupied = adjacent.filter((e) => e === \"#\").length;\n\n        if (element === \"L\") {\n            if (occupied === 0) {\n                return \"#\";\n            }\n        } else if (element === \"#\") {\n            if (occupied >= 5) {\n                return \"L\";\n            }\n        }\n        return element!;\n    });\n    return g;\n};\n\nconst execute = async (\n    lines: string[],\n    visualizer: ISeatingSystemVisualizer,\n    resultOutputCallback: ResultOutputCallback,\n    // pause: Pause,\n    isQuickRunning: boolean,\n    iterationCallback: typeof iterate) => {\n        const visited = new Set<string>();\n        let grid = parseLines(lines);\n        await visualizer.setup(grid.size);\n        if (!isQuickRunning) {\n            // await outputCallback(grid.toString(e => e || \" \"));\n            await visualizer.update(grid);\n            // await pause();\n        }\n        while (true) {\n            const serialized = grid.simpleSerialize();\n            if (visited.has(serialized)) {\n                const occupied = grid.reduce<number>((acc, next) => acc + (next.cell === \"#\" ? 1 : 0), 0);\n                // if (!isQuickRunning) {\n                //     await outputCallback(occupied, true);\n                //     await outputCallback(grid.toString(e => e || \" \"));\n                // }\n                await visualizer.update(grid);\n                await resultOutputCallback(occupied);\n                return;\n            }\n            visited.add(serialized);\n            grid = await iterationCallback(grid);\n            await visualizer.update(grid);\n            // if (!isQuickRunning) {\n                // await outputCallback(grid.toString(e => e || \" \"), true);\n                // await pause();\n            // }\n        }\n    };\n\nexport const seatingSystem = entryForFile(\n    async ({\n        lines,\n        // outputCallback,\n        resultOutputCallback,\n        pause,\n        isQuickRunning,\n        screen,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        await execute(lines, visualizer, resultOutputCallback, /*pause,*/ isQuickRunning, iterate);\n    },\n    async ({\n        lines,\n        // outputCallback,\n        resultOutputCallback,\n        pause,\n        isQuickRunning,\n        screen,\n        setAutoStop\n    }) => {\n        setAutoStop();\n        const visualizer = buildVisualizer(screen, pause);\n        await execute(lines, visualizer, resultOutputCallback, /*pause,*/ isQuickRunning, realIterate);\n    },\n    {\n        key: \"seating-system\",\n        title: \"Seating System\",\n        stars: 2,\n        supportsQuickRunning: true,\n        suggestedDelay: 20,\n        customComponent: \"pause-and-run\",\n        embeddedData: true\n    }\n);\n","import { CCoordinate, Coordinate, directions, manhattanDistance, rotate, serialization } from \"../../../../support/geometry\";\nimport { entryForFile } from \"../../../entry\";\n\nconst validDirections = [\n\"N\" , \"S\" , \"E\" , \"W\" , \"L\" , \"R\" , \"F\"\n];\n\nconst isValidDirection = (d: string): d is Direction => {\n    return validDirections.includes(d);\n};\n\ntype Direction = \"N\" | \"S\" | \"E\" | \"W\" | \"L\" | \"R\" | \"F\";\ninterface Movement {\n    direction: Direction;\n    magnitude: number;\n}\n\ninterface State {\n    position: Coordinate;\n    direction: CCoordinate;\n}\n\nconst parseLines = (lines: string[]): Movement[] => {\n    return lines.map((line) => {\n        const d = line[0];\n        if (!isValidDirection(d)) {\n            throw new Error(\"Invalid direction\");\n        }\n        let magnitude = parseInt(line.slice(1), 10);\n        if (d === \"R\" || d === \"L\") {\n            if (magnitude % 90 !== 0) {\n                throw new Error(\"Invalid magnitude\");\n            }\n            magnitude = magnitude / 90;\n        }\n        return {\n            direction: d,\n            magnitude\n        };\n    });\n};\n\ninterface WaypointState {\n    shipCoordinate: Coordinate;\n    waypointCoordinate: CCoordinate;\n}\n\nconst updateWaypointState = (state: WaypointState, movement: Movement): WaypointState => {\n    const result = {...state};\n    switch (movement.direction) {\n        case \"E\":\n            result.waypointCoordinate = directions.right.times(movement.magnitude).sum(state.waypointCoordinate);\n            break;\n        case \"W\":\n            result.waypointCoordinate = directions.left.times(movement.magnitude).sum(state.waypointCoordinate);\n            break;\n        case \"N\":\n            result.waypointCoordinate = directions.up.times(movement.magnitude).sum(state.waypointCoordinate);\n            break;\n        case \"S\":\n            result.waypointCoordinate = directions.down.times(movement.magnitude).sum(state.waypointCoordinate);\n            break;\n        case \"L\":\n            result.waypointCoordinate = rotate(state.waypointCoordinate, \"Counterclockwise\", movement.magnitude);\n            break;\n        case \"R\":\n            result.waypointCoordinate = rotate(state.waypointCoordinate, \"Clockwise\", movement.magnitude);\n            break;\n        case \"F\":\n            result.shipCoordinate = state.waypointCoordinate.times(movement.magnitude).sum(state.shipCoordinate);\n            break;\n    }\n    return result;\n};\n\nconst updateState = (state: State, movement: Movement): State => {\n    const result = {...state};\n    switch (movement.direction) {\n        case \"E\":\n            result.position = directions.right.times(movement.magnitude).sum(state.position);\n            break;\n        case \"W\":\n            result.position = directions.left.times(movement.magnitude).sum(state.position);\n            break;\n        case \"N\":\n            result.position = directions.up.times(movement.magnitude).sum(state.position);\n            break;\n        case \"S\":\n            result.position = directions.down.times(movement.magnitude).sum(state.position);\n            break;\n        case \"L\":\n            result.direction = rotate(state.direction, \"Counterclockwise\", movement.magnitude);\n            break;\n        case \"R\":\n            result.direction = rotate(state.direction, \"Clockwise\", movement.magnitude);\n            break;\n        case \"F\":\n            result.position = state.direction.times(movement.magnitude).sum(state.position);\n            break;\n    }\n    return result;\n};\n\nexport const rainRisk = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        let state: State = {position: {x: 0, y: 0}, direction: directions.right};\n        for (const movement of input) {\n            state = updateState(state, movement);\n        }\n        await resultOutputCallback(manhattanDistance(state.position, {x: 0, y: 0}));\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        let state: WaypointState = {\n            shipCoordinate: {x: 0, y: 0},\n            waypointCoordinate: new CCoordinate(10, -1)\n        };\n        for (const movement of input) {\n            state = updateWaypointState(state, movement);\n        }\n        await resultOutputCallback(manhattanDistance(state.shipCoordinate, {x: 0, y: 0}));\n    },\n    {\n        key: \"rain-risk\",\n        title: \"Rain Risk\",\n        embeddedData: true,\n        supportsQuickRunning: true,\n        stars: 2\n    }\n);\n","import { modInverse } from \"../../../../support/algebra\";\nimport { entryForFile } from \"../../../entry\";\n\nconst getBusIDs = (line: string): number[] => {\n    return line.split(\",\").map((l) => {\n        const n = parseInt(l, 10);\n        if (n.toString() === l) {\n            return n;\n        } else {\n            return -1;\n        }\n    }).filter((n) => n > 0);\n};\n\ninterface Equation {\n    mod: bigint;\n    value: bigint;\n}\n\nconst parseEquations = (line: string): Equation[] => {\n    const result: Equation[] = [];\n    let v = 0;\n    for (const d of line.split(\",\")) {\n        if (d !== \"x\") {\n            result.push({\n                mod: BigInt(parseInt(d, 10)),\n                value: BigInt(-v)\n            });\n        }\n        v++;\n    }\n    return result;\n};\n\nexport const shuttleSearch = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const ts = parseInt(lines[0], 10);\n        const ids = getBusIDs(lines[1]);\n        const result = ids.map((id) => ({id, ts: id - (ts % id)})).reduce((acc, next) => acc.ts < next.ts ? acc : next);\n        await resultOutputCallback(result.id * result.ts);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const equations = parseEquations(lines[1]);\n        const mainMod = equations.reduce((acc, next) => acc * next.mod, 1n);\n        const toSolve: Array<{a: bigint; c: bigint; y: bigint}> = [];\n        for (const equation of equations) {\n            const c = mainMod / equation.mod;\n            const a = equation.value;\n            const y = modInverse(c, equation.mod);\n            toSolve.push({\n                a,\n                c,\n                y\n            });\n        }\n        let result = toSolve.reduce((acc, next) => acc + next.a * next.c * next.y, 0n) % mainMod;\n        if (result < 0) {\n            result += mainMod;\n        }\n        await resultOutputCallback(result.toString());\n    },\n    {\n        key: \"shuttle-search\",\n        title: \"Shuttle Search\",\n        embeddedData: true,\n        stars: 2,\n        supportsQuickRunning: true\n    }\n);\n","import { entryForFile } from \"../../../entry\";\n\ntype Instruction = {\n    mask: string[];\n} | {\n    address: number;\n    value: string;\n};\n\nconst isMask = (e: Instruction): e is {mask: string[]} => {\n    return (e as {mask: string[]}).mask !== undefined;\n};\n\nconst parseLines = (lines: string[]): Instruction[] => {\n    return lines.map((line) => {\n        const [a, b] = line.split(\" = \");\n        if (a.includes(\"[\")) {\n            return {\n                value: parseInt(b, 10).toString(2).padStart(36, \"0\"),\n                address: parseInt(a.match(/.*\\[(\\d+)\\]/)![1], 10)\n            };\n        } else {\n            return {\n                mask: b.split(\"\")\n            };\n        }\n    });\n};\n\ninterface Memory {\n    data: {[key: number]: number};\n    mask: string[];\n}\n\nconst emptyMemory = (): Memory => {\n    return {\n        data: {},\n        mask: \"\".padStart(36, \"X\").split(\"\")\n    };\n};\n\nconst updateMemory = async (instruction: Instruction, memory: Memory): Promise<void> => {\n    if (isMask(instruction)) {\n        memory.mask = instruction.mask;\n    } else {\n        memory.data[instruction.address] = parseInt(memory.mask.map((e, i) => {\n            if (e === \"X\") {\n                return instruction.value[i];\n            } else {\n                return e;\n            }\n        }).join(\"\"), 2);\n    }\n};\n\nconst createAddress = (mask: string[], address: string, index: number): string[] => {\n    if (index >= mask.length) {\n        return [\"\"];\n    }\n    let base = \"\";\n    if (mask[index] === \"0\") {\n        base = address[index];\n    } else if (mask[index] === \"1\") {\n        base = \"1\";\n    } else {\n        base = \"X\";\n    }\n    const remaining = createAddress(mask, address, index + 1);\n    if (base === \"X\") {\n         return remaining.flatMap((e) => [\"0\", \"1\"].map((x) => x + e));\n    } else {\n        return remaining.map((e) => base + e);\n    }\n};\n\n\nconst updateMemory2 = async (instruction: Instruction, memory: Memory): Promise<void> => {\n    if (isMask(instruction)) {\n        memory.mask = instruction.mask;\n    } else {\n        const binaryAddress = instruction.address.toString(2).padStart(36, \"0\");\n        const addresses = createAddress(memory.mask, binaryAddress, 0);\n        for (const address of addresses) {\n            const v = parseInt(instruction.value, 2);\n            memory.data[parseInt(address, 2)] = v;\n        }\n    }\n};\n\nexport const dockingData = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        const memory = emptyMemory();\n        for (const instruction of input) {\n            updateMemory(instruction, memory);\n        }\n        const result = Object.values(memory.data).reduce((acc, next) => acc + next, 0);\n        await resultOutputCallback(result);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        const memory = emptyMemory();\n        for (const instruction of input) {\n            updateMemory2(instruction, memory);\n        }\n        const result = Object.values(memory.data).reduce((acc, next) => acc + next, 0);\n        await resultOutputCallback(result);\n    },\n    { key: \"docking-data\", title: \"Docking Data\", embeddedData: true, stars: 2}\n);\n","import { entryForFile } from \"../../../entry\";\n\nconst parseLines = (lines: string[]): number[] => {\n    return lines[0].split(\",\").map((e) => parseInt(e, 10));\n};\n\nexport const rambunctiousRecitation = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        // lines[0] = \"0,3,6\";\n        const startList = parseLines(lines);\n        const memory: {[key: number]: number} = {};\n        let lastSpoken: number = 0;\n        let lastAge: number | undefined;\n        for (let i = 0; i < startList.length; i++) {\n            memory[startList[i]] = i + 1;\n            lastSpoken = startList[i];\n        }\n        for (let i = startList.length + 1; i <= 2020; i++) {\n            const newSpoken = lastAge !== undefined ? (memory[lastSpoken] - lastAge) : 0;\n            lastAge = memory[newSpoken];\n            if (i <= 10) {\n                await outputCallback(newSpoken);\n            }\n            memory[newSpoken] = i;\n            lastSpoken = newSpoken;\n        }\n        await resultOutputCallback(lastSpoken);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const startList = parseLines(lines);\n        const memory: {[key: number]: number} = {};\n        let lastSpoken: number = 0;\n        let lastAge: number | undefined;\n        for (let i = 0; i < startList.length; i++) {\n            memory[startList[i]] = i + 1;\n            lastSpoken = startList[i];\n        }\n        for (let i = startList.length + 1; i <= 30000000; i++) {\n            const newSpoken = lastAge !== undefined ? (memory[lastSpoken] - lastAge) : 0;\n            lastAge = memory[newSpoken];\n            if (i % 10000 === 0) {\n                await outputCallback(`${i / 30000000 * 100}%`, true);\n            }\n            memory[newSpoken] = i;\n            lastSpoken = newSpoken;\n        }\n        await resultOutputCallback(lastSpoken);\n    },\n    {\n        key: \"rambunctious-recitation\",\n        title: \"Rambunctious Recitation\",\n        embeddedData: true,\n        stars: 2,\n        supportsQuickRunning: true\n    }\n);\n","import { MessageSender, Pause } from \"../../../entry\";\n\nexport const buildCommunicator = (\n        messageSender: MessageSender | undefined,\n        pause: Pause\n    ): ITicketTranslationMessageSender => {\n    if (!messageSender) {\n        return new DummyMessageSender();\n    } else {\n        return new RealMessageSender(messageSender, pause);\n    }\n};\n\nexport interface ITicketTranslationMessageSender {\n    setup(ticket: number[]): Promise<void>;\n    foundLabel(label: string, index: number): Promise<void>;\n}\n\ntype PrivateTicketTranslationMessage = {\n    type: \"setup\";\n    ticket: number[];\n} | {\n    type: \"label\";\n    index: number;\n    label: string;\n};\n\nexport type TicketTranslationMessage = {kind: \"TicketTranslationMessage\"} & PrivateTicketTranslationMessage;\n\nconst buildMessage = (message: PrivateTicketTranslationMessage): TicketTranslationMessage => {\n    return {\n        ...message,\n        kind: \"TicketTranslationMessage\"\n    };\n};\n\nexport function isTicketTranslationMessage(message: any): message is TicketTranslationMessage {\n    return (message as TicketTranslationMessage).kind === \"TicketTranslationMessage\";\n}\n\nclass RealMessageSender implements ITicketTranslationMessageSender {\n    constructor(private readonly messageSender: MessageSender, private readonly pause: Pause) { }\n\n    public async setup(ticket: number[]) {\n        this.messageSender(buildMessage({\n            type: \"setup\",\n            ticket\n        }));\n        await this.pause();\n    }\n\n    public async foundLabel(label: string, index: number) {\n        this.messageSender(buildMessage({\n            type: \"label\",\n            index,\n            label\n        }));\n        await this.pause();\n    }\n}\n\nclass DummyMessageSender implements ITicketTranslationMessageSender {\n    public async setup(ticket: number[]): Promise<void> { }\n    public async foundLabel(label: string, index: number): Promise<void> { }\n\n}\n","import { buildGroupsFromSeparator } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\nimport { buildCommunicator, ITicketTranslationMessageSender } from \"./communication\";\n\ninterface ValidityRule {\n    min: number;\n    max: number;\n}\ninterface TicketRules {\n    [key: string]: ValidityRule[];\n}\n\ninterface Document {\n    ticketRules: TicketRules;\n    myTicket: number[];\n    nearbyTickets: number[][];\n}\n\nconst checkInvalidValues = (ticket: number[], ticketRules: TicketRules): number[] => {\n    const rules = Object.values(ticketRules);\n    const invalid: number[] = [];\n    for (const n of ticket) {\n        let foundValid = false;\n        for (const rule of rules) {\n            if (foundValid) {\n                break;\n            }\n            for (const range of rule) {\n                if (range.min <= n && range.max >= n) {\n                    foundValid = true;\n                    break;\n                }\n            }\n        }\n        if (!foundValid) {\n            invalid.push(n);\n        }\n    }\n    return invalid;\n};\n\nconst parseLines = (lines: string[]): Document => {\n    const groups = [...buildGroupsFromSeparator(lines, (e) => e.trim().length === 0)];\n    const ticketRules: TicketRules = groups[0].map((line) => line.split(\": \")).map((tokens) => {\n        return {\n            key: tokens[0],\n            validity: tokens[1].split(\" or \").map((e) => ({\n                min: parseInt(e.split(\"-\")[0], 10),\n                max: parseInt(e.split(\"-\")[1], 10)\n            } as ValidityRule))\n        };\n    }).reduce((acc, next) => {acc[next.key] = next.validity; return acc; }, {} as TicketRules);\n\n    const myTicket = groups[1][1].split(\",\").map((e) => parseInt(e, 10));\n    const nearbyTickets = groups[2]\n        .slice(1)\n        .map((line) =>  line.split(\",\").map((e) => parseInt(e, 10)));\n\n    return {\n        ticketRules,\n        myTicket,\n        nearbyTickets\n    };\n};\n\ninterface TicketIndex {\n    [key: string]: number;\n}\n\nconst checkIfRuleCanBe = (rule: ValidityRule[], index: number, tickets: number[][]): boolean => {\n    for (const ticket of tickets) {\n        const n = ticket[index];\n        let isTicketOK = false;\n        for (const range of rule) {\n            if (range.min <= n && range.max >= n) {\n                isTicketOK = true;\n            }\n        }\n        if (!isTicketOK) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst buildIndex = async (\n    ticketRules: TicketRules,\n    validTickets: number[][],\n    currentIndex: TicketIndex,\n    communicator: ITicketTranslationMessageSender\n): Promise<boolean> => {\n    const allRules = Object.keys(ticketRules);\n    const rulesToFind = allRules.filter((rule) => currentIndex[rule] === undefined);\n    const takenIndexes = new Set<number>(Object.values(currentIndex));\n    const availableIndexes = [...Array(validTickets[0].length).keys()].filter((e) => !takenIndexes.has(e));\n    if (availableIndexes.length === 0) {\n        return true;\n    }\n    let found = false;\n    for (const rule of rulesToFind) {\n        const possibleIndexes =\n            availableIndexes.filter((index) =>\n                checkIfRuleCanBe(ticketRules[rule], index, validTickets)\n            );\n        if (possibleIndexes.length === 1) {\n            currentIndex[rule] = possibleIndexes[0];\n            found = true;\n            await communicator.foundLabel(rule, possibleIndexes[0]);\n        }\n    }\n    if (found) {\n        return await buildIndex(ticketRules, validTickets, currentIndex, communicator);\n    }\n    return false;\n};\n\nexport const ticketTranslation = entryForFile(\n    async ({ lines, resultOutputCallback }) => {\n        const document = parseLines(lines);\n        const invalid = document\n            .nearbyTickets\n            .reduce(\n                (acc, next) => acc.concat(checkInvalidValues(next, document.ticketRules)),\n                []\n            );\n        await resultOutputCallback(invalid.reduce((acc, next) => acc + next, 0));\n    },\n    async ({ lines, outputCallback, resultOutputCallback, sendMessage, pause }) => {\n        const communicator = buildCommunicator(sendMessage, pause);\n        const document = parseLines(lines);\n        await communicator.setup(document.myTicket);\n        const validTickets = document\n            .nearbyTickets\n            .filter((e) => checkInvalidValues(e, document.ticketRules).length === 0);\n        const ticketIndex: TicketIndex = {};\n        const hasBuilt = await buildIndex(document.ticketRules, validTickets, ticketIndex, communicator);\n        if (hasBuilt) {\n            const interestingRules = Object.keys(ticketIndex).filter((e) => e.startsWith(\"departure\"));\n            await resultOutputCallback(\n                interestingRules.reduce((acc, next) => acc * document.myTicket[ticketIndex[next]], 1)\n            );\n        } else {\n            await outputCallback(\"Did not build the index :(\");\n        }\n    },\n    {\n        key: \"ticket-translation\",\n        title: \"Ticket Translation\",\n        embeddedData: true,\n        stars: 2,\n        supportsQuickRunning: true,\n        suggestedDelay: 200\n    }\n);\n","import { NotImplementedError } from \"../../../../support/error\";\nimport { UnknownSizeField } from \"../../../../support/field\";\nimport { Coordinate, Coordinate3d, Coordinate4d } from \"../../../../support/geometry\";\nimport { MessageSender, Pause } from \"../../../entry\";\n\nexport interface IConwayCubesMessageSender {\n    send3dData(activeCubes: () => Array<TimedCubes<Coordinate3d>>): Promise<void>;\n    send4dData(activeCubes: () => Array<TimedCubes<Coordinate4d>>): Promise<void>;\n}\nexport const buildCommunicator = (\n        messageSender: MessageSender | undefined,\n        pause: Pause\n    ): IConwayCubesMessageSender => {\n    if (!messageSender) {\n        return new DummyMessageSender();\n    } else {\n        return new RealMessageSender(messageSender, pause);\n    }\n};\n\ninterface TimedCubes<T> {\n    time: number;\n    cubes: T[];\n}\ntype PrivateConwayCubesMessage = {\n    type: \"3d\",\n    minDepth: number;\n    maxDepth: number;\n    maxTime: number;\n    minHyper?: number;\n    maxHyper?: number;\n    data(time: number, depth: number): string[][]\n} | {\n    minDepth: number;\n    maxDepth: number;\n    maxTime: number;\n    minHyper: number;\n    maxHyper: number;\n    type: \"4d\",\n    data(time: number, depth: number, hyper: number): string[][];\n};\n\nexport type ConwayCubesMessage = {kind: \"ConwayCubesMessage\"} & PrivateConwayCubesMessage;\n\nconst buildMessage = (message: PrivateConwayCubesMessage): ConwayCubesMessage => {\n    return {\n        ...message,\n        kind: \"ConwayCubesMessage\"\n    };\n};\n\nexport function isConwayCubesMessage(message: any): message is ConwayCubesMessage {\n    return (message as ConwayCubesMessage).kind === \"ConwayCubesMessage\";\n}\n\nclass RealMessageSender implements IConwayCubesMessageSender {\n    constructor(private readonly messageSender: MessageSender, private readonly pause: Pause) { }\n    public async send3dData(activeCubes: () => Array<TimedCubes<Coordinate3d>>): Promise<void> {\n        let max = Number.MIN_VALUE;\n        let min = Number.MAX_VALUE;\n        const timedCubes = activeCubes();\n        const allCubes = timedCubes.reduce((acc, next) => acc.concat(next.cubes), [] as Coordinate3d[]);\n        for (const cube of allCubes) {\n            max = Math.max(cube.z, max);\n            min = Math.min(cube.z, min);\n        }\n        const mainData = [...Array(max + 1 - min).keys()].map((k) => k + min).flatMap((depth) => {\n            const result: Array<{time: number; depth: number; data: string[][]}> = [];\n            for (let i = 0; i < timedCubes.length; i++) {\n                const field = new UnknownSizeField<string>();\n                for (const cube of timedCubes[i].cubes) {\n                    if (cube.z === depth) {\n                        field.set({x: cube.x, y: cube.y}, \"#\");\n                    }\n                }\n                const data = field.toMatrix().toString((e) => e || \" \").split(\"\\n\").map((e) => e.split(\"\"));\n                result.push({time: i, depth, data});\n            }\n            return result;\n        });\n        this.messageSender(buildMessage({\n                type: \"3d\",\n                maxDepth: max,\n                minDepth: min,\n                data(time, depth) {\n                    return mainData.filter((e) => e.time === time && e.depth === depth)[0].data;\n                },\n                maxTime: timedCubes.length - 1,\n        }));\n    }\n    public async send4dData(activeCubes: () => Array<TimedCubes<Coordinate4d>>): Promise<void> {\n        let max = Number.MIN_VALUE;\n        let min = Number.MAX_VALUE;\n        let maxHyper = Number.MIN_VALUE;\n        let minHyper = Number.MAX_VALUE;\n        const timedCubes = activeCubes();\n        const allCubes = timedCubes.reduce((acc, next) => acc.concat(next.cubes), [] as Coordinate4d[]);\n        for (const cube of allCubes) {\n            max = Math.max(cube.z, max);\n            min = Math.min(cube.z, min);\n            maxHyper = Math.max(cube.w, max);\n            minHyper = Math.min(cube.w, min);\n        }\n        const mainData = [...Array(max + 1 - min).keys()].map((k) => k + min).flatMap((depth) => {\n            return [...Array(maxHyper + 1 - minHyper).keys()].map((k) => k + min).flatMap((hyper) => {\n                const result: Array<{time: number; depth: number; hyper: number; data: string[][]}> = [];\n                for (let i = 0; i < timedCubes.length; i++) {\n                    const field = new UnknownSizeField<string>();\n                    for (const cube of timedCubes[i].cubes) {\n                        if (cube.z === depth && cube.w === hyper) {\n                            field.set({x: cube.x, y: cube.y}, \"#\");\n                        }\n                    }\n                    const data = field.toMatrix().toString((e) => e || \" \").split(\"\\n\").map((e) => e.split(\"\"));\n                    result.push({time: i, depth, hyper, data});\n                }\n                return result;\n            });\n        });\n        this.messageSender(buildMessage({\n                type: \"4d\",\n                maxDepth: max,\n                minDepth: min,\n                minHyper,\n                maxHyper,\n                data(time, depth, hyper) {\n                    return mainData.filter((e) => e.time === time && e.depth === depth && e.hyper === hyper)[0].data;\n                },\n                maxTime: timedCubes.length - 1,\n        }));\n    }\n\n}\n\nclass DummyMessageSender implements IConwayCubesMessageSender {\n    public async send3dData(activeCubes: () => Array<TimedCubes<Coordinate3d>>): Promise<void> { }\n    public async send4dData(activeCubes: () => Array<TimedCubes<Coordinate4d>>): Promise<void> { }\n}\n","import {\n    Coordinate3d,\n    Coordinate4d,\n    getFullSurrounding,\n    serialization\n} from \"../../../../support/geometry\";\nimport { entryForFile } from \"../../../entry\";\nimport { buildCommunicator } from \"./communication\";\n\nconst mapState = (coordinate: Coordinate3d | Coordinate4d, activeCubes: Set<string>): boolean => {\n    const surrounding = getFullSurrounding(coordinate);\n    const activeSurrounding = surrounding.filter((s) => {\n        const c = serialization.serialize(s);\n        return activeCubes.has(c);\n    });\n    const isActive = activeCubes.has(serialization.serialize(coordinate));\n    if (isActive) {\n        if (activeSurrounding.length === 2 || activeSurrounding.length === 3) {\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        if (activeSurrounding.length === 3) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nexport const conwayCubes = entryForFile(\n    async ({ lines, resultOutputCallback, sendMessage, pause }) => {\n        const communicator = buildCommunicator(sendMessage, pause);\n        let activeCubes: Set<string> = new Set<string>();\n        for (let y = 0; y < lines.length; y++) {\n            for (let x = 0; x < lines[y].length; x++) {\n                if (lines[y][x] === \"#\") {\n                    activeCubes.add(serialization.serialize({x, y, z: 0}));\n                }\n            }\n        }\n        const timedCubes: Array<Set<string>> = [activeCubes];\n        for (let i = 0; i < 6; i++) {\n            const affected = new Set<string>([...activeCubes].flatMap((e) => {\n                const coordinate = serialization.deserialize3d(e);\n                return getFullSurrounding(coordinate).map(serialization.serialize);\n            }));\n            activeCubes = new Set<string>([...affected].filter((e) => {\n                const coordinate = serialization.deserialize3d(e);\n                return mapState(coordinate, activeCubes);\n            }));\n            timedCubes.push(activeCubes);\n        }\n        await communicator.send3dData(() => {\n            return timedCubes.map((cubes, i) => {\n                return {\n                    time: i,\n                    cubes: [...cubes].map(serialization.deserialize3d)\n                };\n            });\n        });\n        await resultOutputCallback(activeCubes.size);\n    },\n    async ({ lines, resultOutputCallback, sendMessage, pause }) => {\n        const communicator = buildCommunicator(sendMessage, pause);\n        let activeCubes: Set<string> = new Set<string>();\n        for (let y = 0; y < lines.length; y++) {\n            for (let x = 0; x < lines[y].length; x++) {\n                if (lines[y][x] === \"#\") {\n                    activeCubes.add(serialization.serialize({x, y, z: 0, w: 0}));\n                }\n            }\n        }\n        const timedCubes: Array<Set<string>> = [activeCubes];\n        for (let i = 0; i < 6; i++) {\n            await pause();\n            const affected = new Set<string>([...activeCubes].flatMap((e) => {\n                const coordinate = serialization.deserialize4d(e);\n                const surrounding = getFullSurrounding(coordinate);\n                if (surrounding.length !== 80) {\n                    throw new Error(\"Invalid surrounding\");\n                }\n                return surrounding.map(serialization.serialize);\n            }));\n            activeCubes = new Set<string>([...affected].filter((e) => {\n                const coordinate = serialization.deserialize4d(e);\n                return mapState(coordinate, activeCubes);\n            }));\n            timedCubes.push(activeCubes);\n        }\n\n        await communicator.send4dData(() => {\n            return timedCubes.map((cubes, i) => {\n                return {\n                    time: i,\n                    cubes: [...cubes].map(serialization.deserialize4d)\n                };\n            });\n        });\n        await resultOutputCallback(activeCubes.size);\n    },\n    {\n        key: \"conway-cubes\",\n        title: \"Conway Cubes\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { entryForFile } from \"../../../entry\";\n\ntype Token = string;\n\nconst getNumber = (token: Token): number | null => {\n    const n = parseInt(token, 10);\n    if (n.toString() === token) {\n        return n;\n    }\n    return null;\n};\n\ntype Operation = ((a: number, b: number) => number);\n\nconst getOperation = (token: Token): Operation | null => {\n    if (token === \"+\") {\n        return (a, b) => a + b;\n    } else if (token === \"*\") {\n        return (a, b) => a * b;\n    } else {\n        return null;\n    }\n};\n\nconst getExpressionParenth = (token: Token): \"start\" | \"end\" | null => {\n    if (token === \"(\") {\n        return \"start\";\n    } else if (token === \")\") {\n        return \"end\";\n    } else {\n        return null;\n    }\n};\n\ntype FlatExpressionToken = number | \"*\" | \"+\";\n\nconst evaluateFlatExpression = (tokens: FlatExpressionToken[]): number => {\n    const current: FlatExpressionToken[] = [...tokens];\n    while (current.includes(\"+\")) {\n        const index = current.indexOf(\"+\");\n        const result = (current[index - 1] as number) + (current[index + 1] as number);\n        current.splice(index - 1, 3, result);\n    }\n    let sum = 1;\n    for (const token of current) {\n        if (token !== \"*\") {\n            if (token === \"+\") {\n                throw new Error();\n            }\n            sum *= token;\n        }\n    }\n    return sum;\n};\n\nconst getFlatExpression = (tokens: Token[], startFrom: number): {expression: FlatExpressionToken[], next: number} => {\n    const flat: FlatExpressionToken[] = [];\n    while (startFrom < tokens.length) {\n        const currentToken = tokens[startFrom];\n        if ([\"*\", \"+\"].includes(currentToken)) {\n            flat.push(currentToken as \"*\" | \"+\");\n            startFrom++;\n            continue;\n        }\n        const n = getNumber(currentToken);\n        if (n !== null) {\n            flat.push(n);\n            startFrom++;\n            continue;\n        }\n\n        const startEnd = getExpressionParenth(currentToken);\n        if (startEnd !== null) {\n            if (startEnd === \"start\") {\n                const nested = getFlatExpression(tokens, startFrom + 1);\n                const value = evaluateFlatExpression(nested.expression);\n                flat.push(value);\n                startFrom = nested.next;\n            } else {\n                return {expression: flat, next: startFrom + 1};\n            }\n            continue;\n        }\n        throw new Error(\"Invalid expression\");\n    }\n    return { expression: flat, next: startFrom };\n};\n\n\nconst evaluateExpression = (tokens: Token[], startFrom: number): {result: number, next: number} => {\n    let currentSum = 0;\n    let currentOperation: Operation | null = null;\n    while (startFrom < tokens.length) {\n        const currentToken = tokens[startFrom];\n        const operation = getOperation(currentToken);\n        if (operation !== null) {\n            currentOperation = operation;\n            startFrom++;\n            continue;\n        }\n\n        const n = getNumber(currentToken);\n        if (n !== null) {\n            if (currentOperation !== null) {\n                currentSum = currentOperation(currentSum, n);\n                currentOperation = null;\n            } else {\n                currentSum = n;\n            }\n            startFrom++;\n            continue;\n        }\n\n        const startEnd = getExpressionParenth(currentToken);\n        if (startEnd !== null) {\n            if (startEnd === \"end\") {\n                return {next: startFrom + 1, result: currentSum};\n            } else {\n                const nested = evaluateExpression(tokens, startFrom + 1);\n                if (currentOperation !== null) {\n                    currentSum = currentOperation(currentSum, nested.result);\n                    currentOperation = null;\n                } else {\n                    currentSum = nested.result;\n                }\n                startFrom = nested.next;\n            }\n            continue;\n        }\n\n        throw new Error(\"Invalid token: \" + currentToken);\n    }\n    return { result: currentSum, next: startFrom };\n};\n\nconst parseLines = (lines: string[]): Token[][] => {\n    return lines.map((line) => line.replaceAll(\" \", \"\").split(\"\"));\n};\n\nexport const operationOrder = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        let sum = 0;\n        for (const expression of input) {\n            sum += evaluateExpression(expression, 0).result;\n        }\n        await outputCallback(sum);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        let sum = 0;\n        for (const expression of input) {\n            const flat = getFlatExpression(expression, 0).expression;\n            const result = evaluateFlatExpression(flat);\n            sum += result;\n        }\n        await outputCallback(sum);\n    },\n    {\n        key: \"operation-order\",\n        title: \"Operation Order\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { start } from \"repl\";\nimport { Queue } from \"../../../../support/data-structure\";\nimport { buildGroupsFromSeparator } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\n\nconst isMatchTerminal = (match: FullMatch): match is TerminalMatch => {\n    return typeof match === \"string\";\n};\n\nconst isMatchList = (match: FullMatch): match is ListMatch => {\n    const cast = match as number[][];\n    return cast.length !== undefined && cast.length > 0 && cast[0].length !== undefined;\n};\n\ntype TerminalMatch = string;\ntype SimpleMatch = number[];\ntype ListMatch = number[][];\ntype FullMatch = TerminalMatch | SimpleMatch | ListMatch;\n\ninterface Rule {\n    key: number;\n    match: FullMatch;\n}\n\ninterface RuleIndex {[key: number]: Rule; }\n\nconst parseRules = (lines: string[]): RuleIndex => {\n    return lines.map((line) => {\n        const [a, b] = line.split(\": \");\n        const clean = b.trim();\n        const match: FullMatch = clean.includes(\"|\") ?\n              (clean.split(\" | \").map((e) => e.split(\" \").map((x) => parseInt(x, 10))))\n            : (clean.includes(\"\\\"\") ? clean.replaceAll(\"\\\"\", \"\") : clean.split(\" \").map((e) => parseInt(e, 10)));\n        return {\n            key: parseInt(a, 10),\n            match\n        } as Rule;\n    }).sort((a, b) => a.key - b.key).reduce((acc, next) => {\n        acc[next.key] = next;\n        return acc;\n    }, {} as RuleIndex);\n};\n\nconst buildAll = (match: FullMatch, rules: RuleIndex): string[] => {\n    if (isMatchTerminal(match)) {\n        return [match];\n    } else if (isMatchList(match)) {\n        const nested = match.flatMap((m) => buildAll(m, rules));\n        return nested;\n    } else {\n        const toConcat = match.map((r) => buildAll(rules[r].match, rules));\n        return combine(toConcat);\n    }\n};\n\nconst combine = (elems: string[][]): string[] => {\n    if (elems.length === 0) {\n        return [\"\"];\n    }\n    if (elems.length === 1) {\n        return elems[0];\n    }\n    return elems[0].flatMap((e) => combine(elems.slice(1)).map((x) => e + x));\n};\n\ninterface QElement {current: Array<string|Rule>; }\n\nconst isBuiltFromStart = (target: string, pool: string[]): boolean => {\n    if (target.length === 0) {\n        return true;\n    }\n    for (const candidate of pool) {\n        if (target.startsWith(candidate)) {\n            return isBuiltFromStart(target.slice(candidate.length), pool);\n        }\n    }\n    return false;\n};\n\nconst isBuiltFromStartEnd = (target: string, startPool: string[], endPool: string[]): boolean => {\n    if (target.length === 0) {\n        return true;\n    }\n    for (const startCandidate of startPool) {\n        if (target.startsWith(startCandidate)) {\n            for (const endCandidate of endPool) {\n                if (target.endsWith(endCandidate)) {\n                    return isBuiltFromStartEnd(\n                        target.slice(startCandidate.length, -endCandidate.length),\n                        startPool,\n                        endPool\n                    );\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst isRepetitionOf = (target: string, repetition: string): boolean => {\n    if (target.length === 0) {\n        return true;\n    }\n    if (!target.startsWith(repetition)) {\n        return false;\n    }\n    return isRepetitionOf(target.slice(repetition.length), repetition);\n};\n\nconst isPalindromeOf = (target: string, a: string, b: string): boolean => {\n    if (target.length === 0) {\n        return true;\n    }\n    if (!target.startsWith(a)) {\n        return false;\n    }\n    if (!target.endsWith(b)) {\n        return false;\n    }\n    return isPalindromeOf(target.slice(a.length, -b.length), a, b);\n};\n\nexport const monsterMessages = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const groups = [...buildGroupsFromSeparator(lines, (e) => e.trim().length === 0)];\n        const rules = parseRules(groups[0]);\n        const data = groups[1];\n        const built = buildAll(rules[0].match, rules);\n        const lookup = new Set<string>(built);\n        await resultOutputCallback(data.filter((e) => lookup.has(e)).length);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const groups = [...buildGroupsFromSeparator(lines, (e) => e.trim().length === 0)];\n        const rules = parseRules(groups[0]);\n        const data = groups[1];\n        const as = buildAll(rules[42].match, rules);\n        const bs = buildAll(rules[31].match, rules);\n        console.log(as);\n        console.log(bs);\n        await resultOutputCallback(data.filter((e) => {\n            for (let i = 1; i < e.length - 1; i++) {\n                const a = e.slice(0, i);\n                const b = e.slice(i);\n                if (isBuiltFromStart(a, as) && isBuiltFromStartEnd(b, as, bs)) {\n                    return true;\n                }\n            }\n            return false;\n        }).length);\n        // const built = buildAll(rules[0].match, rules, []);\n        // await outputCallback(built);\n        // await outputCallback(built.filter(e => e.includes(\"8\") || e.includes(\"11\")));\n    },\n    {\n        key: \"monster-messages\",\n        title: \"Monster Messages\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { factorial } from \"../../../../support/algebra\";\nimport { Counter, DefaultListDictionaryString } from \"../../../../support/data-structure\";\nimport { Coordinate } from \"../../../../support/geometry\";\nimport { buildGroupsFromSeparator } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\n\ninterface Tile {\n    id: number;\n    tile: string[][];\n    matches: Array<{\n        matchesWith: number;\n        operations: TileOperations\n    }>;\n    isPlaced: boolean;\n}\n\nconst rotate = (tile: Tile): Tile => {\n    return {\n        ...tile,\n        tile: tile.tile.map((row, rowIndex) => row.map((col, colIndex) => {\n            return tile.tile[colIndex][tile.tile.length - rowIndex - 1];\n        }))\n    };\n};\n\nconst verticalMatch = (a: Tile, b: Tile): boolean => {\n    for (let i = 0; i < a.tile.length; i++) {\n        if (a.tile[a.tile.length - 1][i] !== b.tile[0][i]) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst horizontalMatch = (a: Tile, b: Tile): boolean => {\n    for (let i = 0; i < a.tile.length; i++) {\n        if (a.tile[i][a.tile.length - 1] !== b.tile[i][0]) {\n            return false;\n        }\n    }\n    return true;\n};\n\ninterface TileOperations {\n    rotations: number;\n    flipped: boolean;\n    inverted: boolean;\n    direction: \"horizontal\" | \"vertical\";\n}\ninterface MatchResult {\n    a: TileOperations;\n    b: TileOperations;\n}\n\nconst match = (a: Tile, b: Tile): MatchResult | false => {\n    const easyMatch = (x: Tile, y: Tile): Omit<Omit<TileOperations, \"rotations\">, \"flipped\"> | false => {\n        if (verticalMatch(x, y)) {\n            return {direction: \"vertical\", inverted: false};\n        }\n        if (verticalMatch(y, x)) {\n            return {direction: \"vertical\", inverted: true};\n        }\n        if (horizontalMatch(x, y)) {\n            return {direction: \"horizontal\", inverted: false};\n        }\n        if (horizontalMatch(y, x)) {\n            return {direction: \"horizontal\", inverted: true};\n        }\n        return false;\n    };\n    const makeMatch = (\n        rot: number,\n        flipped: boolean,\n        inverted: boolean,\n        direction: \"horizontal\" | \"vertical\"\n    ): TileOperations => {\n        return {\n            rotations: (rot + 1) % 4, flipped, inverted, direction\n        };\n    };\n    for (let j = 0; j < 4; j++) {\n        b = rotate(b);\n        const flippedB = flip(b);\n        let result = easyMatch(a, b);\n        if (result) {\n            return {\n                a: makeMatch(0, false, result.inverted, result.direction),\n                b: makeMatch(j, false, result.inverted, result.direction)\n            };\n        }\n\n        result = easyMatch(a, flippedB);\n        if (result) {\n            return {\n                a: makeMatch(0, false, result.inverted, result.direction),\n                b: makeMatch(j, true, result.inverted, result.direction)\n            };\n        }\n\n    }\n    return false;\n};\n\nconst horizontalFlip = (tile: Tile): Tile => rotate(rotate(flip(tile)));\n\nconst flip = (tile: Tile): Tile => {\n    return {\n        ...tile,\n        tile: tile.tile.map((row, rowIndex) => row.map((col, colIndex) => {\n            return tile.tile[tile.tile.length - rowIndex - 1][colIndex];\n        }))\n    };\n};\n\nconst parseLines = (lines: string[]): Tile[] => {\n    const result: Tile[] = [];\n    for (const group of buildGroupsFromSeparator(lines, (e) => e.trim().length === 0)) {\n        result.push({\n            id: parseInt(group[0].split(\" \")[1], 10),\n            tile: group.slice(1).map((line) => line.split(\"\")),\n            matches: [],\n            isPlaced: false\n        });\n    }\n    return result;\n};\n\nconst toString = (tile: Tile): string => {\n    return tile.tile.map((e) => e.join(\"\")).join(\"\\n\");\n};\n\nconst adjust = (fixed: Tile, movable: Tile, direction: \"horizontal\" | \"vertical\"): Tile | null => {\n    const matcher = direction === \"horizontal\" ? horizontalMatch : verticalMatch;\n    for (let i = 0; i < 4; i++) {\n        if (matcher(fixed, movable)) {\n            return movable;\n        }\n        const flipped = flip(movable);\n        if (matcher(fixed, flipped)) {\n            return flipped;\n        }\n        movable = rotate(movable);\n    }\n    return null;\n};\n\ninterface TileIndex {[key: number]: Tile; }\n\nexport const jurassicJigsaw = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        for (const a of input) {\n            for (const b of input) {\n                if (a.id < b.id) {\n                    const isMatching = match(a, b);\n                    if (isMatching) {\n                        a.matches.push({\n                            matchesWith: b.id,\n                            operations: isMatching.a\n                        });\n                        b.matches.push({\n                            matchesWith: a.id,\n                            operations: isMatching.b\n                        });\n                    }\n                }\n            }\n        }\n        const corners = input.filter((k) => k.matches.length === 2);\n        await resultOutputCallback(corners.reduce((acc, next) => acc * next.id, 1));\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const input = parseLines(lines);\n        for (const a of input) {\n            for (const b of input) {\n                if (a.id < b.id) {\n                    const isMatching = match(a, b);\n                    if (isMatching) {\n                        a.matches.push({\n                            matchesWith: b.id,\n                            operations: isMatching.a\n                        });\n                        b.matches.push({\n                            matchesWith: a.id,\n                            operations: {...isMatching.b, inverted: !isMatching.b.inverted}\n                        });\n                    }\n                }\n            }\n        }\n        const tileIndex = input.reduce((acc, next) => {\n            acc[next.id] = next;\n            return acc;\n        }, {} as TileIndex);\n\n        const corners = input.filter((k) => k.matches.length === 2);\n        let topLeftCorner = corners.sort((a, b) => a.id - b.id)[0];\n        // this is not generic!\n        topLeftCorner = flip(horizontalFlip(topLeftCorner));\n        console.log(toString(topLeftCorner));\n        const size = Math.sqrt(input.length);\n        let currentLine: Tile[] = [topLeftCorner];\n        topLeftCorner.isPlaced = true;\n        const result: Tile[][] = [];\n        while (result.length < size) {\n            if (currentLine.length > 0 && currentLine.length < size) {\n                const lastIndex = currentLine.length - 1;\n                const current = currentLine[lastIndex];\n                const candidates = current.matches.map((t) => tileIndex[t.matchesWith]).filter((e) => !e.isPlaced);\n                let target: Tile | null = null;\n                for (const tile of candidates) {\n                    target = adjust(current, tile, \"horizontal\");\n                    if (target) {\n                        break;\n                    }\n                }\n                if (!target) {\n                    throw new Error(\"Could not find horizontal tile\");\n                }\n                currentLine.push(target);\n                target.isPlaced = true;\n            } else if (currentLine.length === size) {\n                result.push(currentLine);\n                currentLine = [];\n            } else if (currentLine.length === 0 && result.length === 0) {\n                throw new Error(\"Cannot write second line without first\");\n            } else {\n                if (currentLine.length !== 0) {\n                    throw new Error(\"What didn't I consider? \" + currentLine.length);\n                }\n                const lastIndex = result.length - 1;\n                const current = result[lastIndex][0];\n                const candidates = current.matches.map((t) => tileIndex[t.matchesWith]).filter((e) => !e.isPlaced);\n                let target: Tile | null = null;\n                for (const tile of candidates) {\n                    target = adjust(current, tile, \"vertical\");\n                    if (target) {\n                        break;\n                    }\n                }\n                if (!target) {\n                    throw new Error(\"Could not find vertical tile\");\n                }\n                currentLine.push(target);\n                target.isPlaced = true;\n            }\n        }\n        let maxiTile: Tile = {\n            id: -1,\n            isPlaced: true,\n            matches: [],\n            tile: []\n        };\n        let currentMaxiLine: string[] = [];\n        const tileSize = result[0][0].tile.length;\n        for (let y = 0; y < size; y++) {\n            for (let innerY = 0; innerY < tileSize; innerY++) {\n                if (innerY === 0 || innerY === tileSize - 1) {\n                    continue;\n                }\n                for (let x = 0; x < size; x++) {\n                    const inner = result[y][x].tile[innerY];\n                    currentMaxiLine = currentMaxiLine.concat(inner.slice(1, -1));\n                }\n                maxiTile.tile.push(currentMaxiLine);\n                currentMaxiLine = [];\n            }\n        }\n        const seaMonsterPattern =\n`                  #\n#    ##    ##    ###\n #  #  #  #  #  #   `.split(\"\\n\");\n        const seaMonsterSize = {y: seaMonsterPattern.length, x: seaMonsterPattern[0].length};\n        const clearSeaMonster = (tile: string[][], corner: Coordinate): void => {\n            const nestedTileSize = {y: tile.length, x: tile[0].length};\n            if (corner.x + seaMonsterSize.x > nestedTileSize.x || corner.y + seaMonsterSize.y > nestedTileSize.y) {\n                return;\n            }\n            for (let y = 0; y < seaMonsterPattern.length; y++) {\n                for (let x = 0; x < seaMonsterPattern[0].length; x++) {\n                    if (seaMonsterPattern[y][x] === \"#\")  {\n                        tile[y + corner.y][x + corner.x] = \"O\";\n                    }\n                }\n            }\n        };\n\n        const seaMonsterMatch = (tile: string[][], corner: Coordinate): boolean => {\n            const nestedTileSize = {y: tile.length, x: tile[0].length};\n            if (corner.x + seaMonsterSize.x > nestedTileSize.x || corner.y + seaMonsterSize.y > nestedTileSize.y) {\n                return false;\n            }\n            for (let y = 0; y < seaMonsterPattern.length; y++) {\n                for (let x = 0; x < seaMonsterPattern[0].length; x++) {\n                    if (seaMonsterPattern[y][x] === \"#\" && tile[y + corner.y][x + corner.x] !== \"#\") {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        const countMonsters = (tile: string[][]): number => {\n            let seaMonsterCount = 0;\n            for (let y = 0; y < tile.length; y++) {\n                for (let x = 0; x < tile[0].length; x++) {\n                    if (seaMonsterMatch(tile, {x, y})) {\n                        seaMonsterCount++;\n                    }\n                }\n            }\n            return seaMonsterCount;\n        };\n        let bestTile: Tile | null = null;\n        for (let i = 0; i < 4; i++) {\n            const current = countMonsters(maxiTile.tile);\n            if (current > 0) {\n                bestTile = maxiTile;\n                break;\n            }\n            const currentFlipped = countMonsters(flip(maxiTile).tile);\n            if (currentFlipped > 0) {\n                bestTile = maxiTile;\n                break;\n            }\n            maxiTile = rotate(maxiTile);\n        }\n        if (!bestTile) {\n            throw new Error(\"Didn't find\");\n        }\n        for (let y = 0; y < bestTile.tile.length; y++) {\n            for (let x = 0; x < bestTile.tile[0].length; x++) {\n                if (seaMonsterMatch(bestTile.tile, {x, y})) {\n                    clearSeaMonster(bestTile.tile, {x, y});\n                }\n            }\n        }\n        await outputCallback(toString(bestTile));\n        await resultOutputCallback(\n            bestTile.tile\n                .map((e) => e.join(\"\"))\n                .join(\"\")\n                .split(\"\")\n                .filter((t) => t === \"#\")\n                .length\n        );\n    },\n    {\n        key: \"jurassic-jigsaw\",\n        title: \"Jurassic Jigsaw\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { CircularDoubleLinkedNode } from \"../../../../support/data-structure\";\nimport { entryForFile } from \"../../../entry\";\n\ntype GameState = {\n    cups: CircularDoubleLinkedNode<number>;\n    length: number;\n    map: {[key: number]: CircularDoubleLinkedNode<number>}\n};\n\nconst serialize = (state: GameState): string => {\n    return state.cups.getAllElements().join(\"\");\n};\n\nconst move = (state: GameState): void => {\n    const currentCupLabel = state.cups.value;\n    const pickedUp = [1, 2, 3].map((i) => state.cups.removeNext()!);\n    let destination = (currentCupLabel - 1 + state.length - 1) % state.length + 1;\n    while (pickedUp.includes(destination)) {\n        destination = (destination - 1 + state.length - 1) % state.length + 1;\n    }\n    if (destination < 1 || destination > state.length) {\n        throw new Error(\"Invalid destination: \" + destination);\n    }\n    let destinationCup = state.map[destination];\n    for (const toPut of pickedUp) {\n        destinationCup = destinationCup.append(toPut);\n        state.map[destinationCup.value] = destinationCup;\n    }\n    state.cups = state.cups.next!;\n};\n\ntype Cup = CircularDoubleLinkedNode<number>;\n\nconst buildMap = (cups: Cup): {[key: number]: Cup} => {\n    const start = cups;\n    const map: {[key: number]: Cup} = {};\n    let current = start;\n    do {\n        map[current.value] = current;\n        current = current.next;\n    } while (current !== start);\n    return map;\n};\n\nconst parseLines = (lines: string[]): GameState => {\n    const cups = lines[0].split(\"\").map((e) => parseInt(e, 10));\n    const startCup = new CircularDoubleLinkedNode<number>(cups[0]);\n    let current = startCup;\n    for (const c of cups.slice(1)) {\n        current = current.append(c);\n    }\n    return {\n        cups: startCup,\n        length: cups.length,\n        map: buildMap(startCup)\n    };\n};\n\nconst createResult = (state: GameState): string => {\n    let cup = state.cups;\n    while (cup.value !== 1) {\n        cup = cup.next;\n    }\n    return cup.getAllElements().join(\"\").slice(1);\n};\n\nconst fillUp = (state: GameState, upTo: number) => {\n    for (let i = state.length; i < upTo; i++) {\n        state.cups.prepend(i + 1);\n    }\n    state.length = upTo;\n    state.map = buildMap(state.cups);\n};\n\nconst range = (start: number, end: number) => {\n    return Array(end - start + 1).fill(0).map((_, idx) => start + idx);\n};\n\n\nexport const crabCups = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const state = parseLines(lines);\n        for (let i = 0; i < 100; i++) {\n            move(state);\n        }\n        await outputCallback(serialize(state));\n        await resultOutputCallback(createResult(state));\n    },\n    async ({ lines, outputCallback, pause, resultOutputCallback }) => {\n        const size = 1000000;\n        const moves = 10000000;\n        const state = parseLines(lines);\n        fillUp(state, size);\n        for (let i = 0; i < moves; i++) {\n            move(state);\n            if (i % 10000 === 0) {\n                await pause();\n            }\n        }\n        await resultOutputCallback(state.map[1].next.value * state.map[1].next.next.value);\n    },\n    {\n        key: \"crab-cups\",\n        title: \"Crab Cups\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { DefaultListDictionaryString } from \"../../../../support/data-structure\";\nimport { entryForFile } from \"../../../entry\";\n\ntype Recipe = {\n    ingredients: string[];\n    allergens: string[];\n};\n\ntype MatchingRecipe = {\n    ingredients: string[];\n    allergens: string[];\n};\n\ntype AllergenIndex = {[key: string]: string};\n\ntype AllergenCandidates = DefaultListDictionaryString<string>;\n\nconst clearIntersection = (\n    a: MatchingRecipe,\n    b: MatchingRecipe,\n    allergen: string,\n    allergenCandidates: AllergenCandidates,\n): boolean => {\n    const aIngredients = new Set<string>(a.ingredients);\n    const bIngredients = new Set<string>(b.ingredients);\n    let hasUpdated = false;\n    for (const ingredient of a.ingredients) {\n        if (!bIngredients.has(ingredient)) {\n            const allergens = allergenCandidates.get(ingredient);\n            const index = allergens.indexOf(allergen);\n            if (index >= 0) {\n                hasUpdated = true;\n                allergens.splice(index, 1);\n            }\n        }\n    }\n    for (const ingredient of b.ingredients) {\n        if (!aIngredients.has(ingredient)) {\n            const allergens = allergenCandidates.get(ingredient);\n            const index = allergens.indexOf(allergen);\n            if (index >= 0) {\n                hasUpdated = true;\n                allergens.splice(index, 1);\n            }\n        }\n    }\n    return hasUpdated;\n};\n\nconst updateAllergens = (\n    recipes: MatchingRecipe[],\n    index: AllergenIndex,\n    candidates: AllergenCandidates,\n): void => {\n    for (const recipe of recipes) {\n        recipe.ingredients = recipe.ingredients.filter((e) => (!index[e]) && candidates.get(e).length > 0);\n        recipe.allergens = recipe.allergens.filter((e) => !Object.values(index).includes(e));\n    }\n\n    let hasUpdated = false;\n    for (const recipe of recipes) {\n        for (const allergen of recipe.allergens) {\n            const currentRecipeCandidates = recipe.ingredients.map((i) => ({\n                ingredient: i,\n                allergens: candidates.get(i)\n            })).filter((e) => e.allergens.includes(allergen));\n            if (currentRecipeCandidates.length === 1) {\n                const found = currentRecipeCandidates[0];\n                hasUpdated = true;\n                index[found.ingredient] = allergen;\n                candidates.get(found.ingredient).length = 0;\n                candidates.get(found.ingredient).push(allergen);\n            }\n        }\n    }\n    if (hasUpdated) {\n        return updateAllergens(recipes, index, candidates);\n    }\n};\n\nconst checkCandidate = (\n    candidate: string,\n    a: MatchingRecipe,\n    b: MatchingRecipe,\n    recipes: MatchingRecipe[],\n    allergenIndex: AllergenIndex,\n    allergenCandidates: AllergenCandidates\n): boolean => {\n    if (a.allergens.includes(candidate) && b.allergens.includes(candidate)) {\n        const result = clearIntersection(a, b, candidate, allergenCandidates);\n        if (result) {\n            updateAllergens(recipes, allergenIndex, allergenCandidates);\n            return true;\n        }\n    }\n    return false;\n};\n\nconst intersect = (\n    recipes: MatchingRecipe[],\n    index: AllergenIndex,\n    allergenCandidates: AllergenCandidates\n): boolean => {\n    for (let i = 0; i < recipes.length; i++) {\n        for (let j = i + 1; j < recipes.length; j++) {\n            const candidates = new Set<string>(recipes[i].allergens.concat(recipes[j].allergens));\n            for (const candidate of candidates) {\n                if (checkCandidate(candidate, recipes[i], recipes[j], recipes, index, allergenCandidates)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst createMatching = (recipes: Recipe[]): {allergens: string[], recipes: MatchingRecipe[]} => {\n    const allAllergens = [...recipes.reduce((acc, next) => {\n        next.allergens.forEach((a) => acc.add(a));\n        return acc;\n    }, new Set<string>())];\n    return {\n        allergens: allAllergens,\n        recipes: recipes.map((r) => ({\n            allergens: r.allergens,\n            ingredients: [...r.ingredients],\n        }))\n    };\n};\n\nconst parseLines = (lines: string[]): Recipe[] => {\n    return lines.map((line) => {\n        const [a, b] = line.split(\" (contains \");\n        return {\n            ingredients: a.split(\" \"),\n            allergens: b.replaceAll(\")\", \"\").split(\", \")\n        };\n    });\n};\n\nexport const allergenAssessment = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n//         lines =\n// `mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\n// trh fvjkl sbzzf mxmxvkd (contains dairy)\n// sqjhc fvjkl (contains soy)\n// sqjhc mxmxvkd sbzzf (contains fish)`.split(\"\\n\");\n        const input = parseLines(lines);\n        const {recipes, allergens} = createMatching(input);\n        const allergenIndex: AllergenIndex = {};\n        const allergenCandidates = new DefaultListDictionaryString<string>();\n        const allIngredients = new Set<string>(recipes.flatMap((r) => r.ingredients));\n        for (const allergen of allergens) {\n            for (const ingredient of allIngredients) {\n                allergenCandidates.add(ingredient, allergen);\n            }\n        }\n        let iterations = 0;\n        while (intersect(recipes, allergenIndex, allergenCandidates)) {\n            iterations++;\n            if (iterations % 10 === 0) {\n                await outputCallback(iterations);\n            }\n        }\n        await outputCallback(iterations);\n        await outputCallback(JSON.stringify(allergenIndex));\n        const safeIngredients = [...allIngredients].filter((e) => !allergenIndex[e]);\n        await outputCallback(safeIngredients);\n        const count = input.reduce((acc, next) => {\n            const interesting = next.ingredients.filter((e) => safeIngredients.includes(e));\n            return acc + interesting.length;\n        }, 0);\n        await resultOutputCallback(count);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n//         lines =\n// `mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\n// trh fvjkl sbzzf mxmxvkd (contains dairy)\n// sqjhc fvjkl (contains soy)\n// sqjhc mxmxvkd sbzzf (contains fish)`.split(\"\\n\");\n        const input = parseLines(lines);\n        const {recipes, allergens} = createMatching(input);\n        const allergenIndex: AllergenIndex = {};\n        const allergenCandidates = new DefaultListDictionaryString<string>();\n        const allIngredients = new Set<string>(recipes.flatMap((r) => r.ingredients));\n        for (const allergen of allergens) {\n            for (const ingredient of allIngredients) {\n                allergenCandidates.add(ingredient, allergen);\n            }\n        }\n        while (intersect(recipes, allergenIndex, allergenCandidates)) {\n            // nothing to do here\n        }\n        const canonical = Object.keys(allergenIndex)\n            .sort((a, b) => allergenIndex[a].localeCompare(allergenIndex[b]))\n            .join(\",\");\n        await resultOutputCallback(canonical);\n    },\n    {\n        key: \"allergen-assessment\",\n        title: \"Allergen Assessment\",\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { buildGroupsFromSeparator } from \"../../../../support/sequences\";\nimport { entryForFile } from \"../../../entry\";\n\ntype Deck = number[];\n\ntype GameState = {\n    a: Deck;\n    b: Deck;\n};\n\nconst serializeState = (state: GameState): string => {\n    return JSON.stringify(state);\n};\n\nconst parseLines = (lines: string[]): GameState => {\n    const decks: Deck[] = [];\n    for (const group of buildGroupsFromSeparator(lines, (e) => !e)) {\n        decks.push(group.slice(1).map((e) => parseInt(e, 10)));\n    }\n    return {\n        a: decks[0],\n        b: decks[1]\n    };\n};\n\nconst winRecursiveRound = (gameState: GameState): keyof GameState => {\n    // console.log(\"=== Game \" + level + \" ===\");\n    const memo = new Set<string>();\n    while (true) {\n        const result = playRecursiveRound(gameState, memo);\n        if (result) {\n            return result;\n        }\n    }\n};\n\nlet level = 1;\n\nconst playRecursiveRound = (gameState: GameState, memo: Set<string>): false | keyof GameState => {\n    if (memo.has(serializeState(gameState))) {\n        return \"a\";\n    }\n    memo.add(serializeState(gameState));\n    if (gameState.a.length === 0) {\n        return \"b\";\n    } else if (gameState.b.length === 0) {\n        return \"a\";\n    }\n    const firstA = gameState.a.shift()!;\n    const firstB = gameState.b.shift()!;\n    if (gameState.a.length >= firstA && gameState.b.length >= firstB) {\n        const nestedState: GameState = {\n            a: gameState.a.slice(0, firstA),\n            b: gameState.b.slice(0, firstB)\n        };\n        level++;\n        const winner = winRecursiveRound(nestedState);\n        level--;\n        if (winner === \"a\") {\n            gameState.a.push(firstA);\n            gameState.a.push(firstB);\n        } else {\n            gameState.b.push(firstB);\n            gameState.b.push(firstA);\n        }\n        return false;\n    } else {\n        const winner = firstA > firstB ? gameState.a : gameState.b;\n        if (firstA > firstB) {\n            winner.push(firstA);\n        }\n        winner.push(firstB);\n        if (firstA < firstB) {\n            winner.push(firstA);\n        }\n        if (gameState.a.length === 0) {\n            return \"b\";\n        } else if (gameState.b.length === 0) {\n            return \"a\";\n        } else {\n            return false;\n        }\n    }\n};\n\nconst playRound = (gameState: GameState): false | keyof GameState => {\n    if (gameState.a.length === 0) {\n        return \"b\";\n    } else if (gameState.b.length === 0) {\n        return \"a\";\n    }\n    const firstA = gameState.a.shift()!;\n    const firstB = gameState.b.shift()!;\n    const winner = firstA > firstB ? gameState.a : gameState.b;\n    if (firstA > firstB) {\n        winner.push(firstA);\n    }\n    winner.push(firstB);\n    if (firstA < firstB) {\n        winner.push(firstA);\n    }\n    if (gameState.a.length === 0) {\n        return \"b\";\n    } else if (gameState.b.length === 0) {\n        return \"a\";\n    } else {\n        return false;\n    }\n};\n\nconst calculateScore  = (deck: Deck): number =>\n    [...deck.reverse()]\n        .map((e, i) => e * (i + 1))\n        .reduce((acc, next) => acc + next, 0);\n\nexport const crabCombat = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback, setAutoStop, pause }) => {\n        setAutoStop();\n        const state = parseLines(lines);\n        while (true) {\n            const result = playRound(state);\n            await pause();\n            await outputCallback(state.a.length, true);\n            if (result) {\n                const winnerDeck = state[result];\n                await resultOutputCallback(calculateScore(winnerDeck));\n                return;\n            }\n        }\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const state = parseLines(lines);\n        const winner = winRecursiveRound(state);\n        await resultOutputCallback(calculateScore(state[winner]));\n    },\n    {\n        key: \"crab-combat\",\n        title: \"Crab Combat\",\n        embeddedData: true,\n        supportsQuickRunning: true,\n        suggestedDelay: 0,\n        customComponent: \"pause-and-run\",\n        stars: 2\n    }\n);\n","import { entryForFile } from \"../../../entry\";\nimport {getHexSurrounding, HexCubeCoordinate, pointyHexDirections, serialization, sumHexCoordinates} from \"../../../../support/hex-geometry\";\n\ntype Direction = keyof typeof pointyHexDirections;\n\nconst parseLines = (lines: string[]): Direction[][] => {\n    return lines.map((line) => {\n        const directions: Direction[] = [];\n        let modifier: \"north\" | \"south\" | null = null;\n        for (const token of line) {\n            if (token === \"n\") {\n                modifier = \"north\";\n            } else if (token === \"s\") {\n                modifier = \"south\";\n            } else if (token === \"e\") {\n                if (modifier === \"north\") {\n                    directions.push(\"northEast\");\n                } else if (modifier === \"south\") {\n                    directions.push(\"southEast\");\n                } else {\n                    directions.push(\"east\");\n                }\n                modifier = null;\n            } else if (token === \"w\") {\n                if (modifier === \"north\") {\n                    directions.push(\"northWest\");\n                } else if (modifier === \"south\") {\n                    directions.push(\"southWest\");\n                } else {\n                    directions.push(\"west\");\n                }\n                modifier = null;\n            }\n        }\n        return directions;\n    });\n};\n\nexport const lobbyLayout = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const reference: HexCubeCoordinate = {\n            x: 0,\n            y: 0,\n            z: 0\n        };\n        const black = new Set<string>();\n        const instructions = parseLines(lines);\n        for (const instruction of instructions) {\n            const tile = instruction.reduce(\n                (acc, next) => sumHexCoordinates(acc, pointyHexDirections[next]),\n                reference\n            );\n            const serialized = serialization.serialize(tile);\n            if (black.has(serialized)) {\n                black.delete(serialized);\n            } else {\n                black.add(serialized);\n            }\n        }\n        await resultOutputCallback(black.size);\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const reference: HexCubeCoordinate = {\n            x: 0,\n            y: 0,\n            z: 0\n        };\n        let black = new Set<string>();\n        const instructions = parseLines(lines);\n        for (const instruction of instructions) {\n            const tile = instruction.reduce(\n                (acc, next) => sumHexCoordinates(acc, pointyHexDirections[next]),\n                reference\n            );\n            const serialized = serialization.serialize(tile);\n            if (black.has(serialized)) {\n                black.delete(serialized);\n            } else {\n                black.add(serialized);\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            const interesting = new Set<string>([...black.values()]\n                .map(serialization.deserialize)\n                .flatMap(getHexSurrounding)\n                .map(serialization.serialize)).values();\n            const newBlack = new Set<string>();\n            for (const tile of interesting) {\n                const coordinates = serialization.deserialize(tile);\n                const blackNeighbours = getHexSurrounding(coordinates)\n                    .map(serialization.serialize)\n                    .filter((e) => black.has(e))\n                    .length;\n                const isBlack = black.has(tile);\n                if (isBlack) {\n                    if (blackNeighbours > 0 && blackNeighbours <= 2) {\n                        newBlack.add(tile);\n                    }\n                } else {\n                    if (blackNeighbours === 2) {\n                        newBlack.add(tile);\n                    }\n                }\n            }\n            black = newBlack;\n        }\n        await resultOutputCallback(black.size);\n    },\n    {\n        key: \"lobby-layout\",\n        title: \"Lobby Layout\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { entryForFile } from \"../../../entry\";\n\nconst constants = {\n    subjectNumber: 7n,\n    mod: 20201227n,\n};\n\nconst hack = (publicKey: number): number => {\n    let loopSize = 0;\n    const subjectNumber = constants.subjectNumber;\n    const mod = constants.mod;\n    let current = 1n;\n    const target = BigInt(publicKey);\n    while (current !== target) {\n        current *= subjectNumber;\n        current %= mod;\n        loopSize++;\n    }\n    return loopSize;\n};\n\nconst calculate = (subjectNumber: number, loopSize: number): number => {\n    const mod = constants.mod;\n    let current = 1n;\n    const bigSubject = BigInt(subjectNumber);\n    while (loopSize -- > 0) {\n        current *= bigSubject;\n        current %= mod;\n    }\n    return Number(current);\n};\n\nexport const comboBreaker = entryForFile(\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        const [card, door] = lines.map((l) => parseInt(l, 10));\n        const doorLoopSize = hack(door);\n        const encryptionKey = calculate(card, doorLoopSize);\n        await resultOutputCallback(encryptionKey);\n\n    },\n    async ({ lines, outputCallback, resultOutputCallback }) => {\n        throw Error(\"Not implemented\");\n    },\n    {\n        key: \"combo-breaker\",\n        title: \"Combo Breaker\",\n        supportsQuickRunning: true,\n        embeddedData: true,\n        stars: 2\n    }\n);\n","import { binaryBoarding } from \"./binary-boarding\";\nimport { passportProcessing } from \"./passport-processing\";\nimport { passwordPhilosophy } from \"./password-philosophy\";\nimport { customCustoms } from \"./custom-customs\";\nimport { reportRepair } from \"./report-repair\";\nimport { tobogganTrajectory } from \"./toboggan-trajectory\";\nimport { handyHaversacks } from \"./handy-haversacks\";\nimport { handheldHalting } from \"./handheld-halting\";\nimport { encodingError } from \"./encoding-error\";\nimport { adapterArray } from \"./adapter-array\";\nimport { seatingSystem } from \"./seating-system\";\nimport { rainRisk } from \"./rain-risk\";\nimport { shuttleSearch } from \"./shuttle-search\";\nimport { dockingData } from \"./docking-data\";\nimport { rambunctiousRecitation } from \"./rambunctious-recitation\";\nimport { ticketTranslation } from \"./ticket-translation\";\nimport { conwayCubes } from \"./conway-cubes\";\nimport { operationOrder } from \"./operation-order\";\nimport { monsterMessages } from \"./monster-messages\";\nimport { jurassicJigsaw } from \"./jurassic-jigsaw\";\nimport { crabCups } from \"./crab-cups\";\nimport { allergenAssessment } from \"./allergen-assessment\";\nimport { crabCombat } from \"./crab-combat\";\nimport { lobbyLayout } from \"./lobby-layout\";\nimport { comboBreaker } from \"./combo-breaker\";\n\nexport const entries = [\n        reportRepair,\n        passwordPhilosophy,\n        tobogganTrajectory,\n        passportProcessing,\n        binaryBoarding,\n        customCustoms,\n        handyHaversacks,\n        handheldHalting,\n        encodingError,\n        adapterArray,\n        seatingSystem,\n        rainRisk,\n        shuttleSearch,\n        dockingData,\n        rambunctiousRecitation,\n        ticketTranslation,\n        conwayCubes,\n        operationOrder,\n        monsterMessages,\n        jurassicJigsaw,\n        allergenAssessment,\n        crabCombat,\n        crabCups,\n        lobbyLayout,\n        comboBreaker\n];\n","import { Entry } from \"./entry\";\n\nimport {entries as entries2015} from \"./single-entries/2015\";\nimport {entries as entries2016} from \"./single-entries/2016\";\nimport {entries as entries2017} from \"./single-entries/2017\";\nimport {entries as entries2018} from \"./single-entries/2018\";\nimport {entries as entries2019} from \"./single-entries/2019\";\nimport {entries as entries2020} from \"./single-entries/2020\";\n\nexport interface EntryRoute extends EntryRouteBase {\n    date: number;\n}\n\ninterface EntryRouteBase {\n    name: string;\n    title: string;\n    entry: Entry;\n    date?: number;\n    stars?: 1 | 2;\n}\n\nexport type EntryListYearElement = EntryRouteBase | Entry;\n\nconst isEntryRouteBase = (e: Entry | EntryRouteBase): e is EntryRouteBase => {\n    return (e as EntryRouteBase).name !== undefined;\n};\n\nfunction enrichList(entries: EntryListYearElement[]): EntryRoute[] {\n    let index = 0;\n    return entries.map((e) => {\n        index++;\n        if (isEntryRouteBase(e)) {\n            if (e.date !== undefined) {\n                index = e.date;\n            }\n            return { ...e, date: index };\n        } else {\n            const entry = e;\n            if (entry.metadata === undefined) {\n                throw new Error(\"Entry must have metadata if not specified in here\");\n            }\n            if (entry.metadata.date !== undefined) {\n                index = entry.metadata.date;\n            }\n            return {\n                name: entry.metadata.key,\n                title: entry.metadata.title,\n                stars: entry.metadata.stars,\n                date: index,\n                entry,\n            };\n        }\n    });\n}\n\n\nexport const entryList: { [key: string]: EntryRoute[] } = {\n    2015: enrichList(entries2015),\n    2016: enrichList(entries2016),\n    2017: enrichList(entries2017),\n    2018: enrichList(entries2018),\n    2019: enrichList(entries2019),\n    2020: enrichList(entries2020)\n};\n\n","\n\n\n\n\n\n\n\nimport Year from \"./components/Year.vue\";\nimport Navbar from \"./components/Navbar.vue\";\nimport { Component, Vue } from \"vue-property-decorator\";\nimport { entryList, EntryRoute } from \"./entries/entryList\";\nimport { baseState, updateYear } from \"./state/state\";\n@Component({\n    components: {\n        Navbar\n    }\n})\nexport default class App extends Vue {\n    private entryByYears: { [key: string]: EntryRoute[] } | null = null;\n    public created() {\n        this.entryByYears = entryList;\n    }\n}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=715410be&lang=pug&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"home\"},[_vm._l((_vm.stars),function(star,index){return _c('div',{staticClass:\"falling-star\",style:({left: star.left+'%', animationDuration: star.duration+'s', animationDelay: -star.delay+'s'})},[_vm._m(0,true)])}),_c('div',{staticClass:\"title\"},[_vm._v(\"Solutions for the Advent of Code\")]),_c('div',{staticClass:\"year-tree\"},[_vm._m(1),_vm._l((this.yearsByRow),function(years,index){return _c('div',{key:index,staticClass:\"tree-floor\"},_vm._l((years),function(year,yearIndex){return _c('div',{key:yearIndex,staticClass:\"year\"},[(year)?_c('router-link',{attrs:{\"to\":{name: 'entries'}}},[_c('div',{staticClass:\"year-entry\",on:{\"click\":function($event){return _vm.selectYear(year)}}},[_vm._v(_vm._s(year))])]):_c('div',{staticClass:\"fake-year\"},[_vm._v(\"2020\")])],1)}),0)}),_vm._m(2)],2)],2)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"rotating-star\"},[_c('div',{staticClass:\"animated-star\"})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"tree-floor\"},[_c('div',{staticClass:\"star\"},[_vm._v(\"*\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"tree-floor\"},[_c('div',{staticClass:\"year tree-trunk\"},[_c('div',[_vm._v(\"2020\")])])])}]\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from \"vue\";\nimport { updateYear } from \"../state/state\";\nimport { randrange } from \"../support/random\";\nexport default Vue.extend({\n    props: {\n        years: Array as () => string[]\n    },\n    computed: {\n        stars(): Array<{left: number; duration: number; delay: number}> {\n            const result: Array<{left: number; duration: number; delay: number}> = [];\n            for (let i = 0; i < 50; i++) {\n                const left = randrange(0, 100);\n                const duration = randrange(10, 50);\n                const delay = randrange(0, duration);\n                result.push({left, duration, delay});\n            }\n            return result;\n        },\n        yearsByRow() {\n            const k = this.years.length;\n            const biggestFloor = Math.ceil((-1 + Math.sqrt(1 + 8 * k)) / 2);\n            const result: string[][] = [];\n            const current = {\n                floor: [] as string[],\n                size: 1\n            };\n            const years = [...this.years].reverse();\n            for (const year of years) {\n                current.floor.push(year);\n                if (current.floor.length === current.size) {\n                    result.push(current.floor);\n                    current.floor = [];\n                    current.size++;\n                }\n            }\n            if (current.floor.length > 0) {\n                while (current.floor.length < current.size) {\n                    current.floor.push(\"\");\n                }\n                result.push(current.floor);\n            }\n            return result;\n\n        }\n    },\n    methods: {\n        selectYear(year: string) {\n            updateYear(year);\n        }\n    }\n\n});\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Home.vue?vue&type=template&id=001738db&scoped=true&lang=pug&\"\nimport script from \"./Home.vue?vue&type=script&lang=ts&\"\nexport * from \"./Home.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Home.vue?vue&type=style&index=0&id=001738db&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"001738db\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"entries-wrapper\"},[_c('ul',{staticClass:\"entries\"},_vm._l((_vm.entries),function(entry){return _c('li',{key:entry.name},[_c('CalendarEntry',{attrs:{\"title\":entry.title,\"date\":entry.date,\"name\":entry.name,\"stars\":entry.stars}})],1)}),0)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('router-link',{staticClass:\"calendar-cell\",attrs:{\"to\":{name: _vm.name}}},[_c('div',{staticClass:\"header\"},[_vm._v(\" \"+_vm._s(_vm.ordinalDate)),_c('div',{staticClass:\"icon right rotated-right\"},[_c('font-awesome-icon',{attrs:{\"icon\":\"gift\"}})],1)]),_c('div',{staticClass:\"title\"},[_vm._v(\" \"+_vm._s(_vm.title))]),_c('div',{staticClass:\"stars\"},_vm._l((_vm.starObjects),function(star){return _c('div',{key:star.key,staticClass:\"star\"},[_c('span',{style:({visibility: star.isFull ? 'visible' : 'hidden'})},[_vm._v(\"\")])])}),0)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export function ordinalOf(i: number) {\n    const j = i % 10;\n    const k = i % 100;\n    if (j === 1 && k !== 11) {\n        return i + \"st\";\n    }\n    if (j === 2 && k !== 12) {\n        return i + \"nd\";\n    }\n    if (j === 3 && k !== 13) {\n        return i + \"rd\";\n    }\n    return i + \"th\";\n}\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from \"vue\";\nimport { baseState } from \"../state/state\";\nimport { ordinalOf } from \"../support/string\";\nexport default Vue.extend({\n    props: {\n        title: String,\n        date: Number,\n        name: String,\n        stars: Number,\n    },\n    data() {\n        return {\n            dates: baseState.dates\n        };\n    },\n    computed: {\n        ordinalDate(): string {\n            return ordinalOf(this.date);\n        },\n        starObjects(): Array<{key: number, isFull: boolean}> {\n            return [...Array(2).keys()].map((i) => ({\n                key: i,\n                isFull: i < this.stars\n            }));\n        }\n\n    }\n});\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CalendarEntry.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CalendarEntry.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./CalendarEntry.vue?vue&type=template&id=1bd1c98b&scoped=true&lang=pug&\"\nimport script from \"./CalendarEntry.vue?vue&type=script&lang=ts&\"\nexport * from \"./CalendarEntry.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./CalendarEntry.vue?vue&type=style&index=0&id=1bd1c98b&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1bd1c98b\",\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue } from \"vue-property-decorator\";\n\nimport { entryList } from \"../entries/entryList\";\nimport { baseState } from \"../state/state\";\n\nimport CalendarEntry from \"../components/CalendarEntry.vue\";\n\ninterface Entry {\n    name: string;\n    title: string;\n}\n\n@Component({\n    components: { CalendarEntry }\n})\nexport default class Entries extends Vue {\n\n    private dates = baseState.dates;\n\n    public get entries(): Entry[] {\n        return entryList[this.dates.year + \"\"];\n    }\n    // public entries: Entry[] = [entryList[\"2018\"], entryList[\"2019\"]].flatMap(\n    //     e => e\n    // );\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Entries.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Entries.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Entries.vue?vue&type=template&id=1763c634&lang=pug&\"\nimport script from \"./Entries.vue?vue&type=script&lang=ts&\"\nexport * from \"./Entries.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Entries.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('EntryTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"year\":_vm.year,\"disabled\":_vm.disabled,\"entryKey\":this.entry.metadata.key},on:{\"file-loaded\":_vm.readFile}},[(_vm.supportsQuickRunning)?_c('div',{staticClass:\"quick-run\"},[_c('label',[_vm._v(\"Quick run\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.quickRun),expression:\"quickRun\"}],attrs:{\"type\":\"checkbox\",\"disabled\":_vm.executing},domProps:{\"checked\":Array.isArray(_vm.quickRun)?_vm._i(_vm.quickRun,null)>-1:(_vm.quickRun)},on:{\"change\":function($event){var $$a=_vm.quickRun,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.quickRun=$$a.concat([$$v]))}else{$$i>-1&&(_vm.quickRun=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.quickRun=$$c}}}}),(_vm.time)?_c('label',[_vm._v(\"Time: \"+_vm._s(_vm.time))]):_vm._e()]):_vm._e(),_c('div',{staticClass:\"output\"},[_c('EntrySimpleOutput',{key:_vm.$route.path,attrs:{\"lines\":_vm.output},on:{\"print-factory\":_vm.readFactory}})],1),(_vm.showAdditionalInput)?_c('div',{staticClass:\"input\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.inputLine),expression:\"inputLine\"}],attrs:{\"type\":\"text\",\"disabled\":!_vm.disabled},domProps:{\"value\":(_vm.inputLine)},on:{\"keyup\":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"enter\",13,$event.key,\"Enter\")){ return null; }return _vm.sendInput($event)},\"input\":function($event){if($event.target.composing){ return; }_vm.inputLine=$event.target.value}}}),_c('button',{attrs:{\"disabled\":!_vm.disabled},on:{\"click\":_vm.sendInput}},[_vm._v(\"Send\")]),_c('button',{attrs:{\"disabled\":!_vm.disabled},on:{\"click\":_vm.sendClose}},[_vm._v(\"Close\")])]):_vm._e()])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"wrapper\"},[_c('EntryTitle',{attrs:{\"date\":_vm.id,\"name\":_vm.title,\"year\":_vm.year}}),_c('EntryInput',{key:_vm.$route.path,attrs:{\"disabled\":_vm.disabled,\"entryKey\":_vm.entryKey,\"year\":_vm.year},on:{\"file-loaded\":_vm.fileLoaded}}),_vm._t(\"default\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"title\"},[_c('div',{staticClass:\"date\"},[_vm._v(_vm._s(_vm.fullDate)),_c('a',{staticClass:\"link small\",attrs:{\"href\":_vm.link,\"target\":\"_blank\"}},[_c('font-awesome-icon',{attrs:{\"icon\":\"link\"}})],1)]),_c('div',{staticClass:\"name\"},[_vm._v(_vm._s(_vm.name)),_c('a',{staticClass:\"link big\",attrs:{\"href\":_vm.link,\"target\":\"_blank\"}},[_c('font-awesome-icon',{attrs:{\"icon\":\"link\"}})],1)]),_c('hr')])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop } from \"vue-property-decorator\";\nimport { ordinalOf } from \"../support/string\";\n@Component({})\nexport default class EntryTitle extends Vue {\n    @Prop() private date!: number;\n    @Prop() private name!: string;\n    @Prop() private year!: string;\n    private get fullDate() {\n        return `December ${ordinalOf(this.date)}, ${this.year}`;\n    }\n\n    private get link() {\n        return `https://adventofcode.com/${this.year}/day/${this.date}`;\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTitle.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTitle.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryTitle.vue?vue&type=template&id=2d88f678&scoped=true&lang=pug&\"\nimport script from \"./EntryTitle.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryTitle.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryTitle.vue?vue&type=style&index=0&id=2d88f678&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"2d88f678\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"input\"},[(!_vm.noInput)?_c('div',[_c('EntryFileInput',{attrs:{\"readFile\":\"true\",\"disabled\":_vm.disabled,\"isUsingEmbedded\":_vm.forceEmbedded},on:{\"file-content\":_vm.readFileContent}}),(_vm.hasEmbedded)?_c('div',{staticClass:\"embedded\"},[(_vm.forceEmbedded)?_c('button',{attrs:{\"disabled\":\"\"}},[_vm._v(\"Using embedded data\")]):_c('button',{on:{\"click\":_vm.useEmbedded}},[_vm._v(\"Use embedded\")])]):_vm._e()],1):_c('div',{style:({marginBottom: '1em'})},[_vm._v(\"No input available: you cannot select your input for the current year in order to avoid cheating!\")]),_c('div',{staticClass:\"choices\",class:{hidden: _vm.hideChoices}},[_c('EntryChoice',{key:this.$route.path,attrs:{\"disabled\":_vm.disabled},on:{\"execute\":_vm.loadFile}})],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"file-selection\"},[_c('button',{staticClass:\"selection-action\",attrs:{\"disabled\":_vm.disabled},on:{\"click\":_vm.clickSelectionAction}},[_vm._v(_vm._s(this.selectionLabel))]),_c('input',{ref:\"file-input\",attrs:{\"type\":\"file\"},on:{\"change\":_vm.filesUpdated}}),_c('label',{staticClass:\"selected-file\",class:{hidden: !this.isFileSelected}},[_vm._v(_vm._s(this.shownName))]),_c('hr',{class:{hidden: !this.isFileSelected}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { error } from \"./log\";\n\nexport function readFileFromInput(file: File, onSuccess: ((content: string) => void)) {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        onSuccess(fileReader.result as string);\n    };\n    fileReader.onerror = () => {\n        error(\"File read failure\");\n    };\n    fileReader.readAsText(file);\n}\n\nexport default (callback: (lines: string[]) => void) => {\n    const lines: string[] = [];\n    callback(lines);\n};\n","\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport { readFileFromInput } from \"../support/file-reader\";\n@Component({})\nexport default class EntryFileInput extends Vue {\n    @Prop({ default: false }) public disabled!: boolean;\n    @Prop({ default: false }) public readFile!: boolean;\n    @Prop({ default: false }) public isUsingEmbedded!: boolean;\n\n    public shownName: string = \"\";\n    public isFileSelected: boolean = false;\n\n    public clickSelectionAction() {\n        this.chooseFile();\n    }\n\n    @Watch(\"isUsingEmbedded\")\n    public watchIsUsingEmbedded(newValue: boolean) {\n        if (newValue) {\n            this.isFileSelected = false;\n        }\n    }\n\n    public filesUpdated(e: any) {\n        const fileName = this.getFileName();\n        if (fileName) {\n            this.isFileSelected = true;\n            this.shownName = fileName;\n            console.log(this.readFile);\n            if (this.readFile) {\n                const component = this;\n                readFileFromInput(this.input!.files![0], (content: string) => {\n                    const emitResult = component.$emit(\"file-content\", content);\n                });\n            }\n        }\n    }\n\n    public get selectionLabel(): string {\n        if (this.isFileSelected) {\n            return \"Change input file\";\n        } else {\n            return \"Select input file\";\n        }\n    }\n\n    private get input() {\n        const input = this.$refs[\"file-input\"] as HTMLInputElement;\n        return input;\n    }\n\n    private getFileName() {\n        const input = this.input;\n        if (input && input.files) {\n            return input.files[0].name;\n        } else {\n            return null;\n        }\n    }\n\n    private resetInput() {\n        const input = this.input;\n        if (input) {\n            this.isFileSelected = false;\n            input.value = \"\";\n            this.shownName = \"\";\n        }\n    }\n\n    private chooseFile() {\n        const input = this.input;\n        if (input) {\n            input.click();\n        }\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryFileInput.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryFileInput.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryFileInput.vue?vue&type=template&id=27b03c87&scoped=true&lang=pug&\"\nimport script from \"./EntryFileInput.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryFileInput.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryFileInput.vue?vue&type=style&index=0&id=27b03c87&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"27b03c87\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"entry-choice\",class:{hidden: _vm.hidden}},[_c('label',{staticClass:\"question\"},[_vm._v(\"Which entry?\")]),_c('div',{staticClass:\"choices\"},[_c('label',[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.choice),expression:\"choice\"}],attrs:{\"type\":\"radio\",\"value\":\"first\",\"disabled\":_vm.disabled},domProps:{\"checked\":_vm._q(_vm.choice,\"first\")},on:{\"change\":function($event){_vm.choice=\"first\"}}}),_vm._v(\"First\")]),_c('label',[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.choice),expression:\"choice\"}],attrs:{\"type\":\"radio\",\"value\":\"second\",\"disabled\":_vm.disabled},domProps:{\"checked\":_vm._q(_vm.choice,\"second\")},on:{\"change\":function($event){_vm.choice=\"second\"}}}),_vm._v(\"Second\")])]),_c('button',{attrs:{\"disabled\":_vm.disabled},on:{\"click\":_vm.show}},[_vm._v(\"Execute\")])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop } from \"vue-property-decorator\";\n@Component({})\nexport default class EntryChoice extends Vue {\n    @Prop({ default: false }) public hidden!: boolean;\n    @Prop({ default: false }) public disabled!: boolean;\n    private choice: string = \"first\";\n    public show() {\n        const emitResult = this.$emit(\"execute\", this.choice);\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryChoice.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryChoice.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryChoice.vue?vue&type=template&id=a70d5e66&scoped=true&lang=pug&\"\nimport script from \"./EntryChoice.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryChoice.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryChoice.vue?vue&type=style&index=0&id=a70d5e66&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"a70d5e66\",\n  null\n  \n)\n\nexport default component.exports","import { entryList } from \"./entryList\";\n\nconst parse = (data: string): string[] => data.trim().split(\"\\n\");\n\nexport const disabledYear: string | undefined = \"2020\";\n\nexport const embeddedLines = Object.keys(entryList).flatMap((year) => entryList[year].map((entry) => {\n    return {\n        year,\n        entry\n    };\n})).filter((e) => e.entry.entry.metadata && e.entry.entry.metadata.embeddedData)\n.reduce((acc, next) => {\n    const metadata = next.entry.entry.metadata!;\n    acc[metadata.key] = async () => {\n        const key = metadata.embeddedData === true ? metadata.key : metadata.embeddedData!;\n        const data = (await import(\n            /* webpackChunkName: \"[request]\" */\n            `../../data/${next.year}/${key}.txt`\n        )).default as string;\n        return parse(data);\n    };\n    return acc;\n}, {} as { [key: string]: () => Promise<string[]>});\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport EntryFileInput from \"@/components/EntryFileInput.vue\";\nimport EntryChoice from \"@/components/EntryChoice.vue\";\nimport { Component, Vue, Emit, Prop, Watch } from \"vue-property-decorator\";\nimport { Choice } from \"../constants/choice\";\nimport { EntryFileHandling } from \"../entries/entry\";\nimport { disabledYear, embeddedLines } from \"../entries/embeddedData\";\n\n@Component({\n    components: {\n        EntryFileInput,\n        EntryChoice\n    }\n})\nexport default class EntryInput extends Vue {\n    @Prop({ default: false }) public disabled!: boolean;\n    @Prop({required: true, default: \"\"}) public entryKey!: string;\n    @Prop({required: true}) public year!: string;\n\n    private inputContent: string | null = null;\n    private forceEmbedded: boolean = false;\n\n    public get noInput(): boolean {\n        return this.entryKey in embeddedLines && this.year === disabledYear;\n    }\n\n    public get hasEmbedded(): boolean {\n        return this.entryKey in embeddedLines;\n    }\n\n    public get hideChoices(): boolean {\n        return this.inputContent === null && !(this.noInput || this.forceEmbedded);\n    }\n\n    public readFileContent(content: string) {\n        this.inputContent = content;\n        this.forceEmbedded = false;\n    }\n\n    public useEmbedded() {\n        this.forceEmbedded = true;\n        this.inputContent = null;\n    }\n\n    @Emit(\"file-loaded\")\n    public async loadFile(choice: Choice): Promise<EntryFileHandling> {\n        if (this.noInput || this.forceEmbedded) {\n            const content = await (embeddedLines[this.entryKey] || (async () => [] as string[]))();\n            const lastIndex = content.length - 1;\n            if (content.length > 0 && content[lastIndex].endsWith(\"\\n\")) {\n                content[lastIndex] = content[lastIndex].slice(0, content[lastIndex].length - 1);\n            }\n            return {choice, content };\n        }\n        if (!this.inputContent) {\n            throw Error(\"No file was read\");\n        }\n\n        let contentToSplit = this.inputContent;\n        if (contentToSplit.endsWith(\"\\n\")) {\n            contentToSplit = contentToSplit.slice(0, contentToSplit.length - 1);\n        }\n        const splitContent = contentToSplit.split(\"\\n\");\n\n        return {\n            choice,\n            content: splitContent\n        };\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryInput.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryInput.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryInput.vue?vue&type=template&id=269a8728&scoped=true&lang=pug&\"\nimport script from \"./EntryInput.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryInput.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryInput.vue?vue&type=style&index=0&id=269a8728&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"269a8728\",\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Emit } from \"vue-property-decorator\";\nimport EntryTitle from \"@/components/EntryTitle.vue\";\nimport EntryInput from \"@/components/EntryInput.vue\";\nimport { EntryFileHandling, executeEntry } from \"../entries/entry\";\nimport { updateYear } from \"../state/state\";\n@Component({\n    components: {\n        EntryTitle,\n        EntryInput\n    }\n})\nexport default class EntryTemplate extends Vue {\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop({ default: false }) public disabled!: boolean;\n    @Prop({ required: true }) public year!: string;\n    @Prop({required: false, default: false}) public noInput!: boolean;\n    @Prop({required: true}) public entryKey!: string;\n    @Emit(\"file-loaded\")\n    public fileLoaded(fileHandling: EntryFileHandling) {\n        return fileHandling;\n    }\n\n    public mounted() {\n        updateYear(this.year);\n    }\n\n    public updated() {\n        updateYear(this.year);\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTemplate.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryTemplate.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryTemplate.vue?vue&type=template&id=088c78a5&scoped=true&lang=pug&\"\nimport script from \"./EntryTemplate.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryTemplate.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryTemplate.vue?vue&type=style&index=0&id=088c78a5&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"088c78a5\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"wrapper\"},[(_vm.canvasSize)?_c('div',{staticClass:\"screen-output\"},[_c('canvas',{ref:\"canvas\",attrs:{\"width\":_vm.canvasSize.width,\"height\":_vm.canvasSize.height}})]):_vm._e(),_c('div',{ref:\"output\",staticClass:\"output\",class:{hidden: _vm.hideOutput}},[_vm._v(_vm._s(_vm.text))])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport { Drawable, ScreenPrinter } from \"../entries/entry\";\nimport { Coordinate } from \"../support/geometry\";\n\ntype ScreenCallback = (\n    width: number,\n    height: number,\n    callback: ((context: CanvasRenderingContext2D | null) => void)\n) => void;\n\n@Component({})\nexport default class EntrySimpleOutput extends Vue {\n\n    public get hideOutput(): boolean {\n        return this.lines.length <= 0;\n    }\n\n    public get text() {\n        return this.lines.join(\"\\n\");\n    }\n    @Prop({ default: [] }) public lines!: string[];\n\n    public $refs!: {\n        output: HTMLDivElement,\n        canvas: HTMLCanvasElement\n    };\n\n    private canvasSize: {width: number, height: number} | null = null;\n\n    private shouldStopRenderer: boolean = false;\n\n    private toDraw: Drawable[] = [];\n    private ids: Set<string> = new Set<string>();\n\n    private context: CanvasRenderingContext2D | null = null;\n    private stop: boolean = false;\n\n    private pause: boolean = false;\n    private pauseFor?: number = undefined;\n\n    private manualRender: boolean = false;\n\n    public mounted() {\n        this.$emit(\"print-factory\", {\n            factory: async (size?: Coordinate): Promise<ScreenPrinter> => {\n            this.canvasSize = size ? {width: size.x, height: size.y} : {width: 300, height: 300};\n            this.ids = new Set<string>();\n            this.toDraw = [];\n            this.pause = false;\n            return {\n                add: async (item) => {\n                    if (!this.ids.has(item.id)) {\n                        this.toDraw.push(item);\n                        this.ids.add(item.id);\n                        this.startRender();\n                    } else {\n                        console.error(\"Duplicate ID, not adding: \" + item.id);\n                    }\n                },\n                remove: async (id) => {\n                    if (this.ids.has(id)) {\n                        const index = this.toDraw.findIndex((e) => e.id === id);\n                        this.toDraw.splice(index, 1);\n                        this.ids.delete(id);\n                    }\n                },\n                stop: async () => {\n                    this.renderIteration();\n                    this.context = null;\n                    console.log(\"Stopping render...\");\n                },\n                replace: async (items: Drawable[]) => {\n                    const newIds = new Set<string>(items.map((item) => item.id));\n                    if (newIds.size !== items.length) {\n                        console.error(\"There are duplicated IDs, not replacing\");\n                    }\n                    this.toDraw = [...items];\n                    this.ids = newIds;\n                    this.startRender();\n                },\n                pause: (times?: number) => {\n                    this.pauseFor = times;\n                    this.pause = true;\n                    return () => {\n                        this.pause = false;\n                    };\n                },\n                forceRender: () => {\n                    this.renderIteration();\n                },\n                changeColor: async (idOrIndex: string | number, color: string) => {\n                    const index: number = typeof idOrIndex === \"string\" ?\n                        this.toDraw.findIndex((e) => e.id === idOrIndex)\n                        : idOrIndex;\n                    if (index < 0 || index >= this.toDraw.length) {\n                        return;\n                    }\n                    this.toDraw[index].color = color;\n                },\n                setManualRender: () => {\n                    this.manualRender = true;\n                }\n            };\n        }, clear: () => this.canvasSize = null});\n    }\n\n    @Watch(\"text\")\n    public onTextChanged(val: string[], oldVal: string[]) {\n        this.$refs.output.scrollTop = this.$refs.output.scrollHeight;\n    }\n\n    private startRender() {\n        if (!this.stop && this.context === null) {\n            console.log(\"Starting render...\");\n            this.context = this.$refs.canvas.getContext(\"2d\");\n            if (this.manualRender) {\n                return;\n            }\n            const render = () => {\n                if (this.context !== null && this.canvasSize) {\n                    if (!this.pause) {\n                        this.renderIteration();\n                    }\n                    setTimeout(render, 1000 / 30);\n                } else {\n                    console.log(\"Render stopped\");\n                }\n            };\n            render();\n            // setTimeout(render, 1000/30);\n            console.log(\"Render started\");\n        } else {\n            if (this.stop) {\n                console.log(\"Component destroyed\");\n            }\n        }\n    }\n\n    private renderIteration() {\n        if (this.context && this.canvasSize) {\n            this.context.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);\n            for (const item of this.toDraw) {\n                this.context.beginPath();\n                if (item.type === \"rectangle\") {\n                    this.context.rect(item.c.x, item.c.y, item.size.x, item.size.y);\n                } else if (item.type === \"points\") {\n                    let isFirst = true;\n                    for (const point of item.points) {\n                        if (isFirst) {\n                            this.context.moveTo(point.x, point.y);\n                            isFirst = false;\n                        } else {\n                            this.context.lineTo(point.x, point.y);\n                        }\n                    }\n                }\n                this.context.fillStyle = item.color;\n                this.context.fill();\n            }\n        }\n\n    }\n\n    private destroyed() {\n        this.stop = true;\n        this.context = null;\n    }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntrySimpleOutput.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntrySimpleOutput.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntrySimpleOutput.vue?vue&type=template&id=94bbbadc&scoped=true&lang=pug&\"\nimport script from \"./EntrySimpleOutput.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntrySimpleOutput.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntrySimpleOutput.vue?vue&type=style&index=0&id=94bbbadc&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"94bbbadc\",\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport EntryTemplate from \"@/components/EntryTemplate.vue\";\nimport EntrySimpleOutput from \"@/components/EntrySimpleOutput.vue\";\nimport {\n    Entry,\n    executeEntry,\n    EntryFileHandling,\n    simpleOutputCallbackFactory,\n    ScreenPrinter\n} from \"../../entries/entry\";\nimport { Coordinate } from \"../../support/geometry\";\nimport { setTimeoutAsync } from \"../../support/async\";\n@Component({\n    components: {\n        EntryTemplate,\n        EntrySimpleOutput\n    }\n})\nexport default class SimpleEntryTemplate extends Vue {\n    public get showAdditionalInput(): boolean {\n        const hasAdditionalInput = (this.entry.metadata !== undefined) &&\n            (this.entry.metadata.hasAdditionalInput === true);\n        return hasAdditionalInput && this.showInput;\n    }\n\n    private get timeout() {\n        if (this.entry.metadata && this.entry.metadata!.suggestedDelay) {\n            return this.entry.metadata!.suggestedDelay;\n        }\n        return 0;\n    }\n\n    public get supportsQuickRunning() {\n        return this.entry.metadata && this.entry.metadata.supportsQuickRunning;\n    }\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: string;\n\n    public output: string[] = [];\n    private clearScreen?: () => void;\n\n    private quickRun = false;\n\n    private inputLine: string = \"\";\n\n    private executing = false;\n\n    private buffer: Array<string | null> = [];\n    private resolver: ((s: string | null) => void) | null = null;\n\n    private showInput: boolean = false;\n    private disabled: boolean = false;\n\n    private destroying = false;\n\n    private time: string = \"\";\n\n    private requireScreen?: (size?: Coordinate) => Promise<ScreenPrinter>;\n\n    private stopper?: () => Promise<void>;\n\n    private isCancelled = false;\n\n    public sendInput() {\n        const line = this.inputLine;\n        this.inputLine = \"\";\n        this.sendLine(line);\n    }\n\n    public sendClose() {\n        this.sendLine(null);\n    }\n\n    @Watch(\"$route\")\n    public onRouteChanged() {\n        this.output = [];\n    }\n\n    public readFactory(args: {factory: (c?: Coordinate) => Promise<ScreenPrinter>, clear: () => void}) {\n        this.requireScreen = async (size?: Coordinate) => {\n            const result = await args.factory(size);\n            this.stopper = result.stop;\n            return result;\n        };\n        this.clearScreen = args.clear;\n    }\n\n    @Watch(\"entry\")\n    public onEntryChanged() {\n        this.reset();\n        this.quickRun = false;\n    }\n\n    public beforeDestroy() {\n        this.reset();\n        this.destroying = true;\n        this.isCancelled = true;\n    }\n\n    public async readFile(fileHandling: EntryFileHandling) {\n        this.reset();\n        this.disabled = true;\n        this.showInput = true;\n        const additionalInputReader = this.showAdditionalInput ?\n            {\n                close: () => {\n                    this.showInput = false;\n                },\n                read: async () => {\n                    if (this.buffer.length > 0) {\n                        const res = this.buffer.shift()!;\n                        return res;\n                    }\n                    return await new Promise<string|null>((resolve, reject) => this.resolver = resolve);\n                }\n            } : undefined;\n        try {\n            this.executing = true;\n            const startTime = new Date().getTime();\n            await executeEntry({\n                entry: this.entry,\n                choice: fileHandling.choice,\n                lines: fileHandling.content,\n                outputCallback: simpleOutputCallbackFactory(this.output, () => this.destroying),\n                additionalInputReader,\n                screen: this.requireScreen ? { requireScreen: this.requireScreen } : undefined,\n                isCancelled: () => this.isCancelled,\n                pause: this.createPause(),\n                isQuickRunning: this.quickRun,\n                stopTimer: () => this.time = `${new Date().getTime() - startTime}ms`\n            });\n        } finally {\n            this.executing = false;\n            if (this.stopper) {\n                this.stopper();\n            }\n            this.disabled = false;\n        }\n    }\n\n    private createPause(): () => Promise<void> {\n        let lastPause = 0;\n        return async () => {\n            if (this.timeout === 0) {\n                const current = new Date().getTime();\n                if (current - lastPause < 500) {\n                    return;\n                } else {\n                    lastPause = current;\n                    await setTimeoutAsync(0);\n                }\n            } else {\n                await setTimeoutAsync(this.timeout);\n            }\n        };\n    }\n\n    private reset() {\n        if (this.clearScreen) {\n            this.clearScreen();\n        }\n        this.time = \"\";\n        this.executing = false;\n        this.output = [];\n    }\n\n    private sendLine(line: string | null) {\n        if (this.resolver !== null) {\n            const r = this.resolver;\n            this.resolver = null;\n            r(line);\n        } else {\n            this.buffer.push(line);\n        }\n    }\n\n}\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/ts-loader/index.js??ref--13-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SimpleEntryTemplate.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/ts-loader/index.js??ref--13-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SimpleEntryTemplate.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./SimpleEntryTemplate.vue?vue&type=template&id=1edd1b0a&scoped=true&lang=pug&\"\nimport script from \"./SimpleEntryTemplate.vue?vue&type=script&lang=ts&\"\nexport * from \"./SimpleEntryTemplate.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./SimpleEntryTemplate.vue?vue&type=style&index=0&id=1edd1b0a&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1edd1b0a\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('BaseMessageTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"year\":_vm.year,\"entry\":_vm.entry,\"messageHandler\":_vm.messageHandler,\"additionalReset\":_vm.reset}},[(_vm.showTicket)?_c('div',{staticClass:\"ticket\"},[_c('div',{staticClass:\"title\"},[_vm._v(\"Train Ticket\")]),_vm._l((_vm.ticketData),function(ticket){return _c('div',{key:ticket.id,staticClass:\"ticket-field\"},[_c('label',{staticClass:\"label\"},[_vm._v(_vm._s(ticket.label))]),_c('label',{staticClass:\"value\",class:{'highlighted': ticket.label.startsWith('departure')}},[_vm._v(_vm._s(ticket.value))])])})],2):_vm._e()])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('EntryTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"disabled\":_vm.executing,\"year\":_vm.year,\"entryKey\":this.entry.metadata.key},on:{\"file-loaded\":_vm.readFile}},[(_vm.supportsQuickRunning)?_c('div',{staticClass:\"quick-run\"},[_c('label',[_vm._v(\"Quick run\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.quickRun),expression:\"quickRun\"}],attrs:{\"type\":\"checkbox\",\"disabled\":_vm.executing},domProps:{\"checked\":Array.isArray(_vm.quickRun)?_vm._i(_vm.quickRun,null)>-1:(_vm.quickRun)},on:{\"change\":function($event){var $$a=_vm.quickRun,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.quickRun=$$a.concat([$$v]))}else{$$i>-1&&(_vm.quickRun=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.quickRun=$$c}}}}),(_vm.time)?_c('label',[_vm._v(\"Time: \"+_vm._s(_vm.time))]):_vm._e()]):_vm._e(),_c('div',{staticClass:\"output\"},[_c('EntrySimpleOutput',{key:_vm.$route.path,attrs:{\"lines\":_vm.output}})],1),_vm._t(\"default\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport {\n    Entry,\n    EntryFileHandling,\n    executeEntry,\n    MessageSender,\n    ScreenPrinter,\n    simpleOutputCallbackFactory\n} from \"../../../entries/entry\";\nimport EntryTemplate from \"@/components/EntryTemplate.vue\";\nimport EntrySimpleOutput from \"@/components/EntrySimpleOutput.vue\";\nimport { setTimeoutAsync } from \"../../../support/async\";\nimport { Coordinate } from \"../../../support/geometry\";\n\n@Component({\n    components: {\n        EntryTemplate,\n        EntrySimpleOutput\n    }\n})\nexport default class BaseMessageTemplate extends Vue {\n\n    public get supportsQuickRunning() {\n        return this.entry.metadata && this.entry.metadata.supportsQuickRunning;\n    }\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: number;\n    @Prop() public messageHandler!: MessageSender;\n    @Prop({required: false}) public additionalReset?: () => void;\n\n    private executing: boolean = false;\n    private time: string = \"\";\n\n    private timeout = 50;\n\n    private output: string[] = [];\n\n    private destroying = false;\n    private quickRun = false;\n\n    private shouldStop = false;\n\n    private clearScreen?: () => void;\n\n    @Watch(\"entry\")\n    public onEntryChanged() {\n        this.reset();\n        this.quickRun = false;\n    }\n\n    public beforeDestroy() {\n        this.quickRun = false;\n        this.reset();\n        this.destroying = true;\n    }\n\n    public async readFile(fileHandling: EntryFileHandling) {\n        this.reset();\n        this.executing = true;\n        const that = this;\n        try {\n            const startTime = new Date().getTime();\n            await executeEntry({\n                entry: this.entry,\n                choice: fileHandling.choice,\n                lines: fileHandling.content,\n                outputCallback: simpleOutputCallbackFactory(this.output, () => this.destroying),\n                isCancelled: () => that.shouldStop,\n                pause: this.createPause(),\n                isQuickRunning: this.quickRun,\n                stopTimer: () => this.time = `${new Date().getTime() - startTime}ms`,\n                sendMessage: this.quickRun ? undefined : this.messageHandler\n            });\n        } catch (e) {\n            throw e;\n        } finally {\n            this.executing = false;\n        }\n    }\n\n    private createPause(): (() => Promise<void>) {\n        let lastPause = 0;\n        return () => {\n            const promise = new Promise<void>((resolve, reject) => {\n                if (this.timeout > 0) {\n                    setTimeout(resolve , this.timeout);\n                } else {\n                    const currentTime = new Date().getTime();\n                    if (currentTime - lastPause > 500) {\n                        lastPause = currentTime;\n                        setTimeout(resolve, 0);\n                    } else {\n                        resolve();\n                    }\n                }\n            });\n            return promise;\n        };\n\n    }\n\n    private reset() {\n        if (this.additionalReset) {\n            this.additionalReset();\n        }\n        if (this.clearScreen) {\n            this.clearScreen();\n        }\n        this.time = \"\";\n        this.destroying = false;\n        this.shouldStop = false;\n        this.executing = false;\n        this.output = [];\n        if (this.entry.metadata && this.entry.metadata.suggestedDelay !== undefined) {\n            this.timeout = this.entry.metadata.suggestedDelay;\n        }\n    }\n}\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BaseMessageTemplate.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BaseMessageTemplate.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./BaseMessageTemplate.vue?vue&type=template&id=2e21404b&lang=pug&\"\nimport script from \"./BaseMessageTemplate.vue?vue&type=script&lang=ts&\"\nexport * from \"./BaseMessageTemplate.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./BaseMessageTemplate.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport {\n    Entry, MessageSender,\n} from \"../../../../entries/entry\";\nimport BaseMessageTemplate from \"../BaseMessageTemplate.vue\";\nimport {isTicketTranslationMessage} from \"../../../../entries/single-entries/2020/ticket-translation/communication\";\n\ninterface TicketData {\n    id: number;\n    value: number;\n    label: string;\n}\n@Component({\n    components: {\n        BaseMessageTemplate\n    }\n})\nexport default class TicketTranslationView extends Vue {\n\n@Prop({required: false, default: undefined}) public messageHandlerSetter?: (sender: MessageSender) => void;\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: number;\n\n    private showTicket = false;\n    private ticketData: TicketData[] = [];\n\n\n    private reset() {\n        this.showTicket = false;\n        this.ticketData.length = 0;\n    }\n    private async messageHandler(message: any): Promise<void> {\n        if (!isTicketTranslationMessage(message)) {\n            throw new Error(\"Invalid message\");\n        }\n        this.showTicket = true;\n        switch (message.type) {\n            case \"setup\":\n                this.ticketData = message.ticket.map((n, i) => {\n                    return {\n                        id: i,\n                        value: n,\n                        label: \"\"\n                    };\n                });\n                break;\n            case \"label\":\n                this.ticketData[message.index].label = message.label;\n                break;\n        }\n    }\n\n}\n","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TicketTranslationView.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TicketTranslationView.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./TicketTranslationView.vue?vue&type=template&id=061a032b&lang=pug&\"\nimport script from \"./TicketTranslationView.vue?vue&type=script&lang=ts&\"\nexport * from \"./TicketTranslationView.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./TicketTranslationView.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('BaseMessageTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"year\":_vm.year,\"entry\":_vm.entry,\"messageHandler\":_vm.messageHandler,\"additionalReset\":_vm.reset}},[(_vm.showGrid)?_c('div',{staticClass:\"grid\"},[_c('div',{staticClass:\"header\"},[_c('div',{staticClass:\"slider\"},[_c('label',[_vm._v(\"Time\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model.number\",value:(_vm.time),expression:\"time\",modifiers:{\"number\":true}}],attrs:{\"type\":\"range\",\"min\":_vm.minTime,\"max\":_vm.maxTime},domProps:{\"value\":(_vm.time)},on:{\"__r\":function($event){_vm.time=_vm._n($event.target.value)},\"blur\":function($event){return _vm.$forceUpdate()}}})]),_c('div',{staticClass:\"slider\"},[_c('label',[_vm._v(\"Depth\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model.number\",value:(_vm.depth),expression:\"depth\",modifiers:{\"number\":true}}],attrs:{\"type\":\"range\",\"min\":_vm.minDepth,\"max\":_vm.maxDepth},domProps:{\"value\":(_vm.depth)},on:{\"__r\":function($event){_vm.depth=_vm._n($event.target.value)},\"blur\":function($event){return _vm.$forceUpdate()}}})]),(this.get4dData)?_c('div',{staticClass:\"slider\"},[_c('label',[_vm._v(\"Hyper\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model.number\",value:(_vm.hyper),expression:\"hyper\",modifiers:{\"number\":true}}],attrs:{\"type\":\"range\",\"min\":_vm.minHyper,\"max\":_vm.maxHyper},domProps:{\"value\":(_vm.hyper)},on:{\"__r\":function($event){_vm.hyper=_vm._n($event.target.value)},\"blur\":function($event){return _vm.$forceUpdate()}}})]):_vm._e()]),_c('div',{staticClass:\"grid-output\"},_vm._l((this.getData()),function(line,index){return _c('div',{key:index,staticClass:\"grid-line\"},_vm._l((line),function(cell,index){return _c('div',{key:index,staticClass:\"grid-cell\"},[_vm._v(_vm._s(cell === \" \" ? \".\" : cell))])}),0)}),0)]):_vm._e()])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export class NotImplementedError extends Error {\r\n\r\n}\r\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport {\n    Entry, MessageSender,\n} from \"../../../../entries/entry\";\nimport BaseMessageTemplate from \"../BaseMessageTemplate.vue\";\nimport {isConwayCubesMessage} from \"../../../../entries/single-entries/2020/conway-cubes/communication\";\nimport { NotImplementedError } from \"../../../../support/error\";\n\n@Component({\n    components: {\n        BaseMessageTemplate\n    }\n})\nexport default class ConwayCubesView extends Vue {\n\n@Prop({required: false, default: undefined}) public messageHandlerSetter?: (sender: MessageSender) => void;\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: number;\n\n    public showGrid = false;\n    public minDepth = 0;\n    public maxDepth = 0;\n\n    public minHyper = 0;\n    public maxHyper = 0;\n    public hyper = 0;\n\n    public minTime = 0;\n    public maxTime = 0;\n\n    private time = 0;\n    private depth = 0;\n\n    private get3dData?: (time: number, depth: number) => string[][];\n    private get4dData?: (time: number, depth: number, hyper: number) => string[][];\n    public getData(): string[][] {\n        if (!this.showGrid) {\n            return [];\n        }\n        if (this.get3dData) {\n            return this.get3dData(this.time, this.depth);\n        } else if (this.get4dData) {\n            return this.get4dData(this.time, this.depth, this.hyper);\n        }\n        throw new NotImplementedError();\n    }\n\n    private reset() {\n        this.showGrid = false;\n        this.minDepth = 0;\n        this.maxDepth = 0;\n        this.minHyper = 0;\n        this.maxHyper = 0;\n        this.minTime = 0;\n        this.maxTime = 0;\n        this.time = 0;\n        this.depth = 0;\n        this.hyper = 0;\n        this.get3dData = undefined;\n        this.get4dData = undefined;\n    }\n    private async messageHandler(message: any): Promise<void> {\n        if (!isConwayCubesMessage(message)) {\n            throw new Error(\"Invalid message\");\n        }\n        if (message.type === \"3d\") {\n            this.minDepth = message.minDepth;\n            this.maxDepth = message.maxDepth;\n            this.maxTime = message.maxTime;\n            this.time = Math.min(this.maxTime, this.time);\n            this.depth = Math.max(this.minDepth, Math.min(this.depth, this.maxDepth));\n            this.get3dData = message.data as ((time: number, depth: number) => string[][]);\n        } else if (message.type === \"4d\") {\n            this.minDepth = message.minDepth;\n            this.maxDepth = message.maxDepth;\n            this.minHyper = message.minHyper!;\n            this.maxHyper = message.maxHyper!;\n            this.maxTime = message.maxTime;\n            this.time = Math.min(this.maxTime, this.time);\n            this.depth = Math.max(this.minDepth, Math.min(this.depth, this.maxDepth));\n            this.hyper = Math.max(this.minHyper, Math.min(this.hyper, this.maxHyper));\n            this.get4dData = message.data as ((time: number, depth: number, hyper: number) => string[][]);\n        } else {\n            throw new NotImplementedError();\n        }\n        this.showGrid = true;\n    }\n\n}\n","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConwayCubesView.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConwayCubesView.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ConwayCubesView.vue?vue&type=template&id=2d0c2e8a&scoped=true&lang=pug&\"\nimport script from \"./ConwayCubesView.vue?vue&type=script&lang=ts&\"\nexport * from \"./ConwayCubesView.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./ConwayCubesView.vue?vue&type=style&index=0&id=2d0c2e8a&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"2d0c2e8a\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('BaseMessageTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"year\":_vm.year,\"entry\":_vm.entry,\"messageHandler\":_vm.messageHandler,\"additionalReset\":_vm.reset}},[_c('div',{ref:\"grid\",staticClass:\"grid\"})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport {\n    Entry, MessageSender,\n} from \"../../../../entries/entry\";\nimport BaseMessageTemplate from \"../BaseMessageTemplate.vue\";\nimport { NotImplementedError } from \"../../../../support/error\";\n\nimport {defineGrid, extendHex } from \"honeycomb-grid\";\nimport { SVG } from \"@svgdotjs/svg.js\";\n\n\n@Component({\n    components: {\n        BaseMessageTemplate\n    }\n})\nexport default class ConwayCubesView extends Vue {\n\n@Prop({required: false, default: undefined}) public messageHandlerSetter?: (sender: MessageSender) => void;\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: number;\n\n    public mounted() {\n        const grid = this.$refs.grid as HTMLElement;\n        grid.innerHTML = \"\";\n        const draw = SVG();\n        const Hex = extendHex({ size: 5 });\n        const Grid = defineGrid(Hex);\n        // get the corners of a hex (they're the same for all hexes created with the same Hex factory)\n        const corners = Hex().corners();\n        // an SVG symbol can be reused\n        const hexSymbol = draw.symbol()\n            // map the corners' positions to a string and create a polygon\n            .polygon(corners.map(({ x, y }) => `${x},${y}`).join(\" \"))\n            .fill(\"none\")\n            .stroke({ width: 1, color: \"#999\" });\n\n        // render 10,000 hexes\n        Grid.rectangle({ width: 100, height: 100 }).forEach((hex) => {\n            const { x, y } = hex.toPoint();\n            // use hexSymbol and set its position for each hex\n            draw.use(hexSymbol).translate(x, y);\n        });\n        draw.addTo(grid);\n    }\n\n    private reset() {\n    }\n    private async messageHandler(message: any): Promise<void> {\n    }\n\n\n}\n","import mod from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./LobbyLayout.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../../node_modules/thread-loader/dist/cjs.js!../../../../../node_modules/babel-loader/lib/index.js!../../../../../node_modules/ts-loader/index.js??ref--13-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./LobbyLayout.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./LobbyLayout.vue?vue&type=template&id=d2e217b2&scoped=true&lang=pug&\"\nimport script from \"./LobbyLayout.vue?vue&type=script&lang=ts&\"\nexport * from \"./LobbyLayout.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./LobbyLayout.vue?vue&type=style&index=0&id=d2e217b2&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"d2e217b2\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('EntryTemplate',{attrs:{\"title\":_vm.title,\"id\":_vm.id,\"disabled\":_vm.executing,\"year\":_vm.year,\"entryKey\":this.entry.metadata.key},on:{\"file-loaded\":_vm.readFile}},[(_vm.supportsQuickRunning)?_c('div',{staticClass:\"quick-run\"},[_c('label',[_vm._v(\"Quick run\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.quickRun),expression:\"quickRun\"}],attrs:{\"type\":\"checkbox\",\"disabled\":_vm.executing},domProps:{\"checked\":Array.isArray(_vm.quickRun)?_vm._i(_vm.quickRun,null)>-1:(_vm.quickRun)},on:{\"change\":function($event){var $$a=_vm.quickRun,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.quickRun=$$a.concat([$$v]))}else{$$i>-1&&(_vm.quickRun=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.quickRun=$$c}}}}),(_vm.time)?_c('label',[_vm._v(\"Time: \"+_vm._s(_vm.time))]):_vm._e()]):_vm._e(),_c('div',{staticClass:\"input\",class:{transparent:!_vm.executing || _vm.quickRun}},[_c('button',{class:{transparent: !_vm.executing || _vm.running},on:{\"click\":_vm.play}},[_vm._v(\"Play\")]),_c('button',{class:{transparent: !_vm.executing || _vm.running},on:{\"click\":_vm.nextState}},[_vm._v(\"Next\")]),_c('button',{class:{transparent: !_vm.executing},on:{\"click\":_vm.stop}},[_vm._v(\"Stop\")]),_c('button',{class:{transparent: !_vm.executing || _vm.running},on:{\"click\":_vm.run}},[_vm._v(\"Toggle Run\")]),_c('button',{class:{transparent: !_vm.executing || !_vm.running},on:{\"click\":_vm.run}},[_vm._v(\"Pause\")]),_c('div',{staticClass:\"speed\"},[_c('label',[_vm._v(\"Animation delay\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.timeout),expression:\"timeout\"}],attrs:{\"type\":\"number\",\"min\":\"0\",\"step\":\"10\"},domProps:{\"value\":(_vm.timeout)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.timeout=$event.target.value}}})])]),_c('div',{staticClass:\"output\"},[_c('EntrySimpleOutput',{key:_vm.$route.path,attrs:{\"lines\":_vm.output},on:{\"print-factory\":_vm.readFactory}})],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Watch } from \"vue-property-decorator\";\nimport {\n    Entry,\n    EntryFileHandling,\n    executeEntry,\n    ScreenPrinter,\n    simpleOutputCallbackFactory\n} from \"../../entries/entry\";\nimport EntryTemplate from \"@/components/EntryTemplate.vue\";\nimport EntrySimpleOutput from \"@/components/EntrySimpleOutput.vue\";\nimport { setTimeoutAsync } from \"../../support/async\";\nimport { isTimeoutMessage } from \"../../entries/entryStatusMessages\";\nimport { Coordinate } from \"../../support/geometry\";\n\n@Component({\n    components: {\n        EntryTemplate,\n        EntrySimpleOutput\n    }\n})\nexport default class EntryWithPauseAndRun extends Vue {\n\n    public get supportsQuickRunning() {\n        return this.entry.metadata && this.entry.metadata.supportsQuickRunning;\n    }\n    @Prop() public title!: string;\n    @Prop() public id!: number;\n    @Prop() public entry!: Entry;\n    @Prop() public year!: number;\n\n    private executing: boolean = false;\n    private resolver?: () => void;\n    private shouldStop: boolean = false;\n    private shouldRun: boolean = false;\n    private running: boolean = false;\n    private time: string = \"\";\n\n    private timeout = 50;\n\n    private output: string[] = [];\n\n    private requireScreen?: (size?: Coordinate) => Promise<ScreenPrinter>;\n    private screenPrinter?: ScreenPrinter;\n\n    private destroying = false;\n    private quickRun = false;\n\n    private clearScreen?: () => void;\n\n    @Watch(\"entry\")\n    public onEntryChanged() {\n        this.reset();\n        this.quickRun = false;\n    }\n\n    public readFactory(args: {factory: (c?: Coordinate) => Promise<ScreenPrinter>, clear: () => void}) {\n        this.clearScreen = args.clear;\n        this.requireScreen = async (size?: Coordinate) => {\n            const result = await args.factory(size);\n            this.screenPrinter = result;\n            return result;\n        };\n    }\n\n    public beforeDestroy() {\n        this.quickRun = false;\n        this.reset();\n        this.destroying = true;\n        if (this.screenPrinter) {\n            this.screenPrinter.stop();\n        }\n    }\n\n    public async readFile(fileHandling: EntryFileHandling) {\n        this.reset();\n        this.executing = true;\n        const that = this;\n        try {\n            const startTime = new Date().getTime();\n            await executeEntry({\n                entry: this.entry,\n                choice: fileHandling.choice,\n                lines: fileHandling.content,\n                outputCallback: simpleOutputCallbackFactory(this.output, () => this.destroying),\n                isCancelled: () => that.shouldStop,\n                pause: this.createPause(),\n                screen: this.requireScreen && !this.quickRun ? { requireScreen: this.requireScreen } : undefined,\n                isQuickRunning: this.quickRun,\n                stopTimer: () => this.time = `${new Date().getTime() - startTime}ms`\n            });\n        } catch (e) {\n            throw e;\n        } finally {\n            this.executing = false;\n            if (this.screenPrinter) {\n                this.screenPrinter.stop();\n            }\n        }\n    }\n\n    public play() {\n        this.shouldRun = true;\n        this.nextState();\n    }\n\n    public stop() {\n        this.shouldStop = true;\n        this.running = false;\n        this.nextState();\n    }\n\n    public run() {\n        this.shouldRun = !this.shouldRun;\n    }\n    public nextState() {\n        if (this.resolver) {\n            const resolver = this.resolver;\n            this.resolver = undefined;\n            resolver();\n        }\n    }\n\n    private createPause(): (() => Promise<void>) {\n        let drawingPause: (() => void) | undefined;\n        let lastPause = 0;\n        return () => {\n            const promise = new Promise<void>((resolve, reject) => {\n                if (this.shouldRun) {\n                    this.running = true;\n                    const resolver = drawingPause ? () => {\n                        if (drawingPause) {\n                            drawingPause();\n                            drawingPause = undefined;\n                        }\n                        resolve();\n                    } : resolve;\n                    if (this.timeout > 0) {\n                        setTimeout(resolver , this.timeout);\n                    } else {\n                        const currentTime = new Date().getTime();\n                        if (currentTime - lastPause > 500) {\n                            lastPause = currentTime;\n                            setTimeout(resolver, 0);\n                        } else {\n                            resolver();\n                        }\n                    }\n                } else {\n                    this.running = false;\n                    if (!drawingPause && this.screenPrinter) {\n                        drawingPause = this.screenPrinter.pause();\n                    }\n                    if (this.screenPrinter) {\n                        this.screenPrinter.forceRender();\n                    }\n                    this.resolver = resolve;\n                }\n            });\n            return promise;\n        };\n\n    }\n\n    private reset() {\n        if (this.clearScreen) {\n            this.clearScreen();\n        }\n        if (this.running) {\n            this.stop();\n        }\n        this.time = \"\";\n        this.destroying = false;\n        this.running = false;\n        this.shouldRun = false;\n        this.shouldStop = false;\n        this.executing = false;\n        this.output = [];\n        if (this.entry.metadata && this.entry.metadata.suggestedDelay !== undefined) {\n            this.timeout = this.entry.metadata.suggestedDelay;\n        }\n    }\n}\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/ts-loader/index.js??ref--13-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryWithPauseAndRun.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/ts-loader/index.js??ref--13-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./EntryWithPauseAndRun.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./EntryWithPauseAndRun.vue?vue&type=template&id=215d3686&lang=pug&\"\nimport script from \"./EntryWithPauseAndRun.vue?vue&type=script&lang=ts&\"\nexport * from \"./EntryWithPauseAndRun.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./EntryWithPauseAndRun.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import { VueConstructor } from \"vue\";\nimport { Vue } from \"vue-property-decorator\";\nimport { Entry } from \"./entry\";\n\nimport {ticketTranslation} from \"./single-entries/2020/ticket-translation\";\nimport TicketTranslationView from \"../views/entries/custom/2020/TicketTranslationView.vue\";\n\nimport { conwayCubes } from \"./single-entries/2020/conway-cubes\";\nimport ConwayCubesView from \"../views/entries/custom/2020/ConwayCubesView.vue\";\n\nimport { lobbyLayout } from \"./single-entries/2020/lobby-layout\";\nimport LobbyLayout from \"../views/entries/custom/2020/LobbyLayout.vue\";\n\nimport EntryWithPauseAndRun from \"@/views/entries/EntryWithPauseAndRun.vue\";\n\nimport {entries as entries2015} from \"./single-entries/2015\";\nimport {entries as entries2016} from \"./single-entries/2016\";\nimport {entries as entries2017} from \"./single-entries/2017\";\nimport {entries as entries2018} from \"./single-entries/2018\";\nimport {entries as entries2019} from \"./single-entries/2019\";\nimport {entries as entries2020} from \"./single-entries/2020\";\n\ninterface EntryMap {[key: string]: VueConstructor<Vue>; }\n\nconst keyMap: EntryMap = {\n    \"pause-and-run\": EntryWithPauseAndRun\n};\n\nconst buildMap = (tuples: Array<[Entry, VueConstructor<Vue>]>, entries: Entry[]): EntryMap => {\n    return entries.reduce((acc, next) => {\n        if (next.metadata && next.metadata.customComponent) {\n            const component = keyMap[next.metadata.customComponent];\n            acc[next.metadata.key] = component;\n        }\n        return acc;\n    },\n    tuples.reduce((acc, next) => {\n        acc[next[0].metadata!.key] = next[1];\n        return acc;\n    }, {} as EntryMap)\n    );\n};\n\nconst map2020: EntryMap = buildMap([\n    [ticketTranslation, TicketTranslationView],\n    [conwayCubes, ConwayCubesView],\n    [lobbyLayout, LobbyLayout]\n], entries2020);\n\nexport const map: { [key: string]: VueConstructor<Vue> } = [\n    buildMap([], entries2015),\n    buildMap([], entries2016),\n    buildMap([], entries2017),\n    buildMap([], entries2018),\n    buildMap([], entries2019),\n    map2020\n].reduce((acc, next) => {\n    for (const key in next) {\n        if (key in next) {\n            acc[key] = next[key];\n        }\n    }\n    return acc;\n}, {});\n","import Vue, { VueConstructor } from \"vue\";\nimport Router, { RouteConfig } from \"vue-router\";\nimport Home from \"./views/Home.vue\";\nimport Entries from \"./views/Entries.vue\";\nimport SimpleEntryTemplate from \"./views/entries/SimpleEntryTemplate.vue\";\nimport TicketTranslationView from \"@/views/entries/custom/2020/TicketTranslationView.vue\";\n\nimport { entryList, EntryRoute } from \"./entries/entryList\";\nimport { map as entryComponentMap } from \"./entries/entryMap\";\n\nVue.use(Router);\n\nconst routes: RouteConfig[] = [\n  {\n    path: \"/\",\n    name: \"home\",\n    component: Home,\n    props: {\n      years: Object.keys(entryList)\n    }\n  },\n  {\n    path: \"/entry\",\n    name: \"entries\",\n    component: Entries\n  }\n];\n\nconst getTemplate = (entry: EntryRoute): VueConstructor<Vue> => {\n  if (entry.name in entryComponentMap) {\n    return entryComponentMap[entry.name];\n  }\n  // else if (entry.entry.metadata && entry.entry.metadata.customComponent) {\n  //   if (entry.entry.metadata.customComponent === \"pause-and-run\") {\n  //     return EntryWithPauseAndRun;\n  //   } else if (entry.entry.metadata.customComponent === \"ticket-translation\") {\n  //     return TicketTranslationView;\n  //   }\n  // }\n  return SimpleEntryTemplate;\n};\n\nconst flat = Object.keys(entryList)\n  .map((year) => entryList[year].map((entry, index) => ({ entry, year })))\n  .filter((k) => k);\nflat.flatMap((k) => k).forEach((k) => {\n  routes.push({\n    name: k.entry.name,\n    path: `/entry/${k.entry.name}`,\n    component: getTemplate(k.entry),\n    props: {\n      id: k.entry.date,\n      title: k.entry.title,\n      entry: k.entry.entry,\n      year: k.year,\n      stars: k.entry.stars || 0\n    }\n  });\n});\n\n\n\nexport default new Router({\n  mode: \"hash\",\n  base: process.env.BASE_URL,\n  routes\n});\n","import Vue from \"vue\";\nimport App from \"./App.vue\";\nimport router from \"./router\";\n\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport {\n  faSnowman,\n  faSnowflake,\n  faHollyBerry,\n  faGift,\n  faCandyCane,\n  faSleigh,\n  faLink\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/vue-fontawesome\";\n\nlibrary.add(\n  faSnowman,\n  faSnowflake,\n  faHollyBerry,\n  faGift,\n  faCandyCane,\n  faSleigh,\n  faLink\n);\n\nVue.component(\"font-awesome-icon\", FontAwesomeIcon);\n\nVue.config.productionTip = false;\n\nnew Vue({\n  router,\n  render: (h) => h(App),\n}).$mount(\"#app\");\n","export * from \"-!../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BaseMessageTemplate.vue?vue&type=style&index=0&lang=scss&\"","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TicketTranslationView.vue?vue&type=style&index=0&lang=scss&\""],"sourceRoot":""}